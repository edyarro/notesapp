"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareDiff = prepareDiff;
exports.appendObject = appendObject;
const fs = require("fs-extra");
const uuid = require("uuid");
const __1 = require("..");
const cfnApi = require("../../../api/deployments/cfn-api");
const resource_import_1 = require("../../../api/resource-import");
const toolkit_error_1 = require("../../../toolkit/toolkit-error");
const util_1 = require("../../../util");
const mapping_helpers_1 = require("../../refactor/private/mapping-helpers");
function prepareDiff(ioHelper, stacks, deployments, sdkProvider, options) {
    switch (options.method?.method ?? __1.DiffMethod.ChangeSet().method) {
        case 'local-file':
            return localFileDiff(stacks, options);
        case 'template-only':
            return cfnDiff(ioHelper, stacks, deployments, options, sdkProvider, false);
        case 'change-set':
            return cfnDiff(ioHelper, stacks, deployments, options, sdkProvider, true);
        default:
            throw new toolkit_error_1.ToolkitError((0, util_1.formatErrorMessage)(`Unknown diff method ${options.method}`));
    }
}
async function localFileDiff(stacks, options) {
    const methodOptions = (options.method?.options ?? {});
    // Compare single stack against fixed template
    if (stacks.stackCount !== 1) {
        throw new toolkit_error_1.ToolkitError('Can only select one stack when comparing to fixed template. Use --exclusively to avoid selecting multiple stacks.');
    }
    if (!(await fs.pathExists(methodOptions.path))) {
        throw new toolkit_error_1.ToolkitError(`There is no file at ${methodOptions.path}`);
    }
    const file = fs.readFileSync(methodOptions.path).toString();
    const template = (0, util_1.deserializeStructure)(file);
    return [{
            oldTemplate: template,
            newTemplate: stacks.firstStack,
        }];
}
async function cfnDiff(ioHelper, stacks, deployments, options, sdkProvider, includeChangeSet) {
    const templateInfos = [];
    const methodOptions = (options.method?.options ?? {});
    const allMappings = options.includeMoves
        ? await (0, mapping_helpers_1.mappingsByEnvironment)(stacks.stackArtifacts, sdkProvider, true)
        : [];
    // Compare N stacks against deployed templates
    for (const stack of stacks.stackArtifacts) {
        const templateWithNestedStacks = await deployments.readCurrentTemplateWithNestedStacks(stack, methodOptions.compareAgainstProcessedTemplate);
        const currentTemplate = templateWithNestedStacks.deployedRootTemplate;
        const nestedStacks = templateWithNestedStacks.nestedStacks;
        const migrator = new resource_import_1.ResourceMigrator({ deployments, ioHelper });
        const resourcesToImport = await migrator.tryGetResources(await deployments.resolveEnvironment(stack));
        if (resourcesToImport) {
            (0, resource_import_1.removeNonImportResources)(stack);
        }
        const changeSet = includeChangeSet ? await changeSetDiff(ioHelper, deployments, stack, sdkProvider, resourcesToImport, methodOptions.parameters, methodOptions.fallbackToTemplate, methodOptions.importExistingResources) : undefined;
        const mappings = allMappings.find(m => m.environment.region === stack.environment.region && m.environment.account === stack.environment.account)?.mappings ?? {};
        templateInfos.push({
            oldTemplate: currentTemplate,
            newTemplate: stack,
            isImport: !!resourcesToImport,
            nestedStacks,
            changeSet,
            mappings,
        });
    }
    return templateInfos;
}
async function changeSetDiff(ioHelper, deployments, stack, sdkProvider, resourcesToImport, parameters = {}, fallBackToTemplate = true, importExistingResources = false) {
    let stackExists = false;
    try {
        stackExists = await deployments.stackExists({
            stack,
            deployName: stack.stackName,
            tryLookupRole: true,
        });
    }
    catch (e) {
        if (!fallBackToTemplate) {
            throw new toolkit_error_1.ToolkitError(`describeStacks call failed with ${e} for ${stack.stackName}, set fallBackToTemplate to true or use DiffMethod.templateOnly to base the diff on template differences.`);
        }
        await ioHelper.defaults.debug(`Checking if the stack ${stack.stackName} exists before creating the changeset has failed, will base the diff on template differences.\n`);
        await ioHelper.defaults.debug((0, util_1.formatErrorMessage)(e));
        stackExists = false;
    }
    if (stackExists) {
        return cfnApi.createDiffChangeSet(ioHelper, {
            stack,
            uuid: uuid.v4(),
            deployments,
            willExecute: false,
            sdkProvider,
            parameters: parameters,
            resourcesToImport,
            failOnError: !fallBackToTemplate,
            importExistingResources,
        });
    }
    else {
        if (!fallBackToTemplate) {
            throw new toolkit_error_1.ToolkitError(`the stack '${stack.stackName}' has not been deployed to CloudFormation, set fallBackToTemplate to true or use DiffMethod.templateOnly to base the diff on template differences.`);
        }
        await ioHelper.defaults.debug(`the stack '${stack.stackName}' has not been deployed to CloudFormation, skipping changeset creation.`);
        return;
    }
}
/**
 * Appends all properties from obj2 to obj1.
 * obj2 values take priority in the case of collisions.
 *
 * @param obj1 - The object to modify
 * @param obj2 - The object to consume
 *
 * @returns obj1 with all properties from obj2
 */
function appendObject(obj1, obj2) {
    // Directly modify obj1 by adding all properties from obj2
    for (const key in obj2) {
        obj1[key] = obj2[key];
    }
    // Return the modified obj1
    return obj1;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFpQkEsa0NBaUJDO0FBNklELG9DQVdDO0FBekxELCtCQUErQjtBQUMvQiw2QkFBNkI7QUFFN0IsMEJBQWdDO0FBSWhDLDJEQUEyRDtBQUkzRCxrRUFBMEY7QUFDMUYsa0VBQThEO0FBQzlELHdDQUF5RTtBQUN6RSw0RUFBK0U7QUFFL0UsU0FBZ0IsV0FBVyxDQUN6QixRQUFrQixFQUNsQixNQUF1QixFQUN2QixXQUF3QixFQUN4QixXQUF3QixFQUN4QixPQUFvQjtJQUVwQixRQUFRLE9BQU8sQ0FBQyxNQUFNLEVBQUUsTUFBTSxJQUFJLGNBQVUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNoRSxLQUFLLFlBQVk7WUFDZixPQUFPLGFBQWEsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDeEMsS0FBSyxlQUFlO1lBQ2xCLE9BQU8sT0FBTyxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDN0UsS0FBSyxZQUFZO1lBQ2YsT0FBTyxPQUFPLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM1RTtZQUNFLE1BQU0sSUFBSSw0QkFBWSxDQUFDLElBQUEseUJBQWtCLEVBQUMsdUJBQXVCLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDeEYsQ0FBQztBQUNILENBQUM7QUFFRCxLQUFLLFVBQVUsYUFBYSxDQUFDLE1BQXVCLEVBQUUsT0FBb0I7SUFDeEUsTUFBTSxhQUFhLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxFQUFFLENBQXlCLENBQUM7SUFFOUUsOENBQThDO0lBQzlDLElBQUks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QVUsRUFBRSxVQUFVO1lBQ3RCLGlCQUFpQjtZQUNqQixXQUFXLEVBQUUsQ0FBQyxrQkFBa0I7WUFDaEMsdUJBQXVCO1NBQ3hCLENBQUMsQ0FBQztJQUNMLENBQUM7U0FBTSxDQUFDO1FBQ04sSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDeEIsTUFBTSxJQUFJLDRCQUFZLENBQUMsY0FBYyxLQUFLLENBQUMsU0FBUyxvSkFBb0osQ0FBQyxDQUFDO1FBQzVNLENBQUM7UUFFRCxNQUFNLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLGNBQWMsS0FBSyxDQUFDLFNBQVMseUVBQXlFLENBQUMsQ0FBQztRQUN0SSxPQUFPO0lBQ1QsQ0FBQztBQUNILENBQUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILFNBQWdCLFlBQVksQ0FDMUIsSUFBMkIsRUFDM0IsSUFBMkI7SUFFM0IsMERBQTBEO0lBQzFELEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQsMkJBQTJCO0lBQzNCLE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHV1aWQgZnJvbSAndXVpZCc7XG5pbXBvcnQgdHlwZSB7IENoYW5nZVNldERpZmZPcHRpb25zLCBEaWZmT3B0aW9ucywgTG9jYWxGaWxlRGlmZk9wdGlvbnMgfSBmcm9tICcuLic7XG5pbXBvcnQgeyBEaWZmTWV0aG9kIH0gZnJvbSAnLi4nO1xuaW1wb3J0IHR5cGUgeyBTZGtQcm92aWRlciB9IGZyb20gJy4uLy4uLy4uL2FwaS9hd3MtYXV0aC9wcml2YXRlJztcbmltcG9ydCB0eXBlIHsgU3RhY2tDb2xsZWN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vYXBpL2Nsb3VkLWFzc2VtYmx5L3N0YWNrLWNvbGxlY3Rpb24nO1xuaW1wb3J0IHR5cGUgeyBEZXBsb3ltZW50cyB9IGZyb20gJy4uLy4uLy4uL2FwaS9kZXBsb3ltZW50cyc7XG5pbXBvcnQgKiBhcyBjZm5BcGkgZnJvbSAnLi4vLi4vLi4vYXBpL2RlcGxveW1lbnRzL2Nmbi1hcGknO1xuaW1wb3J0IHR5cGUgeyBUZW1wbGF0ZUluZm8gfSBmcm9tICcuLi8uLi8uLi9hcGkvZGlmZic7XG5pbXBvcnQgdHlwZSB7IElvSGVscGVyIH0gZnJvbSAnLi4vLi4vLi4vYXBpL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBSZXNvdXJjZXNUb0ltcG9ydCB9IGZyb20gJy4uLy4uLy4uL2FwaS9yZXNvdXJjZS1pbXBvcnQnO1xuaW1wb3J0IHsgcmVtb3ZlTm9uSW1wb3J0UmVzb3VyY2VzLCBSZXNvdXJjZU1pZ3JhdG9yIH0gZnJvbSAnLi4vLi4vLi4vYXBpL3Jlc291cmNlLWltcG9ydCc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi8uLi90b29sa2l0L3Rvb2xraXQtZXJyb3InO1xuaW1wb3J0IHsgZGVzZXJpYWxpemVTdHJ1Y3R1cmUsIGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgbWFwcGluZ3NCeUVudmlyb25tZW50IH0gZnJvbSAnLi4vLi4vcmVmYWN0b3IvcHJpdmF0ZS9tYXBwaW5nLWhlbHBlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZURpZmYoXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgc3RhY2tzOiBTdGFja0NvbGxlY3Rpb24sXG4gIGRlcGxveW1lbnRzOiBEZXBsb3ltZW50cyxcbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICBvcHRpb25zOiBEaWZmT3B0aW9ucyxcbik6IFByb21pc2U8VGVtcGxhdGVJbmZvW10+IHtcbiAgc3dpdGNoIChvcHRpb25zLm1ldGhvZD8ubWV0aG9kID8/IERpZmZNZXRob2QuQ2hhbmdlU2V0KCkubWV0aG9kKSB7XG4gICAgY2FzZSAnbG9jYWwtZmlsZSc6XG4gICAgICByZXR1cm4gbG9jYWxGaWxlRGlmZihzdGFja3MsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ3RlbXBsYXRlLW9ubHknOlxuICAgICAgcmV0dXJuIGNmbkRpZmYoaW9IZWxwZXIsIHN0YWNrcywgZGVwbG95bWVudHMsIG9wdGlvbnMsIHNka1Byb3ZpZGVyLCBmYWxzZSk7XG4gICAgY2FzZSAnY2hhbmdlLXNldCc6XG4gICAgICByZXR1cm4gY2ZuRGlmZihpb0hlbHBlciwgc3RhY2tzLCBkZXBsb3ltZW50cywgb3B0aW9ucywgc2RrUHJvdmlkZXIsIHRydWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGZvcm1hdEVycm9yTWVzc2FnZShgVW5rbm93biBkaWZmIG1ldGhvZCAke29wdGlvbnMubWV0aG9kfWApKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBsb2NhbEZpbGVEaWZmKHN0YWNrczogU3RhY2tDb2xsZWN0aW9uLCBvcHRpb25zOiBEaWZmT3B0aW9ucyk6IFByb21pc2U8VGVtcGxhdGVJbmZvW10+IHtcbiAgY29uc3QgbWV0aG9kT3B0aW9ucyA9IChvcHRpb25zLm1ldGhvZD8ub3B0aW9ucyA/PyB7fSkgYXMgTG9jYWxGaWxlRGlmZk9wdGlvbnM7XG5cbiAgLy8gQ29tcGFyZSBzaW5nbGUgc3RhY2sgYWdhaW5zdCBmaXhlZCB0ZW1wbGF0ZVxuICBpZiAoc3RhY2tzLnN0YWNrQ291bnQgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgJ0NhbiBvbmx5IHNlbGVjdCBvbmUgc3RhY2sgd2hlbiBjb21wYXJpbmcgdG8gZml4ZWQgdGVtcGxhdGUuIFVzZSAtLWV4Y2x1c2l2ZWx5IHRvIGF2b2lkIHNlbGVjdGluZyBtdWx0aXBsZSBzdGFja3MuJyxcbiAgICApO1xuICB9XG5cbiAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhtZXRob2RPcHRpb25zLnBhdGgpKSkge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFRoZXJlIGlzIG5vIGZpbGUgYXQgJHttZXRob2RPcHRpb25zLnBhdGh9YCk7XG4gIH1cblxuICBjb25zdCBmaWxlID0gZnMucmVhZEZpbGVTeW5jKG1ldGhvZE9wdGlvbnMucGF0aCkudG9TdHJpbmcoKTtcbiAgY29uc3QgdGVtcGxhdGUgPSBkZXNlcmlhbGl6ZVN0cnVjdHVyZShmaWxlKTtcblxuICByZXR1cm4gW3tcbiAgICBvbGRUZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgbmV3VGVtcGxhdGU6IHN0YWNrcy5maXJzdFN0YWNrLFxuICB9XTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2ZuRGlmZihcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICBzdGFja3M6IFN0YWNrQ29sbGVjdGlvbixcbiAgZGVwbG95bWVudHM6IERlcGxveW1lbnRzLFxuICBvcHRpb25zOiBEaWZmT3B0aW9ucyxcbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICBpbmNsdWRlQ2hhbmdlU2V0OiBib29sZWFuLFxuKTogUHJvbWlzZTxUZW1wbGF0ZUluZm9bXT4ge1xuICBjb25zdCB0ZW1wbGF0ZUluZm9zID0gW107XG4gIGNvbnN0IG1ldGhvZE9wdGlvbnMgPSAob3B0aW9ucy5tZXRob2Q/Lm9wdGlvbnMgPz8ge30pIGFzIENoYW5nZVNldERpZmZPcHRpb25zO1xuXG4gIGNvbnN0IGFsbE1hcHBpbmdzID0gb3B0aW9ucy5pbmNsdWRlTW92ZXNcbiAgICA/IGF3YWl0IG1hcHBpbmdzQnlFbnZpcm9ubWVudChzdGFja3Muc3RhY2tBcnRpZmFjdHMsIHNka1Byb3ZpZGVyLCB0cnVlKVxuICAgIDogW107XG5cbiAgLy8gQ29tcGFyZSBOIHN0YWNrcyBhZ2FpbnN0IGRlcGxveWVkIHRlbXBsYXRlc1xuICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcy5zdGFja0FydGlmYWN0cykge1xuICAgIGNvbnN0IHRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcyA9IGF3YWl0IGRlcGxveW1lbnRzLnJlYWRDdXJyZW50VGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzKFxuICAgICAgc3RhY2ssXG4gICAgICBtZXRob2RPcHRpb25zLmNvbXBhcmVBZ2FpbnN0UHJvY2Vzc2VkVGVtcGxhdGUsXG4gICAgKTtcbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSB0ZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3MuZGVwbG95ZWRSb290VGVtcGxhdGU7XG4gICAgY29uc3QgbmVzdGVkU3RhY2tzID0gdGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzLm5lc3RlZFN0YWNrcztcblxuICAgIGNvbnN0IG1pZ3JhdG9yID0gbmV3IFJlc291cmNlTWlncmF0b3IoeyBkZXBsb3ltZW50cywgaW9IZWxwZXIgfSk7XG4gICAgY29uc3QgcmVzb3VyY2VzVG9JbXBvcnQgPSBhd2FpdCBtaWdyYXRvci50cnlHZXRSZXNvdXJjZXMoYXdhaXQgZGVwbG95bWVudHMucmVzb2x2ZUVudmlyb25tZW50KHN0YWNrKSk7XG4gICAgaWYgKHJlc291cmNlc1RvSW1wb3J0KSB7XG4gICAgICByZW1vdmVOb25JbXBvcnRSZXNvdXJjZXMoc3RhY2spO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZVNldCA9IGluY2x1ZGVDaGFuZ2VTZXQgPyBhd2FpdCBjaGFuZ2VTZXREaWZmKFxuICAgICAgaW9IZWxwZXIsXG4gICAgICBkZXBsb3ltZW50cyxcbiAgICAgIHN0YWNrLFxuICAgICAgc2RrUHJvdmlkZXIsXG4gICAgICByZXNvdXJjZXNUb0ltcG9ydCxcbiAgICAgIG1ldGhvZE9wdGlvbnMucGFyYW1ldGVycyxcbiAgICAgIG1ldGhvZE9wdGlvbnMuZmFsbGJhY2tUb1RlbXBsYXRlLFxuICAgICAgbWV0aG9kT3B0aW9ucy5pbXBvcnRFeGlzdGluZ1Jlc291cmNlcyxcbiAgICApIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgbWFwcGluZ3MgPSBhbGxNYXBwaW5ncy5maW5kKG0gPT5cbiAgICAgIG0uZW52aXJvbm1lbnQucmVnaW9uID09PSBzdGFjay5lbnZpcm9ubWVudC5yZWdpb24gJiYgbS5lbnZpcm9ubWVudC5hY2NvdW50ID09PSBzdGFjay5lbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICk/Lm1hcHBpbmdzID8/IHt9O1xuXG4gICAgdGVtcGxhdGVJbmZvcy5wdXNoKHtcbiAgICAgIG9sZFRlbXBsYXRlOiBjdXJyZW50VGVtcGxhdGUsXG4gICAgICBuZXdUZW1wbGF0ZTogc3RhY2ssXG4gICAgICBpc0ltcG9ydDogISFyZXNvdXJjZXNUb0ltcG9ydCxcbiAgICAgIG5lc3RlZFN0YWNrcyxcbiAgICAgIGNoYW5nZVNldCxcbiAgICAgIG1hcHBpbmdzLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRlbXBsYXRlSW5mb3M7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNoYW5nZVNldERpZmYoXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgZGVwbG95bWVudHM6IERlcGxveW1lbnRzLFxuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gIHJlc291cmNlc1RvSW1wb3J0PzogUmVzb3VyY2VzVG9JbXBvcnQsXG4gIHBhcmFtZXRlcnM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9ID0ge30sXG4gIGZhbGxCYWNrVG9UZW1wbGF0ZTogYm9vbGVhbiA9IHRydWUsXG4gIGltcG9ydEV4aXN0aW5nUmVzb3VyY2VzOiBib29sZWFuID0gZmFsc2UsXG4pOiBQcm9taXNlPGFueSB8IHVuZGVmaW5lZD4ge1xuICBsZXQgc3RhY2tFeGlzdHMgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBzdGFja0V4aXN0cyA9IGF3YWl0IGRlcGxveW1lbnRzLnN0YWNrRXhpc3RzKHtcbiAgICAgIHN0YWNrLFxuICAgICAgZGVwbG95TmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgdHJ5TG9va3VwUm9sZTogdHJ1ZSxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgaWYgKCFmYWxsQmFja1RvVGVtcGxhdGUpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYGRlc2NyaWJlU3RhY2tzIGNhbGwgZmFpbGVkIHdpdGggJHtlfSBmb3IgJHtzdGFjay5zdGFja05hbWV9LCBzZXQgZmFsbEJhY2tUb1RlbXBsYXRlIHRvIHRydWUgb3IgdXNlIERpZmZNZXRob2QudGVtcGxhdGVPbmx5IHRvIGJhc2UgdGhlIGRpZmYgb24gdGVtcGxhdGUgZGlmZmVyZW5jZXMuYCk7XG4gICAgfVxuXG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoYENoZWNraW5nIGlmIHRoZSBzdGFjayAke3N0YWNrLnN0YWNrTmFtZX0gZXhpc3RzIGJlZm9yZSBjcmVhdGluZyB0aGUgY2hhbmdlc2V0IGhhcyBmYWlsZWQsIHdpbGwgYmFzZSB0aGUgZGlmZiBvbiB0ZW1wbGF0ZSBkaWZmZXJlbmNlcy5cXG5gKTtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5kZWJ1Zyhmb3JtYXRFcnJvck1lc3NhZ2UoZSkpO1xuICAgIHN0YWNrRXhpc3RzID0gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhY2tFeGlzdHMpIHtcbiAgICByZXR1cm4gY2ZuQXBpLmNyZWF0ZURpZmZDaGFuZ2VTZXQoaW9IZWxwZXIsIHtcbiAgICAgIHN0YWNrLFxuICAgICAgdXVpZDogdXVpZC52NCgpLFxuICAgICAgZGVwbG95bWVudHMsXG4gICAgICB3aWxsRXhlY3V0ZTogZmFsc2UsXG4gICAgICBzZGtQcm92aWRlcixcbiAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG4gICAgICByZXNvdXJjZXNUb0ltcG9ydCxcbiAgICAgIGZhaWxPbkVycm9yOiAhZmFsbEJhY2tUb1RlbXBsYXRlLFxuICAgICAgaW1wb3J0RXhpc3RpbmdSZXNvdXJjZXMsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFmYWxsQmFja1RvVGVtcGxhdGUpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYHRoZSBzdGFjayAnJHtzdGFjay5zdGFja05hbWV9JyBoYXMgbm90IGJlZW4gZGVwbG95ZWQgdG8gQ2xvdWRGb3JtYXRpb24sIHNldCBmYWxsQmFja1RvVGVtcGxhdGUgdG8gdHJ1ZSBvciB1c2UgRGlmZk1ldGhvZC50ZW1wbGF0ZU9ubHkgdG8gYmFzZSB0aGUgZGlmZiBvbiB0ZW1wbGF0ZSBkaWZmZXJlbmNlcy5gKTtcbiAgICB9XG5cbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5kZWJ1ZyhgdGhlIHN0YWNrICcke3N0YWNrLnN0YWNrTmFtZX0nIGhhcyBub3QgYmVlbiBkZXBsb3llZCB0byBDbG91ZEZvcm1hdGlvbiwgc2tpcHBpbmcgY2hhbmdlc2V0IGNyZWF0aW9uLmApO1xuICAgIHJldHVybjtcbiAgfVxufVxuXG4vKipcbiAqIEFwcGVuZHMgYWxsIHByb3BlcnRpZXMgZnJvbSBvYmoyIHRvIG9iajEuXG4gKiBvYmoyIHZhbHVlcyB0YWtlIHByaW9yaXR5IGluIHRoZSBjYXNlIG9mIGNvbGxpc2lvbnMuXG4gKlxuICogQHBhcmFtIG9iajEgLSBUaGUgb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIG9iajIgLSBUaGUgb2JqZWN0IHRvIGNvbnN1bWVcbiAqXG4gKiBAcmV0dXJucyBvYmoxIHdpdGggYWxsIHByb3BlcnRpZXMgZnJvbSBvYmoyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRPYmplY3Q8VD4oXG4gIG9iajE6IHsgW25hbWU6IHN0cmluZ106IFQgfSxcbiAgb2JqMjogeyBbbmFtZTogc3RyaW5nXTogVCB9LFxuKTogeyBbbmFtZTogc3RyaW5nXTogVCB9IHtcbiAgLy8gRGlyZWN0bHkgbW9kaWZ5IG9iajEgYnkgYWRkaW5nIGFsbCBwcm9wZXJ0aWVzIGZyb20gb2JqMlxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmoyKSB7XG4gICAgb2JqMVtrZXldID0gb2JqMltrZXldO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmoxXG4gIHJldHVybiBvYmoxO1xufVxuIl19