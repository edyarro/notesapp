"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bootstrapper = void 0;
const path = require("path");
const deploy_bootstrap_1 = require("./deploy-bootstrap");
const legacy_template_1 = require("./legacy-template");
const toolkit_error_1 = require("../../toolkit/toolkit-error");
const util_1 = require("../../util");
const plugin_1 = require("../plugin");
const toolkit_info_1 = require("../toolkit-info");
class Bootstrapper {
    source;
    ioHelper;
    constructor(source = { source: 'default' }, ioHelper) {
        this.source = source;
        this.ioHelper = ioHelper;
    }
    bootstrapEnvironment(environment, sdkProvider, options = {}) {
        switch (this.source.source) {
            case 'legacy':
                return this.legacyBootstrap(environment, sdkProvider, options);
            case 'default':
                return this.modernBootstrap(environment, sdkProvider, options);
            case 'custom':
                return this.customBootstrap(environment, sdkProvider, options);
        }
    }
    async showTemplate(json) {
        const template = await this.loadTemplate();
        process.stdout.write(`${(0, util_1.serializeStructure)(template, json)}\n`);
    }
    /**
     * Deploy legacy bootstrap stack
     *
     */
    async legacyBootstrap(environment, sdkProvider, options = {}) {
        const params = options.parameters ?? {};
        if (params.trustedAccounts?.length) {
            throw new toolkit_error_1.ToolkitError('--trust can only be passed for the modern bootstrap experience.');
        }
        if (params.cloudFormationExecutionPolicies?.length) {
            throw new toolkit_error_1.ToolkitError('--cloudformation-execution-policies can only be passed for the modern bootstrap experience.');
        }
        if (params.createCustomerMasterKey !== undefined) {
            throw new toolkit_error_1.ToolkitError('--bootstrap-customer-key can only be passed for the modern bootstrap experience.');
        }
        if (params.qualifier) {
            throw new toolkit_error_1.ToolkitError('--qualifier can only be passed for the modern bootstrap experience.');
        }
        const toolkitStackName = options.toolkitStackName ?? toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, toolkitStackName, this.ioHelper);
        return current.update(await this.loadTemplate(params), {}, {
            ...options,
            terminationProtection: options.terminationProtection ?? current.terminationProtection,
        });
    }
    /**
     * Deploy CI/CD-ready bootstrap stack from template
     *
     */
    async modernBootstrap(environment, sdkProvider, options = {}) {
        const params = options.parameters ?? {};
        const bootstrapTemplate = await this.loadTemplate();
        const toolkitStackName = options.toolkitStackName ?? toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, toolkitStackName, this.ioHelper);
        const partition = await current.partition();
        if (params.createCustomerMasterKey !== undefined && params.kmsKeyId) {
            throw new toolkit_error_1.ToolkitError("You cannot pass '--bootstrap-kms-key-id' and '--bootstrap-customer-key' together. Specify one or the other");
        }
        // If people re-bootstrap, existing parameter values are reused so that people don't accidentally change the configuration
        // on their bootstrap stack (this happens automatically in deployStack). However, to do proper validation on the
        // combined arguments (such that if --trust has been given, --cloudformation-execution-policies is necessary as well)
        // we need to take this parameter reuse into account.
        //
        // Ideally we'd do this inside the template, but the `Rules` section of CFN
        // templates doesn't seem to be able to express the conditions that we need
        // (can't use Fn::Join or reference Conditions) so we do it here instead.
        const allTrusted = new Set([
            ...params.trustedAccounts ?? [],
            ...params.trustedAccountsForLookup ?? [],
        ]);
        const invalid = intersection(allTrusted, new Set(params.untrustedAccounts));
        if (invalid.size > 0) {
            throw new toolkit_error_1.ToolkitError(`Accounts cannot be both trusted and untrusted. Found: ${[...invalid].join(',')}`);
        }
        const removeUntrusted = (accounts) => accounts.filter(acc => !params.untrustedAccounts?.map(String).includes(String(acc)));
        const trustedAccounts = removeUntrusted(params.trustedAccounts ?? splitCfnArray(current.parameters.TrustedAccounts));
        await this.ioHelper.defaults.info(`Trusted accounts for deployment: ${trustedAccounts.length > 0 ? trustedAccounts.join(', ') : '(none)'}`);
        const trustedAccountsForLookup = removeUntrusted(params.trustedAccountsForLookup ?? splitCfnArray(current.parameters.TrustedAccountsForLookup));
        await this.ioHelper.defaults.info(`Trusted accounts for lookup: ${trustedAccountsForLookup.length > 0 ? trustedAccountsForLookup.join(', ') : '(none)'}`);
        const cloudFormationExecutionPolicies = params.cloudFormationExecutionPolicies ?? splitCfnArray(current.parameters.CloudFormationExecutionPolicies);
        if (trustedAccounts.length === 0 && cloudFormationExecutionPolicies.length === 0) {
            // For self-trust it's okay to default to AdministratorAccess, and it improves the usability of bootstrapping a lot.
            //
            // We don't actually make the implicitly policy a physical parameter. The template will infer it instead,
            // we simply do the UI advertising that behavior here.
            //
            // If we DID make it an explicit parameter, we wouldn't be able to tell the difference between whether
            // we inferred it or whether the user told us, and the sequence:
            //
            // $ cdk bootstrap
            // $ cdk bootstrap --trust 1234
            //
            // Would leave AdministratorAccess policies with a trust relationship, without the user explicitly
            // approving the trust policy.
            const implicitPolicy = `arn:${partition}:iam::aws:policy/AdministratorAccess`;
            await this.ioHelper.defaults.warn(`Using default execution policy of '${implicitPolicy}'. Pass '--cloudformation-execution-policies' to customize.`);
        }
        else if (cloudFormationExecutionPolicies.length === 0) {
            throw new toolkit_error_1.ToolkitError(`Please pass \'--cloudformation-execution-policies\' when using \'--trust\' to specify deployment permissions. Try a managed policy of the form \'arn:${partition}:iam::aws:policy/<PolicyName>\'.`);
        }
        else {
            // Remind people what the current settings are
            await this.ioHelper.defaults.info(`Execution policies: ${cloudFormationExecutionPolicies.join(', ')}`);
        }
        // * If an ARN is given, that ARN. Otherwise:
        //   * '-' if customerKey = false
        //   * '' if customerKey = true
        //   * if customerKey is also not given
        //     * undefined if we already had a value in place (reusing what we had)
        //     * '-' if this is the first time we're deploying this stack (or upgrading from old to new bootstrap)
        const currentKmsKeyId = current.parameters.FileAssetsBucketKmsKeyId;
        const kmsKeyId = params.kmsKeyId ??
            (params.createCustomerMasterKey === true
                ? CREATE_NEW_KEY
                : params.createCustomerMasterKey === false || currentKmsKeyId === undefined
                    ? USE_AWS_MANAGED_KEY
                    : undefined);
        /* A permissions boundary can be provided via:
         *    - the flag indicating the example one should be used
         *    - the name indicating the custom permissions boundary to be used
         * Re-bootstrapping will NOT be blocked by either tightening or relaxing the permissions' boundary.
         */
        // InputPermissionsBoundary is an `any` type and if it is not defined it
        // appears as an empty string ''. We need to force it to evaluate an empty string
        // as undefined
        const currentPermissionsBoundary = current.parameters.InputPermissionsBoundary || undefined;
        const inputPolicyName = params.examplePermissionsBoundary
            ? CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY
            : params.customPermissionsBoundary;
        let policyName;
        if (inputPolicyName) {
            // If the example policy is not already in place, it must be created.
            const sdk = (await sdkProvider.forEnvironment(environment, plugin_1.Mode.ForWriting)).sdk;
            policyName = await this.getPolicyName(environment, sdk, inputPolicyName, partition, params);
        }
        if (currentPermissionsBoundary !== policyName) {
            if (!currentPermissionsBoundary) {
                await this.ioHelper.defaults.warn(`Adding new permissions boundary ${policyName}`);
            }
            else if (!policyName) {
                await this.ioHelper.defaults.warn(`Removing existing permissions boundary ${currentPermissionsBoundary}`);
            }
            else {
                await this.ioHelper.defaults.warn(`Changing permissions boundary from ${currentPermissionsBoundary} to ${policyName}`);
            }
        }
        const bootstrapTemplateParameters = {
            FileAssetsBucketName: params.bucketName,
            FileAssetsBucketKmsKeyId: kmsKeyId,
            // Empty array becomes empty string
            TrustedAccounts: trustedAccounts.join(','),
            TrustedAccountsForLookup: trustedAccountsForLookup.join(','),
            CloudFormationExecutionPolicies: cloudFormationExecutionPolicies.join(','),
            Qualifier: params.qualifier,
            PublicAccessBlockConfiguration: params.publicAccessBlockConfiguration || params.publicAccessBlockConfiguration === undefined
                ? 'true'
                : 'false',
            InputPermissionsBoundary: policyName,
        };
        const templateParameters = await this.templateParameters();
        // Conditionally set these parameters: only set these parameters if they are accepted by the template.
        // If we pass them unconditionally, older customized templates that don't know about these
        // parameters yet will fail to deploy.
        if (params.denyExternalId !== undefined) {
            if (!templateParameters.includes('DenyExternalId')) {
                throw new toolkit_error_1.ToolkitError('The selected bootstrap template does not accept the DenyExternalId parameter');
            }
            bootstrapTemplateParameters.DenyExternalId = `${params.denyExternalId}`;
        }
        return current.update(bootstrapTemplate, bootstrapTemplateParameters, {
            ...options,
            terminationProtection: options.terminationProtection ?? current.terminationProtection,
        });
    }
    async getPolicyName(environment, sdk, permissionsBoundary, partition, params) {
        if (permissionsBoundary !== CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY) {
            this.validatePolicyName(permissionsBoundary);
            return Promise.resolve(permissionsBoundary);
        }
        // if no Qualifier is supplied, resort to the default one
        const arn = await this.getExamplePermissionsBoundary(params.qualifier ?? 'hnb659fds', partition, environment.account, sdk);
        const policyName = arn.split('/').pop();
        if (!policyName) {
            throw new toolkit_error_1.ToolkitError('Could not retrieve the example permission boundary!');
        }
        return Promise.resolve(policyName);
    }
    async getExamplePermissionsBoundary(qualifier, partition, account, sdk) {
        const iam = sdk.iam();
        let policyName = `cdk-${qualifier}-permissions-boundary`;
        const arn = `arn:${partition}:iam::${account}:policy/${policyName}`;
        try {
            let getPolicyResp = await iam.getPolicy({ PolicyArn: arn });
            if (getPolicyResp.Policy) {
                return arn;
            }
        }
        catch (e) {
            // https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetPolicy.html#API_GetPolicy_Errors
            if (e.name === 'NoSuchEntity') {
                // noop, proceed with creating the policy
            }
            else {
                throw e;
            }
        }
        const policyDoc = {
            Version: '2012-10-17',
            Statement: [
                {
                    Action: ['*'],
                    Resource: '*',
                    Effect: 'Allow',
                    Sid: 'ExplicitAllowAll',
                },
                {
                    Condition: {
                        StringEquals: {
                            'iam:PermissionsBoundary': `arn:${partition}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
                        },
                    },
                    Action: [
                        'iam:CreateUser',
                        'iam:CreateRole',
                        'iam:PutRolePermissionsBoundary',
                        'iam:PutUserPermissionsBoundary',
                    ],
                    Resource: '*',
                    Effect: 'Allow',
                    Sid: 'DenyAccessIfRequiredPermBoundaryIsNotBeingApplied',
                },
                {
                    Action: [
                        'iam:CreatePolicyVersion',
                        'iam:DeletePolicy',
                        'iam:DeletePolicyVersion',
                        'iam:SetDefaultPolicyVersion',
                    ],
                    Resource: `arn:${partition}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
                    Effect: 'Deny',
                    Sid: 'DenyPermBoundaryIAMPolicyAlteration',
                },
                {
                    Action: ['iam:DeleteUserPermissionsBoundary', 'iam:DeleteRolePermissionsBoundary'],
                    Resource: '*',
                    Effect: 'Deny',
                    Sid: 'DenyRemovalOfPermBoundaryFromAnyUserOrRole',
                },
            ],
        };
        const request = {
            PolicyName: policyName,
            PolicyDocument: JSON.stringify(policyDoc),
        };
        const createPolicyResponse = await iam.createPolicy(request);
        if (createPolicyResponse.Policy?.Arn) {
            return createPolicyResponse.Policy.Arn;
        }
        else {
            throw new toolkit_error_1.ToolkitError(`Could not retrieve the example permission boundary ${arn}!`);
        }
    }
    validatePolicyName(permissionsBoundary) {
        // https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html
        // Added support for policy names with a path
        // See https://github.com/aws/aws-cdk/issues/26320
        const regexp = /[\w+\/=,.@-]+/;
        const matches = regexp.exec(permissionsBoundary);
        if (!(matches && matches.length === 1 && matches[0] === permissionsBoundary)) {
            throw new toolkit_error_1.ToolkitError(`The permissions boundary name ${permissionsBoundary} does not match the IAM conventions.`);
        }
    }
    async customBootstrap(environment, sdkProvider, options = {}) {
        // Look at the template, decide whether it's most likely a legacy or modern bootstrap
        // template, and use the right bootstrapper for that.
        const version = (0, deploy_bootstrap_1.bootstrapVersionFromTemplate)(await this.loadTemplate());
        if (version === 0) {
            return this.legacyBootstrap(environment, sdkProvider, options);
        }
        else {
            return this.modernBootstrap(environment, sdkProvider, options);
        }
    }
    /**
     * Return the set of parameter names accepted by the current bootstrapping template
     */
    async templateParameters(legacyParams = {}) {
        const template = await this.loadTemplate(legacyParams);
        return Object.keys(template.Parameters ?? {});
    }
    async loadTemplate(legacyParams = {}) {
        switch (this.source.source) {
            case 'custom':
                return (0, util_1.loadStructuredFile)(this.source.templateFile);
            case 'default':
                return (0, util_1.loadStructuredFile)(path.join((0, util_1.bundledPackageRootDir)(__dirname), 'lib', 'api', 'bootstrap', 'bootstrap-template.yaml'));
            case 'legacy':
                return (0, legacy_template_1.legacyBootstrapTemplate)(legacyParams);
        }
    }
}
exports.Bootstrapper = Bootstrapper;
/**
 * Magic parameter value that will cause the bootstrap-template.yml to NOT create a CMK but use the default key
 */
const USE_AWS_MANAGED_KEY = 'AWS_MANAGED_KEY';
/**
 * Magic parameter value that will cause the bootstrap-template.yml to create a CMK
 */
const CREATE_NEW_KEY = '';
/**
 * Parameter value indicating the use of the default, CDK provided permissions boundary for bootstrap-template.yml
 */
const CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY = 'CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY';
/**
 * Split an array-like CloudFormation parameter on ,
 *
 * An empty string is the empty array (instead of `['']`).
 */
function splitCfnArray(xs) {
    if (xs === '' || xs === undefined) {
        return [];
    }
    return xs.split(',');
}
function intersection(xs, ys) {
    return new Set(Array.from(xs).filter(x => ys.has(x)));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwLWVudmlyb25tZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYm9vdHN0cmFwLWVudmlyb25tZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUE2QjtBQUc3Qix5REFBa0Y7QUFDbEYsdURBQTREO0FBQzVELCtEQUEyRDtBQUMzRCxxQ0FBMkY7QUFJM0Ysc0NBQWlDO0FBQ2pDLGtEQUE2RDtBQUk3RCxNQUFhLFlBQVk7SUFJSjtJQUhGLFFBQVEsQ0FBVztJQUVwQyxZQUNtQixTQUEwQixFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsRUFDaEUsUUFBa0I7UUFERCxXQUFNLEdBQU4sTUFBTSxDQUF5QztRQUdoRSxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztJQUMzQixDQUFDO0lBRU0sb0JBQW9CLENBQ3pCLFdBQThCLEVBQzlCLFdBQXdCLEVBQ3hCLFVBQXVDLEVBQUU7UUFFekMsUUFBUSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQzNCLEtBQUssUUFBUTtnQkFDWCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNqRSxLQUFLLFNBQVM7Z0JBQ1osT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDakUsS0FBSyxRQUFRO2dCQUNYLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ25FLENBQUM7SUFDSCxDQUFDO0lBRU0sS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFhO1FBQ3JDLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQzNDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBQSx5QkFBa0IsRUFBQyxRQUFRLEVBQUUsSUFB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QUFFOUM7O0dBRUc7QUFDSCxNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFDMUI7O0dBRUc7QUFDSCxNQUFNLGtDQUFrQyxHQUFHLG9DQUFvQyxDQUFDO0FBRWhGOzs7O0dBSUc7QUFDSCxTQUFTLGFBQWEsQ0FBQyxFQUFzQjtJQUMzQyxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLFNBQVMsRUFBRSxDQUFDO1FBQ2xDLE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUNELE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2QixDQUFDO0FBRUQsU0FBUyxZQUFZLENBQUksRUFBVSxFQUFFLEVBQVU7SUFDN0MsT0FBTyxJQUFJLEdBQUcsQ0FBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHR5cGUgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHR5cGUgeyBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMsIEJvb3RzdHJhcHBpbmdQYXJhbWV0ZXJzIH0gZnJvbSAnLi9ib290c3RyYXAtcHJvcHMnO1xuaW1wb3J0IHsgQm9vdHN0cmFwU3RhY2ssIGJvb3RzdHJhcFZlcnNpb25Gcm9tVGVtcGxhdGUgfSBmcm9tICcuL2RlcGxveS1ib290c3RyYXAnO1xuaW1wb3J0IHsgbGVnYWN5Qm9vdHN0cmFwVGVtcGxhdGUgfSBmcm9tICcuL2xlZ2FjeS10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L3Rvb2xraXQtZXJyb3InO1xuaW1wb3J0IHsgYnVuZGxlZFBhY2thZ2VSb290RGlyLCBsb2FkU3RydWN0dXJlZEZpbGUsIHNlcmlhbGl6ZVN0cnVjdHVyZSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBTREssIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXdzLWF1dGgvcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4uL2RlcGxveW1lbnRzJztcbmltcG9ydCB0eXBlIHsgSW9IZWxwZXIgfSBmcm9tICcuLi9pby9wcml2YXRlJztcbmltcG9ydCB7IE1vZGUgfSBmcm9tICcuLi9wbHVnaW4nO1xuaW1wb3J0IHsgREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUgfSBmcm9tICcuLi90b29sa2l0LWluZm8nO1xuXG5leHBvcnQgdHlwZSBCb290c3RyYXBTb3VyY2UgPSB7IHNvdXJjZTogJ2xlZ2FjeScgfSB8IHsgc291cmNlOiAnZGVmYXVsdCcgfSB8IHsgc291cmNlOiAnY3VzdG9tJzsgdGVtcGxhdGVGaWxlOiBzdHJpbmcgfTtcblxuZXhwb3J0IGNsYXNzIEJvb3RzdHJhcHBlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgaW9IZWxwZXI6IElvSGVscGVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc291cmNlOiBCb290c3RyYXBTb3VyY2UgPSB7IHNvdXJjZTogJ2RlZmF1bHQnIH0sXG4gICAgaW9IZWxwZXI6IElvSGVscGVyLFxuICApIHtcbiAgICB0aGlzLmlvSGVscGVyID0gaW9IZWxwZXI7XG4gIH1cblxuICBwdWJsaWMgYm9vdHN0cmFwRW52aXJvbm1lbnQoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgICBvcHRpb25zOiBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgPSB7fSxcbiAgKTogUHJvbWlzZTxTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgICBzd2l0Y2ggKHRoaXMuc291cmNlLnNvdXJjZSkge1xuICAgICAgY2FzZSAnbGVnYWN5JzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGVnYWN5Qm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZXJuQm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICBjYXNlICdjdXN0b20nOlxuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21Cb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2hvd1RlbXBsYXRlKGpzb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGF3YWl0IHRoaXMubG9hZFRlbXBsYXRlKCk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7c2VyaWFsaXplU3RydWN0dXJlKHRlbXBsYXRlLCBqc29uKX1cXG5gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgbGVnYWN5IGJvb3RzdHJhcCBzdGFja1xuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBsZWdhY3lCb290c3RyYXAoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgICBvcHRpb25zOiBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgPSB7fSxcbiAgKTogUHJvbWlzZTxTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zLnBhcmFtZXRlcnMgPz8ge307XG5cbiAgICBpZiAocGFyYW1zLnRydXN0ZWRBY2NvdW50cz8ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCctLXRydXN0IGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzPy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJy0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzIGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCctLWJvb3RzdHJhcC1jdXN0b21lci1rZXkgY2FuIG9ubHkgYmUgcGFzc2VkIGZvciB0aGUgbW9kZXJuIGJvb3RzdHJhcCBleHBlcmllbmNlLicpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnF1YWxpZmllcikge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignLS1xdWFsaWZpZXIgY2FuIG9ubHkgYmUgcGFzc2VkIGZvciB0aGUgbW9kZXJuIGJvb3RzdHJhcCBleHBlcmllbmNlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHRvb2xraXRTdGFja05hbWUgPSBvcHRpb25zLnRvb2xraXRTdGFja05hbWUgPz8gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUU7XG4gICAgY29uc3QgY3VycmVudCA9IGF3YWl0IEJvb3RzdHJhcFN0YWNrLmxvb2t1cChzZGtQcm92aWRlciwgZW52aXJvbm1lbnQsIHRvb2xraXRTdGFja05hbWUsIHRoaXMuaW9IZWxwZXIpO1xuICAgIHJldHVybiBjdXJyZW50LnVwZGF0ZShcbiAgICAgIGF3YWl0IHRoaXMubG9hZFRlbXBsYXRlKHBhcmFtcyksXG4gICAgICB7fSxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdGVybWluYXRpb25Qcm90ZWN0aW9uOiBvcHRpb25zLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiA/PyBjdXJyZW50LnRlcm1pbmF0aW9uUHJvdGVjdGlvbixcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgQ0kvQ0QtcmVhZHkgYm9vdHN0cmFwIHN0YWNrIGZyb20gdGVtcGxhdGVcbiAgICpcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbW9kZXJuQm9vdHN0cmFwKFxuICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCxcbiAgICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gICAgb3B0aW9uczogQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zID0ge30sXG4gICk6IFByb21pc2U8U3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0PiB7XG4gICAgY29uc3QgcGFyYW1zID0gb3B0aW9ucy5wYXJhbWV0ZXJzID8/IHt9O1xuXG4gICAgY29uc3QgYm9vdHN0cmFwVGVtcGxhdGUgPSBhd2FpdCB0aGlzLmxvYWRUZW1wbGF0ZSgpO1xuXG4gICAgY29uc3QgdG9vbGtpdFN0YWNrTmFtZSA9IG9wdGlvbnMudG9vbGtpdFN0YWNrTmFtZSA/PyBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRTtcbiAgICBjb25zdCBjdXJyZW50ID0gYXdhaXQgQm9vdHN0cmFwU3RhY2subG9va3VwKHNka1Byb3ZpZGVyLCBlbnZpcm9ubWVudCwgdG9vbGtpdFN0YWNrTmFtZSwgdGhpcy5pb0hlbHBlcik7XG4gICAgY29uc3QgcGFydGl0aW9uID0gYXdhaXQgY3VycmVudC5wYXJ0aXRpb24oKTtcblxuICAgIGlmIChwYXJhbXMuY3JlYXRlQ3VzdG9tZXJNYXN0ZXJLZXkgIT09IHVuZGVmaW5lZCAmJiBwYXJhbXMua21zS2V5SWQpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgIFwiWW91IGNhbm5vdCBwYXNzICctLWJvb3RzdHJhcC1rbXMta2V5LWlkJyBhbmQgJy0tYm9vdHN0cmFwLWN1c3RvbWVyLWtleScgdG9nZXRoZXIuIFNwZWNpZnkgb25lIG9yIHRoZSBvdGhlclwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBJZiBwZW9wbGUgcmUtYm9vdHN0cmFwLCBleGlzdGluZyBwYXJhbWV0ZXIgdmFsdWVzIGFyZSByZXVzZWQgc28gdGhhdCBwZW9wbGUgZG9uJ3QgYWNjaWRlbnRhbGx5IGNoYW5nZSB0aGUgY29uZmlndXJhdGlvblxuICAgIC8vIG9uIHRoZWlyIGJvb3RzdHJhcCBzdGFjayAodGhpcyBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgaW4gZGVwbG95U3RhY2spLiBIb3dldmVyLCB0byBkbyBwcm9wZXIgdmFsaWRhdGlvbiBvbiB0aGVcbiAgICAvLyBjb21iaW5lZCBhcmd1bWVudHMgKHN1Y2ggdGhhdCBpZiAtLXRydXN0IGhhcyBiZWVuIGdpdmVuLCAtLWNsb3VkZm9ybWF0aW9uLWV4ZWN1dGlvbi1wb2xpY2llcyBpcyBuZWNlc3NhcnkgYXMgd2VsbClcbiAgICAvLyB3ZSBuZWVkIHRvIHRha2UgdGhpcyBwYXJhbWV0ZXIgcmV1c2UgaW50byBhY2NvdW50LlxuICAgIC8vXG4gICAgLy8gSWRlYWxseSB3ZSdkIGRvIHRoaXMgaW5zaWRlIHRoZSB0ZW1wbGF0ZSwgYnV0IHRoZSBgUnVsZXNgIHNlY3Rpb24gb2YgQ0ZOXG4gICAgLy8gdGVtcGxhdGVzIGRvZXNuJ3Qgc2VlbSB0byBiZSBhYmxlIHRvIGV4cHJlc3MgdGhlIGNvbmRpdGlvbnMgdGhhdCB3ZSBuZWVkXG4gICAgLy8gKGNhbid0IHVzZSBGbjo6Sm9pbiBvciByZWZlcmVuY2UgQ29uZGl0aW9ucykgc28gd2UgZG8gaXQgaGVyZSBpbnN0ZWFkLlxuICAgIGNvbnN0IGFsbFRydXN0ZWQgPSBuZXcgU2V0KFtcbiAgICAgIC4uLnBhcmFtcy50cnVzdGVkQWNjb3VudHMgPz8gW10sXG4gICAgICAuLi5wYXJhbXMudHJ1c3RlZEFjY291bnRzRm9yTG9va3VwID8/IFtdLFxuICAgIF0pO1xuICAgIGNvbnN0IGludmFsaWQgPSBpbnRlcnNlY3Rpb24oYWxsVHJ1c3RlZCwgbmV3IFNldChwYXJhbXMudW50cnVzdGVkQWNjb3VudHMpKTtcbiAgICBpZiAoaW52YWxpZC5zaXplID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgQWNjb3VudHMgY2Fubm90IGJlIGJvdGggdHJ1c3RlZCBhbmQgdW50cnVzdGVkLiBGb3VuZDogJHtbLi4uaW52YWxpZF0uam9pbignLCcpfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbW92ZVVudHJ1c3RlZCA9IChhY2NvdW50czogc3RyaW5nW10pID0+XG4gICAgICBhY2NvdW50cy5maWx0ZXIoYWNjID0+ICFwYXJhbXMudW50cnVzdGVkQWNjb3VudHM/Lm1hcChTdHJpbmcpLmluY2x1ZGVzKFN0cmluZyhhY2MpKSk7XG5cbiAgICBjb25zdCB0cnVzdGVkQWNjb3VudHMgPSByZW1vdmVVbnRydXN0ZWQocGFyYW1zLnRydXN0ZWRBY2NvdW50cyA/PyBzcGxpdENmbkFycmF5KGN1cnJlbnQucGFyYW1ldGVycy5UcnVzdGVkQWNjb3VudHMpKTtcbiAgICBhd2FpdCB0aGlzLmlvSGVscGVyLmRlZmF1bHRzLmluZm8oXG4gICAgICBgVHJ1c3RlZCBhY2NvdW50cyBmb3IgZGVwbG95bWVudDogJHt0cnVzdGVkQWNjb3VudHMubGVuZ3RoID4gMCA/IHRydXN0ZWRBY2NvdW50cy5qb2luKCcsICcpIDogJyhub25lKSd9YCxcbiAgICApO1xuXG4gICAgY29uc3QgdHJ1c3RlZEFjY291bnRzRm9yTG9va3VwID0gcmVtb3ZlVW50cnVzdGVkKFxuICAgICAgcGFyYW1zLnRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cCA/PyBzcGxpdENmbkFycmF5KGN1cnJlbnQucGFyYW1ldGVycy5UcnVzdGVkQWNjb3VudHNGb3JMb29rdXApLFxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5pb0hlbHBlci5kZWZhdWx0cy5pbmZvKFxuICAgICAgYFRydXN0ZWQgYWNjb3VudHMgZm9yIGxvb2t1cDogJHt0cnVzdGVkQWNjb3VudHNGb3JMb29rdXAubGVuZ3RoID4gMCA/IHRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cC5qb2luKCcsICcpIDogJyhub25lKSd9YCxcbiAgICApO1xuXG4gICAgY29uc3QgY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcyA9XG4gICAgICBwYXJhbXMuY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcyA/PyBzcGxpdENmbkFycmF5KGN1cnJlbnQucGFyYW1ldGVycy5DbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzKTtcbiAgICBpZiAodHJ1c3RlZEFjY291bnRzLmxlbmd0aCA9PT0gMCAmJiBjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRm9yIHNlbGYtdHJ1c3QgaXQncyBva2F5IHRvIGRlZmF1bHQgdG8gQWRtaW5pc3RyYXRvckFjY2VzcywgYW5kIGl0IGltcHJvdmVzIHRoZSB1c2FiaWxpdHkgb2YgYm9vdHN0cmFwcGluZyBhIGxvdC5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBtYWtlIHRoZSBpbXBsaWNpdGx5IHBvbGljeSBhIHBoeXNpY2FsIHBhcmFtZXRlci4gVGhlIHRlbXBsYXRlIHdpbGwgaW5mZXIgaXQgaW5zdGVhZCxcbiAgICAgIC8vIHdlIHNpbXBseSBkbyB0aGUgVUkgYWR2ZXJ0aXNpbmcgdGhhdCBiZWhhdmlvciBoZXJlLlxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIERJRCBtYWtlIGl0IGFuIGV4cGxpY2l0IHBhcmFtZXRlciwgd2Ugd291bGRuJ3QgYmUgYWJsZSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gd2hldGhlclxuICAgICAgLy8gd2UgaW5mZXJyZWQgaXQgb3Igd2hldGhlciB0aGUgdXNlciB0b2xkIHVzLCBhbmQgdGhlIHNlcXVlbmNlOlxuICAgICAgLy9cbiAgICAgIC8vICQgY2RrIGJvb3RzdHJhcFxuICAgICAgLy8gJCBjZGsgYm9vdHN0cmFwIC0tdHJ1c3QgMTIzNFxuICAgICAgLy9cbiAgICAgIC8vIFdvdWxkIGxlYXZlIEFkbWluaXN0cmF0b3JBY2Nlc3MgcG9saWNpZXMgd2l0aCBhIHRydXN0IHJlbGF0aW9uc2hpcCwgd2l0aG91dCB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAvLyBhcHByb3ZpbmcgdGhlIHRydXN0IHBvbGljeS5cbiAgICAgIGNvbnN0IGltcGxpY2l0UG9saWN5ID0gYGFybjoke3BhcnRpdGlvbn06aWFtOjphd3M6cG9saWN5L0FkbWluaXN0cmF0b3JBY2Nlc3NgO1xuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5kZWZhdWx0cy53YXJuKFxuICAgICAgICBgVXNpbmcgZGVmYXVsdCBleGVjdXRpb24gcG9saWN5IG9mICcke2ltcGxpY2l0UG9saWN5fScuIFBhc3MgJy0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzJyB0byBjdXN0b21pemUuYCxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgYFBsZWFzZSBwYXNzIFxcJy0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzXFwnIHdoZW4gdXNpbmcgXFwnLS10cnVzdFxcJyB0byBzcGVjaWZ5IGRlcGxveW1lbnQgcGVybWlzc2lvbnMuIFRyeSBhIG1hbmFnZWQgcG9saWN5IG9mIHRoZSBmb3JtIFxcJ2Fybjoke3BhcnRpdGlvbn06aWFtOjphd3M6cG9saWN5LzxQb2xpY3lOYW1lPlxcJy5gLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtaW5kIHBlb3BsZSB3aGF0IHRoZSBjdXJyZW50IHNldHRpbmdzIGFyZVxuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5kZWZhdWx0cy5pbmZvKGBFeGVjdXRpb24gcG9saWNpZXM6ICR7Y2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5qb2luKCcsICcpfWApO1xuICAgIH1cblxuICAgIC8vICogSWYgYW4gQVJOIGlzIGdpdmVuLCB0aGF0IEFSTi4gT3RoZXJ3aXNlOlxuICAgIC8vICAgKiAnLScgaWYgY3VzdG9tZXJLZXkgPSBmYWxzZVxuICAgIC8vICAgKiAnJyBpZiBjdXN0b21lcktleSA9IHRydWVcbiAgICAvLyAgICogaWYgY3VzdG9tZXJLZXkgaXMgYWxzbyBub3QgZ2l2ZW5cbiAgICAvLyAgICAgKiB1bmRlZmluZWQgaWYgd2UgYWxyZWFkeSBoYWQgYSB2YWx1ZSBpbiBwbGFjZSAocmV1c2luZyB3aGF0IHdlIGhhZClcbiAgICAvLyAgICAgKiAnLScgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBkZXBsb3lpbmcgdGhpcyBzdGFjayAob3IgdXBncmFkaW5nIGZyb20gb2xkIHRvIG5ldyBib290c3RyYXApXG4gICAgY29uc3QgY3VycmVudEttc0tleUlkID0gY3VycmVudC5wYXJhbWV0ZXJzLkZpbGVBc3NldHNCdWNrZXRLbXNLZXlJZDtcbiAgICBjb25zdCBrbXNLZXlJZCA9XG4gICAgICBwYXJhbXMua21zS2V5SWQgPz9cbiAgICAgIChwYXJhbXMuY3JlYXRlQ3VzdG9tZXJNYXN0ZXJLZXkgPT09IHRydWVcbiAgICAgICAgPyBDUkVBVEVfTkVXX0tFWVxuICAgICAgICA6IHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSA9PT0gZmFsc2UgfHwgY3VycmVudEttc0tleUlkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IFVTRV9BV1NfTUFOQUdFRF9LRVlcbiAgICAgICAgICA6IHVuZGVmaW5lZCk7XG5cbiAgICAvKiBBIHBlcm1pc3Npb25zIGJvdW5kYXJ5IGNhbiBiZSBwcm92aWRlZCB2aWE6XG4gICAgICogICAgLSB0aGUgZmxhZyBpbmRpY2F0aW5nIHRoZSBleGFtcGxlIG9uZSBzaG91bGQgYmUgdXNlZFxuICAgICAqICAgIC0gdGhlIG5hbWUgaW5kaWNhdGluZyB0aGUgY3VzdG9tIHBlcm1pc3Npb25zIGJvdW5kYXJ5IHRvIGJlIHVzZWRcbiAgICAgKiBSZS1ib290c3RyYXBwaW5nIHdpbGwgTk9UIGJlIGJsb2NrZWQgYnkgZWl0aGVyIHRpZ2h0ZW5pbmcgb3IgcmVsYXhpbmcgdGhlIHBlcm1pc3Npb25zJyBib3VuZGFyeS5cbiAgICAgKi9cblxuICAgIC8vIElucHV0UGVybWlzc2lvbnNCb3VuZGFyeSBpcyBhbiBgYW55YCB0eXBlIGFuZCBpZiBpdCBpcyBub3QgZGVmaW5lZCBpdFxuICAgIC8vIGFwcGVhcnMgYXMgYW4gZW1wdHkgc3RyaW5nICcnLiBXZSBuZWVkIHRvIGZvcmNlIGl0IHRvIGV2YWx1YXRlIGFuIGVtcHR5IHN0cmluZ1xuICAgIC8vIGFzIHVuZGVmaW5lZFxuICAgIGNvbnN0IGN1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5OiBzdHJpbmcgfCB1bmRlZmluZWQgPSBjdXJyZW50LnBhcmFtZXRlcnMuSW5wdXRQZXJtaXNzaW9uc0JvdW5kYXJ5IHx8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpbnB1dFBvbGljeU5hbWUgPSBwYXJhbXMuZXhhbXBsZVBlcm1pc3Npb25zQm91bmRhcnlcbiAgICAgID8gQ0RLX0JPT1RTVFJBUF9QRVJNSVNTSU9OU19CT1VOREFSWVxuICAgICAgOiBwYXJhbXMuY3VzdG9tUGVybWlzc2lvbnNCb3VuZGFyeTtcbiAgICBsZXQgcG9saWN5TmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlmIChpbnB1dFBvbGljeU5hbWUpIHtcbiAgICAgIC8vIElmIHRoZSBleGFtcGxlIHBvbGljeSBpcyBub3QgYWxyZWFkeSBpbiBwbGFjZSwgaXQgbXVzdCBiZSBjcmVhdGVkLlxuICAgICAgY29uc3Qgc2RrID0gKGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KGVudmlyb25tZW50LCBNb2RlLkZvcldyaXRpbmcpKS5zZGs7XG4gICAgICBwb2xpY3lOYW1lID0gYXdhaXQgdGhpcy5nZXRQb2xpY3lOYW1lKGVudmlyb25tZW50LCBzZGssIGlucHV0UG9saWN5TmFtZSwgcGFydGl0aW9uLCBwYXJhbXMpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBlcm1pc3Npb25zQm91bmRhcnkgIT09IHBvbGljeU5hbWUpIHtcbiAgICAgIGlmICghY3VycmVudFBlcm1pc3Npb25zQm91bmRhcnkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5kZWZhdWx0cy53YXJuKFxuICAgICAgICAgIGBBZGRpbmcgbmV3IHBlcm1pc3Npb25zIGJvdW5kYXJ5ICR7cG9saWN5TmFtZX1gLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghcG9saWN5TmFtZSkge1xuICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLmRlZmF1bHRzLndhcm4oXG4gICAgICAgICAgYFJlbW92aW5nIGV4aXN0aW5nIHBlcm1pc3Npb25zIGJvdW5kYXJ5ICR7Y3VycmVudFBlcm1pc3Npb25zQm91bmRhcnl9YCxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIuZGVmYXVsdHMud2FybihcbiAgICAgICAgICBgQ2hhbmdpbmcgcGVybWlzc2lvbnMgYm91bmRhcnkgZnJvbSAke2N1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5fSB0byAke3BvbGljeU5hbWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBib290c3RyYXBUZW1wbGF0ZVBhcmFtZXRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB7XG4gICAgICBGaWxlQXNzZXRzQnVja2V0TmFtZTogcGFyYW1zLmJ1Y2tldE5hbWUsXG4gICAgICBGaWxlQXNzZXRzQnVja2V0S21zS2V5SWQ6IGttc0tleUlkLFxuICAgICAgLy8gRW1wdHkgYXJyYXkgYmVjb21lcyBlbXB0eSBzdHJpbmdcbiAgICAgIFRydXN0ZWRBY2NvdW50czogdHJ1c3RlZEFjY291bnRzLmpvaW4oJywnKSxcbiAgICAgIFRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cDogdHJ1c3RlZEFjY291bnRzRm9yTG9va3VwLmpvaW4oJywnKSxcbiAgICAgIENsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXM6IGNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMuam9pbignLCcpLFxuICAgICAgUXVhbGlmaWVyOiBwYXJhbXMucXVhbGlmaWVyLFxuICAgICAgUHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uOlxuICAgICAgICBwYXJhbXMucHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uIHx8IHBhcmFtcy5wdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gJ3RydWUnXG4gICAgICAgICAgOiAnZmFsc2UnLFxuICAgICAgSW5wdXRQZXJtaXNzaW9uc0JvdW5kYXJ5OiBwb2xpY3lOYW1lLFxuICAgIH07XG5cbiAgICBjb25zdCB0ZW1wbGF0ZVBhcmFtZXRlcnMgPSBhd2FpdCB0aGlzLnRlbXBsYXRlUGFyYW1ldGVycygpO1xuXG4gICAgLy8gQ29uZGl0aW9uYWxseSBzZXQgdGhlc2UgcGFyYW1ldGVyczogb25seSBzZXQgdGhlc2UgcGFyYW1ldGVycyBpZiB0aGV5IGFyZSBhY2NlcHRlZCBieSB0aGUgdGVtcGxhdGUuXG4gICAgLy8gSWYgd2UgcGFzcyB0aGVtIHVuY29uZGl0aW9uYWxseSwgb2xkZXIgY3VzdG9taXplZCB0ZW1wbGF0ZXMgdGhhdCBkb24ndCBrbm93IGFib3V0IHRoZXNlXG4gICAgLy8gcGFyYW1ldGVycyB5ZXQgd2lsbCBmYWlsIHRvIGRlcGxveS5cbiAgICBpZiAocGFyYW1zLmRlbnlFeHRlcm5hbElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghdGVtcGxhdGVQYXJhbWV0ZXJzLmluY2x1ZGVzKCdEZW55RXh0ZXJuYWxJZCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ1RoZSBzZWxlY3RlZCBib290c3RyYXAgdGVtcGxhdGUgZG9lcyBub3QgYWNjZXB0IHRoZSBEZW55RXh0ZXJuYWxJZCBwYXJhbWV0ZXInKTtcbiAgICAgIH1cbiAgICAgIGJvb3RzdHJhcFRlbXBsYXRlUGFyYW1ldGVycy5EZW55RXh0ZXJuYWxJZCA9IGAke3BhcmFtcy5kZW55RXh0ZXJuYWxJZH1gO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50LnVwZGF0ZShib290c3RyYXBUZW1wbGF0ZSwgYm9vdHN0cmFwVGVtcGxhdGVQYXJhbWV0ZXJzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdGVybWluYXRpb25Qcm90ZWN0aW9uOiBvcHRpb25zLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiA/PyBjdXJyZW50LnRlcm1pbmF0aW9uUHJvdGVjdGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0UG9saWN5TmFtZShcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrOiBTREssXG4gICAgcGVybWlzc2lvbnNCb3VuZGFyeTogc3RyaW5nLFxuICAgIHBhcnRpdGlvbjogc3RyaW5nLFxuICAgIHBhcmFtczogQm9vdHN0cmFwcGluZ1BhcmFtZXRlcnMsXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKHBlcm1pc3Npb25zQm91bmRhcnkgIT09IENES19CT09UU1RSQVBfUEVSTUlTU0lPTlNfQk9VTkRBUlkpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVQb2xpY3lOYW1lKHBlcm1pc3Npb25zQm91bmRhcnkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwZXJtaXNzaW9uc0JvdW5kYXJ5KTtcbiAgICB9XG4gICAgLy8gaWYgbm8gUXVhbGlmaWVyIGlzIHN1cHBsaWVkLCByZXNvcnQgdG8gdGhlIGRlZmF1bHQgb25lXG4gICAgY29uc3QgYXJuID0gYXdhaXQgdGhpcy5nZXRFeGFtcGxlUGVybWlzc2lvbnNCb3VuZGFyeShcbiAgICAgIHBhcmFtcy5xdWFsaWZpZXIgPz8gJ2huYjY1OWZkcycsXG4gICAgICBwYXJ0aXRpb24sXG4gICAgICBlbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICAgc2RrLFxuICAgICk7XG4gICAgY29uc3QgcG9saWN5TmFtZSA9IGFybi5zcGxpdCgnLycpLnBvcCgpO1xuICAgIGlmICghcG9saWN5TmFtZSkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQ291bGQgbm90IHJldHJpZXZlIHRoZSBleGFtcGxlIHBlcm1pc3Npb24gYm91bmRhcnkhJyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocG9saWN5TmFtZSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldEV4YW1wbGVQZXJtaXNzaW9uc0JvdW5kYXJ5KFxuICAgIHF1YWxpZmllcjogc3RyaW5nLFxuICAgIHBhcnRpdGlvbjogc3RyaW5nLFxuICAgIGFjY291bnQ6IHN0cmluZyxcbiAgICBzZGs6IFNESyxcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBpYW0gPSBzZGsuaWFtKCk7XG5cbiAgICBsZXQgcG9saWN5TmFtZSA9IGBjZGstJHtxdWFsaWZpZXJ9LXBlcm1pc3Npb25zLWJvdW5kYXJ5YDtcbiAgICBjb25zdCBhcm4gPSBgYXJuOiR7cGFydGl0aW9ufTppYW06OiR7YWNjb3VudH06cG9saWN5LyR7cG9saWN5TmFtZX1gO1xuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBnZXRQb2xpY3lSZXNwID0gYXdhaXQgaWFtLmdldFBvbGljeSh7IFBvbGljeUFybjogYXJuIH0pO1xuICAgICAgaWYgKGdldFBvbGljeVJlc3AuUG9saWN5KSB7XG4gICAgICAgIHJldHVybiBhcm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vSUFNL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0dldFBvbGljeS5odG1sI0FQSV9HZXRQb2xpY3lfRXJyb3JzXG4gICAgICBpZiAoZS5uYW1lID09PSAnTm9TdWNoRW50aXR5Jykge1xuICAgICAgICAvLyBub29wLCBwcm9jZWVkIHdpdGggY3JlYXRpbmcgdGhlIHBvbGljeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwb2xpY3lEb2MgPSB7XG4gICAgICBWZXJzaW9uOiAnMjAxMi0xMC0xNycsXG4gICAgICBTdGF0ZW1lbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIEFjdGlvbjogWycqJ10sXG4gICAgICAgICAgUmVzb3VyY2U6ICcqJyxcbiAgICAgICAgICBFZmZlY3Q6ICdBbGxvdycsXG4gICAgICAgICAgU2lkOiAnRXhwbGljaXRBbGxvd0FsbCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBDb25kaXRpb246IHtcbiAgICAgICAgICAgIFN0cmluZ0VxdWFsczoge1xuICAgICAgICAgICAgICAnaWFtOlBlcm1pc3Npb25zQm91bmRhcnknOiBgYXJuOiR7cGFydGl0aW9ufTppYW06OiR7YWNjb3VudH06cG9saWN5L2Nkay0ke3F1YWxpZmllcn0tcGVybWlzc2lvbnMtYm91bmRhcnlgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIEFjdGlvbjogW1xuICAgICAgICAgICAgJ2lhbTpDcmVhdGVVc2VyJyxcbiAgICAgICAgICAgICdpYW06Q3JlYXRlUm9sZScsXG4gICAgICAgICAgICAnaWFtOlB1dFJvbGVQZXJtaXNzaW9uc0JvdW5kYXJ5JyxcbiAgICAgICAgICAgICdpYW06UHV0VXNlclBlcm1pc3Npb25zQm91bmRhcnknLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgUmVzb3VyY2U6ICcqJyxcbiAgICAgICAgICBFZmZlY3Q6ICdBbGxvdycsXG4gICAgICAgICAgU2lkOiAnRGVueUFjY2Vzc0lmUmVxdWlyZWRQZXJtQm91bmRhcnlJc05vdEJlaW5nQXBwbGllZCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBBY3Rpb246IFtcbiAgICAgICAgICAgICdpYW06Q3JlYXRlUG9saWN5VmVyc2lvbicsXG4gICAgICAgICAgICAnaWFtOkRlbGV0ZVBvbGljeScsXG4gICAgICAgICAgICAnaWFtOkRlbGV0ZVBvbGljeVZlcnNpb24nLFxuICAgICAgICAgICAgJ2lhbTpTZXREZWZhdWx0UG9saWN5VmVyc2lvbicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBSZXNvdXJjZTogYGFybjoke3BhcnRpdGlvbn06aWFtOjoke2FjY291bnR9OnBvbGljeS9jZGstJHtxdWFsaWZpZXJ9LXBlcm1pc3Npb25zLWJvdW5kYXJ5YCxcbiAgICAgICAgICBFZmZlY3Q6ICdEZW55JyxcbiAgICAgICAgICBTaWQ6ICdEZW55UGVybUJvdW5kYXJ5SUFNUG9saWN5QWx0ZXJhdGlvbicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBBY3Rpb246IFsnaWFtOkRlbGV0ZVVzZXJQZXJtaXNzaW9uc0JvdW5kYXJ5JywgJ2lhbTpEZWxldGVSb2xlUGVybWlzc2lvbnNCb3VuZGFyeSddLFxuICAgICAgICAgIFJlc291cmNlOiAnKicsXG4gICAgICAgICAgRWZmZWN0OiAnRGVueScsXG4gICAgICAgICAgU2lkOiAnRGVueVJlbW92YWxPZlBlcm1Cb3VuZGFyeUZyb21BbnlVc2VyT3JSb2xlJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgUG9saWN5TmFtZTogcG9saWN5TmFtZSxcbiAgICAgIFBvbGljeURvY3VtZW50OiBKU09OLnN0cmluZ2lmeShwb2xpY3lEb2MpLFxuICAgIH07XG4gICAgY29uc3QgY3JlYXRlUG9saWN5UmVzcG9uc2UgPSBhd2FpdCBpYW0uY3JlYXRlUG9saWN5KHJlcXVlc3QpO1xuICAgIGlmIChjcmVhdGVQb2xpY3lSZXNwb25zZS5Qb2xpY3k/LkFybikge1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvbGljeVJlc3BvbnNlLlBvbGljeS5Bcm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYENvdWxkIG5vdCByZXRyaWV2ZSB0aGUgZXhhbXBsZSBwZXJtaXNzaW9uIGJvdW5kYXJ5ICR7YXJufSFgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlUG9saWN5TmFtZShwZXJtaXNzaW9uc0JvdW5kYXJ5OiBzdHJpbmcpIHtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vSUFNL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0NyZWF0ZVBvbGljeS5odG1sXG4gICAgLy8gQWRkZWQgc3VwcG9ydCBmb3IgcG9saWN5IG5hbWVzIHdpdGggYSBwYXRoXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvMjYzMjBcbiAgICBjb25zdCByZWdleHA6IFJlZ0V4cCA9IC9bXFx3K1xcLz0sLkAtXSsvO1xuICAgIGNvbnN0IG1hdGNoZXMgPSByZWdleHAuZXhlYyhwZXJtaXNzaW9uc0JvdW5kYXJ5KTtcbiAgICBpZiAoIShtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID09PSAxICYmIG1hdGNoZXNbMF0gPT09IHBlcm1pc3Npb25zQm91bmRhcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGUgcGVybWlzc2lvbnMgYm91bmRhcnkgbmFtZSAke3Blcm1pc3Npb25zQm91bmRhcnl9IGRvZXMgbm90IG1hdGNoIHRoZSBJQU0gY29udmVudGlvbnMuYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjdXN0b21Cb290c3RyYXAoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgICBvcHRpb25zOiBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgPSB7fSxcbiAgKTogUHJvbWlzZTxTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgICAvLyBMb29rIGF0IHRoZSB0ZW1wbGF0ZSwgZGVjaWRlIHdoZXRoZXIgaXQncyBtb3N0IGxpa2VseSBhIGxlZ2FjeSBvciBtb2Rlcm4gYm9vdHN0cmFwXG4gICAgLy8gdGVtcGxhdGUsIGFuZCB1c2UgdGhlIHJpZ2h0IGJvb3RzdHJhcHBlciBmb3IgdGhhdC5cbiAgICBjb25zdCB2ZXJzaW9uID0gYm9vdHN0cmFwVmVyc2lvbkZyb21UZW1wbGF0ZShhd2FpdCB0aGlzLmxvYWRUZW1wbGF0ZSgpKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVnYWN5Qm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVybkJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNldCBvZiBwYXJhbWV0ZXIgbmFtZXMgYWNjZXB0ZWQgYnkgdGhlIGN1cnJlbnQgYm9vdHN0cmFwcGluZyB0ZW1wbGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB0ZW1wbGF0ZVBhcmFtZXRlcnMobGVnYWN5UGFyYW1zOiBCb290c3RyYXBwaW5nUGFyYW1ldGVycyA9IHt9KTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUobGVnYWN5UGFyYW1zKTtcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0ZW1wbGF0ZS5QYXJhbWV0ZXJzID8/IHt9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZFRlbXBsYXRlKGxlZ2FjeVBhcmFtczogQm9vdHN0cmFwcGluZ1BhcmFtZXRlcnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgc3dpdGNoICh0aGlzLnNvdXJjZS5zb3VyY2UpIHtcbiAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgIHJldHVybiBsb2FkU3RydWN0dXJlZEZpbGUodGhpcy5zb3VyY2UudGVtcGxhdGVGaWxlKTtcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICByZXR1cm4gbG9hZFN0cnVjdHVyZWRGaWxlKHBhdGguam9pbihidW5kbGVkUGFja2FnZVJvb3REaXIoX19kaXJuYW1lKSwgJ2xpYicsICdhcGknLCAnYm9vdHN0cmFwJywgJ2Jvb3RzdHJhcC10ZW1wbGF0ZS55YW1sJykpO1xuICAgICAgY2FzZSAnbGVnYWN5JzpcbiAgICAgICAgcmV0dXJuIGxlZ2FjeUJvb3RzdHJhcFRlbXBsYXRlKGxlZ2FjeVBhcmFtcyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWFnaWMgcGFyYW1ldGVyIHZhbHVlIHRoYXQgd2lsbCBjYXVzZSB0aGUgYm9vdHN0cmFwLXRlbXBsYXRlLnltbCB0byBOT1QgY3JlYXRlIGEgQ01LIGJ1dCB1c2UgdGhlIGRlZmF1bHQga2V5XG4gKi9cbmNvbnN0IFVTRV9BV1NfTUFOQUdFRF9LRVkgPSAnQVdTX01BTkFHRURfS0VZJztcblxuLyoqXG4gKiBNYWdpYyBwYXJhbWV0ZXIgdmFsdWUgdGhhdCB3aWxsIGNhdXNlIHRoZSBib290c3RyYXAtdGVtcGxhdGUueW1sIHRvIGNyZWF0ZSBhIENNS1xuICovXG5jb25zdCBDUkVBVEVfTkVXX0tFWSA9ICcnO1xuLyoqXG4gKiBQYXJhbWV0ZXIgdmFsdWUgaW5kaWNhdGluZyB0aGUgdXNlIG9mIHRoZSBkZWZhdWx0LCBDREsgcHJvdmlkZWQgcGVybWlzc2lvbnMgYm91bmRhcnkgZm9yIGJvb3RzdHJhcC10ZW1wbGF0ZS55bWxcbiAqL1xuY29uc3QgQ0RLX0JPT1RTVFJBUF9QRVJNSVNTSU9OU19CT1VOREFSWSA9ICdDREtfQk9PVFNUUkFQX1BFUk1JU1NJT05TX0JPVU5EQVJZJztcblxuLyoqXG4gKiBTcGxpdCBhbiBhcnJheS1saWtlIENsb3VkRm9ybWF0aW9uIHBhcmFtZXRlciBvbiAsXG4gKlxuICogQW4gZW1wdHkgc3RyaW5nIGlzIHRoZSBlbXB0eSBhcnJheSAoaW5zdGVhZCBvZiBgWycnXWApLlxuICovXG5mdW5jdGlvbiBzcGxpdENmbkFycmF5KHhzOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmdbXSB7XG4gIGlmICh4cyA9PT0gJycgfHwgeHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4geHMuc3BsaXQoJywnKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uPEE+KHhzOiBTZXQ8QT4sIHlzOiBTZXQ8QT4pOiBTZXQ8QT4ge1xuICByZXR1cm4gbmV3IFNldDxBPihBcnJheS5mcm9tKHhzKS5maWx0ZXIoeCA9PiB5cy5oYXMoeCkpKTtcbn1cbiJdfQ==