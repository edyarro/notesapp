"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RefactoringContext = void 0;
const cloudformation_1 = require("./cloudformation");
const digest_1 = require("./digest");
const toolkit_error_1 = require("../../toolkit/toolkit-error");
const sets_1 = require("../../util/sets");
/**
 * Encapsulates the information for refactoring resources in a single environment.
 */
class RefactoringContext {
    _mappings = [];
    ambiguousMoves = [];
    environment;
    constructor(props) {
        this.environment = props.environment;
        const moves = resourceMoves(props.deployedStacks, props.localStacks, 'direct', props.ignoreModifications);
        const additionalOverrides = structuralOverrides(props.deployedStacks, props.localStacks);
        const overrides = (props.overrides ?? []).concat(additionalOverrides);
        const [nonAmbiguousMoves, ambiguousMoves] = partitionByAmbiguity(overrides, moves);
        this.ambiguousMoves = ambiguousMoves;
        this._mappings = resourceMappings(nonAmbiguousMoves);
    }
    get ambiguousPaths() {
        return this.ambiguousMoves.map(([a, b]) => [convert(a), convert(b)]);
        function convert(locations) {
            return locations.map((l) => l.toPath());
        }
    }
    get mappings() {
        return this._mappings;
    }
}
exports.RefactoringContext = RefactoringContext;
/**
 * Generates an automatic list of overrides that can be deduced from the structure of the opposite resource graph.
 * Suppose we have the following resource graph:
 *
 *     A --> B
 *     C --> D
 *
 * such that B and D are identical, but A is different from C. Then digest(B) = digest(D). If both resources are moved,
 * we have an ambiguity. But if we reverse the arrows:
 *
 *     A <-- B
 *     C <-- D
 *
 * then digest(B) â‰  digest(D), because they now have different dependencies. If we compute the mappings from this
 * opposite graph, we can use them as a set of overrides to disambiguate the original moves.
 *
 */
function structuralOverrides(deployedStacks, localStacks) {
    const moves = resourceMoves(deployedStacks, localStacks, 'opposite', true);
    const [nonAmbiguousMoves] = partitionByAmbiguity([], moves);
    return resourceMappings(nonAmbiguousMoves);
}
function resourceMoves(before, after, direction = 'direct', ignoreModifications = false) {
    const digestsBefore = resourceDigests(before, direction);
    const digestsAfter = resourceDigests(after, direction);
    const stackNames = (stacks) => stacks
        .map((s) => s.stackName)
        .sort()
        .join(', ');
    if (!(ignoreModifications || isomorphic(digestsBefore, digestsAfter))) {
        const message = [
            'A refactor operation cannot add, remove or update resources. Only resource moves and renames are allowed. ',
            "Run 'cdk diff' to compare the local templates to the deployed stacks.\n",
            `Deployed stacks: ${stackNames(before)}`,
            `Local stacks: ${stackNames(after)}`,
        ];
        throw new toolkit_error_1.ToolkitError(message.join('\n'));
    }
    return Object.values(removeUnmovedResources(zip(digestsBefore, digestsAfter)));
}
/**
 * Whether two sets of resources have the same elements (uniquely identified by the digest), and
 * each element is in the same number of locations. The locations themselves may be different.
 */
function isomorphic(a, b) {
    const sameKeys = (0, sets_1.equalSets)(new Set(Object.keys(a)), new Set(Object.keys(b)));
    return sameKeys && Object.entries(a).every(([digest, locations]) => locations.length === b[digest].length);
}
function removeUnmovedResources(moves) {
    const result = {};
    for (const [hash, [before, after]] of Object.entries(moves)) {
        const common = before.filter((b) => after.some((a) => a.equalTo(b)));
        result[hash] = [
            before.filter((b) => !common.some((c) => b.equalTo(c))),
            after.filter((a) => !common.some((c) => a.equalTo(c))),
        ];
    }
    return result;
}
/**
 * For each hash, identifying a single resource, zip the two lists of locations,
 * producing a resource move
 */
function zip(m1, m2) {
    const result = {};
    for (const [hash, locations] of Object.entries(m1)) {
        if (hash in m2) {
            result[hash] = [locations, m2[hash]];
        }
        else {
            result[hash] = [locations, []];
        }
    }
    for (const [hash, locations] of Object.entries(m2)) {
        if (!(hash in m1)) {
            result[hash] = [[], locations];
        }
    }
    return result;
}
/**
 * Computes a list of pairs [digest, location] for each resource in the stack.
 */
function resourceDigests(stacks, direction) {
    // index stacks by name
    const stacksByName = new Map();
    for (const stack of stacks) {
        stacksByName.set(stack.stackName, stack);
    }
    const digests = (0, digest_1.computeResourceDigests)(stacks, direction);
    return groupByKey(Object.entries(digests).map(([loc, digest]) => {
        const [stackName, logicalId] = loc.split('.');
        const location = new cloudformation_1.ResourceLocation(stacksByName.get(stackName), logicalId);
        return [digest, location];
    }));
    function groupByKey(entries) {
        const result = {};
        for (const [key, value] of entries) {
            if (key in result) {
                result[key].push(value);
            }
            else {
                result[key] = [value];
            }
        }
        return result;
    }
}
function isAmbiguousMove(move) {
    const [pre, post] = move;
    // A move is considered ambiguous if two conditions are met:
    //  1. Both sides have at least one element (otherwise, it's just addition or deletion)
    //  2. At least one side has more than one element
    return pre.length > 0 && post.length > 0 && (pre.length > 1 || post.length > 1);
}
function resourceMappings(movements) {
    return movements
        .filter(([pre, post]) => pre.length === 1 && post.length === 1 && !pre[0].equalTo(post[0]))
        .map(([pre, post]) => new cloudformation_1.ResourceMapping(pre[0], post[0]));
}
/**
 * Partitions a list of moves into non-ambiguous and ambiguous moves.
 * @param overrides - The list of overrides to disambiguate moves
 * @param moves - a pair of lists of moves. First: non-ambiguous, second: ambiguous
 */
function partitionByAmbiguity(overrides, moves) {
    const ambiguous = [];
    const nonAmbiguous = [];
    for (let move of moves) {
        if (!isAmbiguousMove(move)) {
            nonAmbiguous.push(move);
        }
        else {
            for (const override of overrides) {
                const resolvedMove = resolve(override, move);
                if (resolvedMove != null) {
                    nonAmbiguous.push(resolvedMove);
                    move = remove(override, move);
                }
            }
            // One last chance to be non-ambiguous
            if (!isAmbiguousMove(move)) {
                nonAmbiguous.push(move);
            }
            else {
                ambiguous.push(move);
            }
        }
    }
    function resolve(override, move) {
        const [pre, post] = move;
        const source = pre.find((loc) => loc.equalTo(override.source));
        const destination = post.find((loc) => loc.equalTo(override.destination));
        return (source && destination) ? [[source], [destination]] : undefined;
    }
    function remove(override, move) {
        const [pre, post] = move;
        return [
            pre.filter(loc => !loc.equalTo(override.source)),
            post.filter(loc => !loc.equalTo(override.destination)),
        ];
    }
    return [nonAmbiguous, ambiguous];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnRleHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEscURBQXFFO0FBRXJFLHFDQUFrRDtBQUNsRCwrREFBMkQ7QUFDM0QsMENBQTRDO0FBaUI1Qzs7R0FFRztBQUNILE1BQWEsa0JBQWtCO0lBQ1osU0FBUyxHQUFzQixFQUFFLENBQUM7SUFDbEMsY0FBYyxHQUFtQixFQUFFLENBQUM7SUFDckMsV0FBVyxDQUFjO0lBRXpDLFlBQVksS0FBZ0M7UUFDMUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO1FBQ3JDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLEtBQUssQ0FBQyxXQUFXLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQzFHLE1BQU0sbUJBQW1CLEdBQUcsbUJBQW1CLENBQUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDekYsTUFBTSxTQUFTLEdBQUcsQ0FBQyxLQUFLLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3RFLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxjQUFjLENBQUMsR0FBRyxvQkFBb0IsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbkYsSUFBSSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7UUFFckMsSUFBSSxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxJQUFXLGNBQWM7UUFDdkIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFB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QUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQy9ELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFDMUUsT0FBTyxDQUFDLE1BQU0sSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ3pFLENBQUM7SUFFRCxTQUFTLE1BQU0sQ0FBQyxRQUF5QixFQUFFLElBQWtCO1FBQzNELE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLE9BQU87WUFDTCxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNoRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUN2RCxDQUFDO0lBQ0osQ0FBQztJQUVELE9BQU8sQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDbkMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRW52aXJvbm1lbnQgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHR5cGUgeyBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBSZXNvdXJjZUxvY2F0aW9uLCBSZXNvdXJjZU1hcHBpbmcgfSBmcm9tICcuL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB0eXBlIHsgR3JhcGhEaXJlY3Rpb24gfSBmcm9tICcuL2RpZ2VzdCc7XG5pbXBvcnQgeyBjb21wdXRlUmVzb3VyY2VEaWdlc3RzIH0gZnJvbSAnLi9kaWdlc3QnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC90b29sa2l0LWVycm9yJztcbmltcG9ydCB7IGVxdWFsU2V0cyB9IGZyb20gJy4uLy4uL3V0aWwvc2V0cyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNldCBvZiBwb3NzaWJsZSBtb3ZlcyBvZiBhIHJlc291cmNlIGZyb20gb25lIGxvY2F0aW9uXG4gKiB0byBhbm90aGVyLiBJbiB0aGUgaWRlYWwgY2FzZSwgdGhlcmUgaXMgb25seSBvbmUgc291cmNlIGFuZCBvbmx5IG9uZVxuICogZGVzdGluYXRpb24uXG4gKi9cbnR5cGUgUmVzb3VyY2VNb3ZlID0gW1Jlc291cmNlTG9jYXRpb25bXSwgUmVzb3VyY2VMb2NhdGlvbltdXTtcblxuZXhwb3J0IGludGVyZmFjZSBSZWZhY3RvcmluZ0NvbnRleHRPcHRpb25zIHtcbiAgZW52aXJvbm1lbnQ6IEVudmlyb25tZW50O1xuICBsb2NhbFN0YWNrczogQ2xvdWRGb3JtYXRpb25TdGFja1tdO1xuICBkZXBsb3llZFN0YWNrczogQ2xvdWRGb3JtYXRpb25TdGFja1tdO1xuICBvdmVycmlkZXM/OiBSZXNvdXJjZU1hcHBpbmdbXTtcbiAgaWdub3JlTW9kaWZpY2F0aW9ucz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogRW5jYXBzdWxhdGVzIHRoZSBpbmZvcm1hdGlvbiBmb3IgcmVmYWN0b3JpbmcgcmVzb3VyY2VzIGluIGEgc2luZ2xlIGVudmlyb25tZW50LlxuICovXG5leHBvcnQgY2xhc3MgUmVmYWN0b3JpbmdDb250ZXh0IHtcbiAgcHJpdmF0ZSByZWFkb25seSBfbWFwcGluZ3M6IFJlc291cmNlTWFwcGluZ1tdID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgYW1iaWd1b3VzTW92ZXM6IFJlc291cmNlTW92ZVtdID0gW107XG4gIHB1YmxpYyByZWFkb25seSBlbnZpcm9ubWVudDogRW52aXJvbm1lbnQ7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFJlZmFjdG9yaW5nQ29udGV4dE9wdGlvbnMpIHtcbiAgICB0aGlzLmVudmlyb25tZW50ID0gcHJvcHMuZW52aXJvbm1lbnQ7XG4gICAgY29uc3QgbW92ZXMgPSByZXNvdXJjZU1vdmVzKHByb3BzLmRlcGxveWVkU3RhY2tzLCBwcm9wcy5sb2NhbFN0YWNrcywgJ2RpcmVjdCcsIHByb3BzLmlnbm9yZU1vZGlmaWNhdGlvbnMpO1xuICAgIGNvbnN0IGFkZGl0aW9uYWxPdmVycmlkZXMgPSBzdHJ1Y3R1cmFsT3ZlcnJpZGVzKHByb3BzLmRlcGxveWVkU3RhY2tzLCBwcm9wcy5sb2NhbFN0YWNrcyk7XG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gKHByb3BzLm92ZXJyaWRlcyA/PyBbXSkuY29uY2F0KGFkZGl0aW9uYWxPdmVycmlkZXMpO1xuICAgIGNvbnN0IFtub25BbWJpZ3VvdXNNb3ZlcywgYW1iaWd1b3VzTW92ZXNdID0gcGFydGl0aW9uQnlBbWJpZ3VpdHkob3ZlcnJpZGVzLCBtb3Zlcyk7XG4gICAgdGhpcy5hbWJpZ3VvdXNNb3ZlcyA9IGFtYmlndW91c01vdmVzO1xuXG4gICAgdGhpcy5fbWFwcGluZ3MgPSByZXNvdXJjZU1hcHBpbmdzKG5vbkFtYmlndW91c01vdmVzKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYW1iaWd1b3VzUGF0aHMoKTogW3N0cmluZ1tdLCBzdHJpbmdbXV1bXSB7XG4gICAgcmV0dXJuIHRoaXMuYW1iaWd1b3VzTW92ZXMubWFwKChbYSwgYl0pID0+IFtjb252ZXJ0KGEpLCBjb252ZXJ0KGIpXSk7XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0KGxvY2F0aW9uczogUmVzb3VyY2VMb2NhdGlvbltdKTogc3RyaW5nW10ge1xuICAgICAgcmV0dXJuIGxvY2F0aW9ucy5tYXAoKGwpID0+IGwudG9QYXRoKCkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgbWFwcGluZ3MoKTogUmVzb3VyY2VNYXBwaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9tYXBwaW5ncztcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhdXRvbWF0aWMgbGlzdCBvZiBvdmVycmlkZXMgdGhhdCBjYW4gYmUgZGVkdWNlZCBmcm9tIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIG9wcG9zaXRlIHJlc291cmNlIGdyYXBoLlxuICogU3VwcG9zZSB3ZSBoYXZlIHRoZSBmb2xsb3dpbmcgcmVzb3VyY2UgZ3JhcGg6XG4gKlxuICogICAgIEEgLS0+IEJcbiAqICAgICBDIC0tPiBEXG4gKlxuICogc3VjaCB0aGF0IEIgYW5kIEQgYXJlIGlkZW50aWNhbCwgYnV0IEEgaXMgZGlmZmVyZW50IGZyb20gQy4gVGhlbiBkaWdlc3QoQikgPSBkaWdlc3QoRCkuIElmIGJvdGggcmVzb3VyY2VzIGFyZSBtb3ZlZCxcbiAqIHdlIGhhdmUgYW4gYW1iaWd1aXR5LiBCdXQgaWYgd2UgcmV2ZXJzZSB0aGUgYXJyb3dzOlxuICpcbiAqICAgICBBIDwtLSBCXG4gKiAgICAgQyA8LS0gRFxuICpcbiAqIHRoZW4gZGlnZXN0KEIpIOKJoCBkaWdlc3QoRCksIGJlY2F1c2UgdGhleSBub3cgaGF2ZSBkaWZmZXJlbnQgZGVwZW5kZW5jaWVzLiBJZiB3ZSBjb21wdXRlIHRoZSBtYXBwaW5ncyBmcm9tIHRoaXNcbiAqIG9wcG9zaXRlIGdyYXBoLCB3ZSBjYW4gdXNlIHRoZW0gYXMgYSBzZXQgb2Ygb3ZlcnJpZGVzIHRvIGRpc2FtYmlndWF0ZSB0aGUgb3JpZ2luYWwgbW92ZXMuXG4gKlxuICovXG5mdW5jdGlvbiBzdHJ1Y3R1cmFsT3ZlcnJpZGVzKGRlcGxveWVkU3RhY2tzOiBDbG91ZEZvcm1hdGlvblN0YWNrW10sIGxvY2FsU3RhY2tzOiBDbG91ZEZvcm1hdGlvblN0YWNrW10pOiBSZXNvdXJjZU1hcHBpbmdbXSB7XG4gIGNvbnN0IG1vdmVzID0gcmVzb3VyY2VNb3ZlcyhkZXBsb3llZFN0YWNrcywgbG9jYWxTdGFja3MsICdvcHBvc2l0ZScsIHRydWUpO1xuICBjb25zdCBbbm9uQW1iaWd1b3VzTW92ZXNdID0gcGFydGl0aW9uQnlBbWJpZ3VpdHkoW10sIG1vdmVzKTtcbiAgcmV0dXJuIHJlc291cmNlTWFwcGluZ3Mobm9uQW1iaWd1b3VzTW92ZXMpO1xufVxuXG5mdW5jdGlvbiByZXNvdXJjZU1vdmVzKFxuICBiZWZvcmU6IENsb3VkRm9ybWF0aW9uU3RhY2tbXSxcbiAgYWZ0ZXI6IENsb3VkRm9ybWF0aW9uU3RhY2tbXSxcbiAgZGlyZWN0aW9uOiBHcmFwaERpcmVjdGlvbiA9ICdkaXJlY3QnLFxuICBpZ25vcmVNb2RpZmljYXRpb25zOiBib29sZWFuID0gZmFsc2UpOiBSZXNvdXJjZU1vdmVbXSB7XG4gIGNvbnN0IGRpZ2VzdHNCZWZvcmUgPSByZXNvdXJjZURpZ2VzdHMoYmVmb3JlLCBkaXJlY3Rpb24pO1xuICBjb25zdCBkaWdlc3RzQWZ0ZXIgPSByZXNvdXJjZURpZ2VzdHMoYWZ0ZXIsIGRpcmVjdGlvbik7XG5cbiAgY29uc3Qgc3RhY2tOYW1lcyA9IChzdGFja3M6IENsb3VkRm9ybWF0aW9uU3RhY2tbXSkgPT5cbiAgICBzdGFja3NcbiAgICAgIC5tYXAoKHMpID0+IHMuc3RhY2tOYW1lKVxuICAgICAgLnNvcnQoKVxuICAgICAgLmpvaW4oJywgJyk7XG4gIGlmICghKGlnbm9yZU1vZGlmaWNhdGlvbnMgfHwgaXNvbW9ycGhpYyhkaWdlc3RzQmVmb3JlLCBkaWdlc3RzQWZ0ZXIpKSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAnQSByZWZhY3RvciBvcGVyYXRpb24gY2Fubm90IGFkZCwgcmVtb3ZlIG9yIHVwZGF0ZSByZXNvdXJjZXMuIE9ubHkgcmVzb3VyY2UgbW92ZXMgYW5kIHJlbmFtZXMgYXJlIGFsbG93ZWQuICcsXG4gICAgICBcIlJ1biAnY2RrIGRpZmYnIHRvIGNvbXBhcmUgdGhlIGxvY2FsIHRlbXBsYXRlcyB0byB0aGUgZGVwbG95ZWQgc3RhY2tzLlxcblwiLFxuICAgICAgYERlcGxveWVkIHN0YWNrczogJHtzdGFja05hbWVzKGJlZm9yZSl9YCxcbiAgICAgIGBMb2NhbCBzdGFja3M6ICR7c3RhY2tOYW1lcyhhZnRlcil9YCxcbiAgICBdO1xuXG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihtZXNzYWdlLmpvaW4oJ1xcbicpKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QudmFsdWVzKHJlbW92ZVVubW92ZWRSZXNvdXJjZXMoemlwKGRpZ2VzdHNCZWZvcmUsIGRpZ2VzdHNBZnRlcikpKTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHR3byBzZXRzIG9mIHJlc291cmNlcyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzICh1bmlxdWVseSBpZGVudGlmaWVkIGJ5IHRoZSBkaWdlc3QpLCBhbmRcbiAqIGVhY2ggZWxlbWVudCBpcyBpbiB0aGUgc2FtZSBudW1iZXIgb2YgbG9jYXRpb25zLiBUaGUgbG9jYXRpb25zIHRoZW1zZWx2ZXMgbWF5IGJlIGRpZmZlcmVudC5cbiAqL1xuZnVuY3Rpb24gaXNvbW9ycGhpYyhhOiBSZWNvcmQ8c3RyaW5nLCBSZXNvdXJjZUxvY2F0aW9uW10+LCBiOiBSZWNvcmQ8c3RyaW5nLCBSZXNvdXJjZUxvY2F0aW9uW10+KTogYm9vbGVhbiB7XG4gIGNvbnN0IHNhbWVLZXlzID0gZXF1YWxTZXRzKG5ldyBTZXQoT2JqZWN0LmtleXMoYSkpLCBuZXcgU2V0KE9iamVjdC5rZXlzKGIpKSk7XG4gIHJldHVybiBzYW1lS2V5cyAmJiBPYmplY3QuZW50cmllcyhhKS5ldmVyeSgoW2RpZ2VzdCwgbG9jYXRpb25zXSkgPT4gbG9jYXRpb25zLmxlbmd0aCA9PT0gYltkaWdlc3RdLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVVubW92ZWRSZXNvdXJjZXMobW92ZXM6IFJlY29yZDxzdHJpbmcsIFJlc291cmNlTW92ZT4pOiBSZWNvcmQ8c3RyaW5nLCBSZXNvdXJjZU1vdmU+IHtcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBSZXNvdXJjZU1vdmU+ID0ge307XG4gIGZvciAoY29uc3QgW2hhc2gsIFtiZWZvcmUsIGFmdGVyXV0gb2YgT2JqZWN0LmVudHJpZXMobW92ZXMpKSB7XG4gICAgY29uc3QgY29tbW9uID0gYmVmb3JlLmZpbHRlcigoYikgPT4gYWZ0ZXIuc29tZSgoYSkgPT4gYS5lcXVhbFRvKGIpKSk7XG4gICAgcmVzdWx0W2hhc2hdID0gW1xuICAgICAgYmVmb3JlLmZpbHRlcigoYikgPT4gIWNvbW1vbi5zb21lKChjKSA9PiBiLmVxdWFsVG8oYykpKSxcbiAgICAgIGFmdGVyLmZpbHRlcigoYSkgPT4gIWNvbW1vbi5zb21lKChjKSA9PiBhLmVxdWFsVG8oYykpKSxcbiAgICBdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGb3IgZWFjaCBoYXNoLCBpZGVudGlmeWluZyBhIHNpbmdsZSByZXNvdXJjZSwgemlwIHRoZSB0d28gbGlzdHMgb2YgbG9jYXRpb25zLFxuICogcHJvZHVjaW5nIGEgcmVzb3VyY2UgbW92ZVxuICovXG5mdW5jdGlvbiB6aXAoXG4gIG0xOiBSZWNvcmQ8c3RyaW5nLCBSZXNvdXJjZUxvY2F0aW9uW10+LFxuICBtMjogUmVjb3JkPHN0cmluZywgUmVzb3VyY2VMb2NhdGlvbltdPixcbik6IFJlY29yZDxzdHJpbmcsIFJlc291cmNlTW92ZT4ge1xuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIFJlc291cmNlTW92ZT4gPSB7fTtcblxuICBmb3IgKGNvbnN0IFtoYXNoLCBsb2NhdGlvbnNdIG9mIE9iamVjdC5lbnRyaWVzKG0xKSkge1xuICAgIGlmIChoYXNoIGluIG0yKSB7XG4gICAgICByZXN1bHRbaGFzaF0gPSBbbG9jYXRpb25zLCBtMltoYXNoXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtoYXNoXSA9IFtsb2NhdGlvbnMsIFtdXTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IFtoYXNoLCBsb2NhdGlvbnNdIG9mIE9iamVjdC5lbnRyaWVzKG0yKSkge1xuICAgIGlmICghKGhhc2ggaW4gbTEpKSB7XG4gICAgICByZXN1bHRbaGFzaF0gPSBbW10sIGxvY2F0aW9uc107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhIGxpc3Qgb2YgcGFpcnMgW2RpZ2VzdCwgbG9jYXRpb25dIGZvciBlYWNoIHJlc291cmNlIGluIHRoZSBzdGFjay5cbiAqL1xuZnVuY3Rpb24gcmVzb3VyY2VEaWdlc3RzKHN0YWNrczogQ2xvdWRGb3JtYXRpb25TdGFja1tdLCBkaXJlY3Rpb246IEdyYXBoRGlyZWN0aW9uKTogUmVjb3JkPHN0cmluZywgUmVzb3VyY2VMb2NhdGlvbltdPiB7XG4gIC8vIGluZGV4IHN0YWNrcyBieSBuYW1lXG4gIGNvbnN0IHN0YWNrc0J5TmFtZSA9IG5ldyBNYXA8c3RyaW5nLCBDbG91ZEZvcm1hdGlvblN0YWNrPigpO1xuICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgIHN0YWNrc0J5TmFtZS5zZXQoc3RhY2suc3RhY2tOYW1lLCBzdGFjayk7XG4gIH1cblxuICBjb25zdCBkaWdlc3RzID0gY29tcHV0ZVJlc291cmNlRGlnZXN0cyhzdGFja3MsIGRpcmVjdGlvbik7XG5cbiAgcmV0dXJuIGdyb3VwQnlLZXkoXG4gICAgT2JqZWN0LmVudHJpZXMoZGlnZXN0cykubWFwKChbbG9jLCBkaWdlc3RdKSA9PiB7XG4gICAgICBjb25zdCBbc3RhY2tOYW1lLCBsb2dpY2FsSWRdID0gbG9jLnNwbGl0KCcuJyk7XG4gICAgICBjb25zdCBsb2NhdGlvbjogUmVzb3VyY2VMb2NhdGlvbiA9IG5ldyBSZXNvdXJjZUxvY2F0aW9uKHN0YWNrc0J5TmFtZS5nZXQoc3RhY2tOYW1lKSEsIGxvZ2ljYWxJZCk7XG4gICAgICByZXR1cm4gW2RpZ2VzdCwgbG9jYXRpb25dO1xuICAgIH0pLFxuICApO1xuXG4gIGZ1bmN0aW9uIGdyb3VwQnlLZXk8QT4oZW50cmllczogW3N0cmluZywgQV1bXSk6IFJlY29yZDxzdHJpbmcsIEFbXT4ge1xuICAgIGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgQVtdPiA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcykge1xuICAgICAgaWYgKGtleSBpbiByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FtYmlndW91c01vdmUobW92ZTogUmVzb3VyY2VNb3ZlKTogYm9vbGVhbiB7XG4gIGNvbnN0IFtwcmUsIHBvc3RdID0gbW92ZTtcblxuICAvLyBBIG1vdmUgaXMgY29uc2lkZXJlZCBhbWJpZ3VvdXMgaWYgdHdvIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAgLy8gIDEuIEJvdGggc2lkZXMgaGF2ZSBhdCBsZWFzdCBvbmUgZWxlbWVudCAob3RoZXJ3aXNlLCBpdCdzIGp1c3QgYWRkaXRpb24gb3IgZGVsZXRpb24pXG4gIC8vICAyLiBBdCBsZWFzdCBvbmUgc2lkZSBoYXMgbW9yZSB0aGFuIG9uZSBlbGVtZW50XG4gIHJldHVybiBwcmUubGVuZ3RoID4gMCAmJiBwb3N0Lmxlbmd0aCA+IDAgJiYgKHByZS5sZW5ndGggPiAxIHx8IHBvc3QubGVuZ3RoID4gMSk7XG59XG5cbmZ1bmN0aW9uIHJlc291cmNlTWFwcGluZ3MobW92ZW1lbnRzOiBSZXNvdXJjZU1vdmVbXSk6IFJlc291cmNlTWFwcGluZ1tdIHtcbiAgcmV0dXJuIG1vdmVtZW50c1xuICAgIC5maWx0ZXIoKFtwcmUsIHBvc3RdKSA9PiBwcmUubGVuZ3RoID09PSAxICYmIHBvc3QubGVuZ3RoID09PSAxICYmICFwcmVbMF0uZXF1YWxUbyhwb3N0WzBdKSlcbiAgICAubWFwKChbcHJlLCBwb3N0XSkgPT4gbmV3IFJlc291cmNlTWFwcGluZyhwcmVbMF0sIHBvc3RbMF0pKTtcbn1cblxuLyoqXG4gKiBQYXJ0aXRpb25zIGEgbGlzdCBvZiBtb3ZlcyBpbnRvIG5vbi1hbWJpZ3VvdXMgYW5kIGFtYmlndW91cyBtb3Zlcy5cbiAqIEBwYXJhbSBvdmVycmlkZXMgLSBUaGUgbGlzdCBvZiBvdmVycmlkZXMgdG8gZGlzYW1iaWd1YXRlIG1vdmVzXG4gKiBAcGFyYW0gbW92ZXMgLSBhIHBhaXIgb2YgbGlzdHMgb2YgbW92ZXMuIEZpcnN0OiBub24tYW1iaWd1b3VzLCBzZWNvbmQ6IGFtYmlndW91c1xuICovXG5mdW5jdGlvbiBwYXJ0aXRpb25CeUFtYmlndWl0eShvdmVycmlkZXM6IFJlc291cmNlTWFwcGluZ1tdLCBtb3ZlczogUmVzb3VyY2VNb3ZlW10pOiBbUmVzb3VyY2VNb3ZlW10sIFJlc291cmNlTW92ZVtdXSB7XG4gIGNvbnN0IGFtYmlndW91czogUmVzb3VyY2VNb3ZlW10gPSBbXTtcbiAgY29uc3Qgbm9uQW1iaWd1b3VzOiBSZXNvdXJjZU1vdmVbXSA9IFtdO1xuXG4gIGZvciAobGV0IG1vdmUgb2YgbW92ZXMpIHtcbiAgICBpZiAoIWlzQW1iaWd1b3VzTW92ZShtb3ZlKSkge1xuICAgICAgbm9uQW1iaWd1b3VzLnB1c2gobW92ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3Qgb3ZlcnJpZGUgb2Ygb3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkTW92ZSA9IHJlc29sdmUob3ZlcnJpZGUsIG1vdmUpO1xuICAgICAgICBpZiAocmVzb2x2ZWRNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgICBub25BbWJpZ3VvdXMucHVzaChyZXNvbHZlZE1vdmUpO1xuICAgICAgICAgIG1vdmUgPSByZW1vdmUob3ZlcnJpZGUsIG1vdmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBPbmUgbGFzdCBjaGFuY2UgdG8gYmUgbm9uLWFtYmlndW91c1xuICAgICAgaWYgKCFpc0FtYmlndW91c01vdmUobW92ZSkpIHtcbiAgICAgICAgbm9uQW1iaWd1b3VzLnB1c2gobW92ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbWJpZ3VvdXMucHVzaChtb3ZlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlKG92ZXJyaWRlOiBSZXNvdXJjZU1hcHBpbmcsIG1vdmU6IFJlc291cmNlTW92ZSk6IFJlc291cmNlTW92ZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgW3ByZSwgcG9zdF0gPSBtb3ZlO1xuICAgIGNvbnN0IHNvdXJjZSA9IHByZS5maW5kKChsb2MpID0+IGxvYy5lcXVhbFRvKG92ZXJyaWRlLnNvdXJjZSkpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gcG9zdC5maW5kKChsb2MpID0+IGxvYy5lcXVhbFRvKG92ZXJyaWRlLmRlc3RpbmF0aW9uKSk7XG4gICAgcmV0dXJuIChzb3VyY2UgJiYgZGVzdGluYXRpb24pID8gW1tzb3VyY2VdLCBbZGVzdGluYXRpb25dXSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZShvdmVycmlkZTogUmVzb3VyY2VNYXBwaW5nLCBtb3ZlOiBSZXNvdXJjZU1vdmUpOiBSZXNvdXJjZU1vdmUge1xuICAgIGNvbnN0IFtwcmUsIHBvc3RdID0gbW92ZTtcbiAgICByZXR1cm4gW1xuICAgICAgcHJlLmZpbHRlcihsb2MgPT4gIWxvYy5lcXVhbFRvKG92ZXJyaWRlLnNvdXJjZSkpLFxuICAgICAgcG9zdC5maWx0ZXIobG9jID0+ICFsb2MuZXF1YWxUbyhvdmVycmlkZS5kZXN0aW5hdGlvbikpLFxuICAgIF07XG4gIH1cblxuICByZXR1cm4gW25vbkFtYmlndW91cywgYW1iaWd1b3VzXTtcbn1cbiJdfQ==