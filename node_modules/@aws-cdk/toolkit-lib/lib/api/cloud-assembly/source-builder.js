"use strict";
var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudAssemblySourceBuilder = void 0;
const path = require("path");
const util_1 = require("util");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const context_store_1 = require("./context-store");
const rwlock_1 = require("../rwlock");
const cached_source_1 = require("./cached-source");
const context_aware_source_1 = require("./private/context-aware-source");
const exec_1 = require("./private/exec");
const prepare_source_1 = require("./private/prepare-source");
const readable_assembly_1 = require("./private/readable-assembly");
const toolkit_error_1 = require("../../toolkit/toolkit-error");
const util_2 = require("../../util");
const private_1 = require("../io/private");
const helpers_1 = require("./private/helpers");
class CloudAssemblySourceBuilder {
    /**
     * Create a Cloud Assembly from a Cloud Assembly builder function.
     *
     * ## Outdir
     *
     * If no output directory is given, it will synthesize into a temporary system
     * directory. The temporary directory will be cleaned up, unless
     * `disposeOutdir: false`.
     *
     * A write lock will be acquired on the output directory for the duration of
     * the CDK app synthesis (which means that no two apps can synthesize at the
     * same time), and after synthesis a read lock will be acquired on the
     * directory. This means that while the CloudAssembly is being used, no CDK
     * app synthesis can take place into that directory.
     *
     * ## Context
     *
     * If no `contextStore` is given, a `MemoryContext` will be used. This means
     * no provider lookups will be persisted anywhere by default. Use a different
     * type of context store if you want persistence between synth operations.
     *
     * @param builder - the builder function
     * @param props - additional configuration properties
     * @returns the CloudAssembly source
     */
    async fromAssemblyBuilder(builder, props = {}) {
        const services = await this.sourceBuilderServices();
        const contextStore = props.contextStore ?? new context_store_1.MemoryContext();
        const contextAssemblyProps = {
            services,
            contextStore,
            lookups: props.lookups,
        };
        const outdir = props.outdir ? path.resolve(props.outdir) : undefined;
        return new context_aware_source_1.ContextAwareCloudAssemblySource({
            produce: async () => {
                const env_1 = { stack: [], error: void 0, hasError: false };
                try {
                    const execution = __addDisposableResource(env_1, await prepare_source_1.ExecutionEnvironment.create(services, {
                        outdir,
                        resolveDefaultAppEnv: props.resolveDefaultEnvironment ?? true,
                    }), true);
                    const synthParams = (0, prepare_source_1.parametersFromSynthOptions)(props.synthOptions);
                    const fullContext = {
                        ...await contextStore.read(),
                        ...synthParams.context,
                    };
                    await services.ioHelper.defaults.debug((0, util_1.format)('context:', fullContext));
                    const env = (0, util_2.noUndefined)({
                        // Versioning, outdir, default account and region
                        ...await execution.defaultEnvVars(),
                        // Environment variables derived from settings
                        ...synthParams.env,
                    });
                    const cleanupContextTemp = (0, prepare_source_1.writeContextToEnv)(env, fullContext, 'env-is-complete');
                    const _cleanupEnv = __addDisposableResource(env_1, (props.clobberEnv ?? true) ? (0, helpers_1.temporarilyWriteEnv)(env) : undefined, false);
                    let assembly;
                    try {
                        assembly = await builder({
                            outdir: execution.outdir,
                            context: fullContext,
                            env,
                        });
                    }
                    catch (error) {
                        // re-throw toolkit errors unchanged
                        if (toolkit_error_1.ToolkitError.isToolkitError(error)) {
                            throw error;
                        }
                        // otherwise, wrap into an assembly error
                        throw toolkit_error_1.AssemblyError.withCause('Assembly builder failed', error);
                    }
                    finally {
                        await cleanupContextTemp();
                    }
                    // Convert what we got to the definitely correct type we're expecting, a cxapi.CloudAssembly
                    const asm = cxapi.CloudAssembly.isCloudAssembly(assembly)
                        ? assembly
                        : await (0, prepare_source_1.assemblyFromDirectory)(assembly.directory, services.ioHelper, props.loadAssemblyOptions);
                    const success = await execution.markSuccessful();
                    const deleteOnDispose = props.disposeOutdir ?? execution.shouldDisposeOutDir;
                    return new readable_assembly_1.ReadableCloudAssembly(asm, success.readLock, { deleteOnDispose });
                }
                catch (e_1) {
                    env_1.error = e_1;
                    env_1.hasError = true;
                }
                finally {
                    const result_1 = __disposeResources(env_1);
                    if (result_1)
                        await result_1;
                }
            },
        }, contextAssemblyProps);
    }
    /**
     * Creates a Cloud Assembly from an existing assembly directory.
     *
     * A read lock will be acquired for the directory. This means that while
     * the CloudAssembly is being used, no CDK app synthesis can take place into
     * that directory.
     *
     * @param directory - directory the directory of a already produced Cloud Assembly.
     * @returns the CloudAssembly source
     */
    async fromAssemblyDirectory(directory, props = {}) {
        const services = await this.sourceBuilderServices();
        return {
            async produce() {
                await services.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0150.msg('--app points to a cloud assembly, so we bypass synth'));
                const readLock = await new rwlock_1.RWLock(directory).acquireRead();
                try {
                    const asm = await (0, prepare_source_1.assemblyFromDirectory)(directory, services.ioHelper, props.loadAssemblyOptions);
                    const assembly = new readable_assembly_1.ReadableCloudAssembly(asm, readLock, { deleteOnDispose: false });
                    if (assembly.cloudAssembly.manifest.missing && assembly.cloudAssembly.manifest.missing.length > 0) {
                        if (props.failOnMissingContext ?? true) {
                            const missingKeysSet = (0, helpers_1.missingContextKeys)(assembly.cloudAssembly.manifest.missing);
                            const missingKeys = Array.from(missingKeysSet);
                            throw toolkit_error_1.AssemblyError.withCause('Assembly contains missing context. ' +
                                "Make sure all necessary context is already in 'cdk.context.json' by running 'cdk synth' on a machine with sufficient AWS credentials and committing the result. " +
                                `Missing context keys: '${missingKeys.join(', ')}'`, 'Error producing assembly');
                        }
                    }
                    return new cached_source_1.CachedCloudAssembly(assembly);
                }
                catch (e) {
                    await readLock.release();
                    throw e;
                }
            },
        };
    }
    /**
     * Use a directory containing an AWS CDK app as source.
     *
     * The subprocess will execute in `workingDirectory`, which defaults to
     * the current process' working directory if not given.
     *
     * ## Outdir
     *
     * If an output directory is supplied, relative paths are evaluated with
     * respect to the current process' working directory. If an output directory
     * is not supplied, the default is a `cdk.out` directory underneath
     * `workingDirectory`. The output directory will not be cleaned up unless
     * `disposeOutdir: true`.
     *
     * A write lock will be acquired on the output directory for the duration of
     * the CDK app synthesis (which means that no two apps can synthesize at the
     * same time), and after synthesis a read lock will be acquired on the
     * directory.  This means that while the CloudAssembly is being used, no CDK
     * app synthesis can take place into that directory.
     *
     * ## Context
     *
     * If no `contextStore` is given, a `CdkAppMultiContext` will be used, initialized
     * to the app's `workingDirectory`. This means that context will be loaded from
     * all the CDK's default context sources, and updates will be written to
     * `cdk.context.json`.
     *
     * @param props - additional configuration properties
     * @returns the CloudAssembly source
     */
    async fromCdkApp(app, props = {}) {
        const services = await this.sourceBuilderServices();
        const workingDirectory = props.workingDirectory ?? process.cwd();
        const outdir = props.outdir ? path.resolve(props.outdir) : path.resolve(workingDirectory, 'cdk.out');
        const contextStore = props.contextStore ?? new context_store_1.CdkAppMultiContext(workingDirectory);
        const contextAssemblyProps = {
            services,
            contextStore,
            lookups: props.lookups,
        };
        return new context_aware_source_1.ContextAwareCloudAssemblySource({
            produce: async () => {
                const env_2 = { stack: [], error: void 0, hasError: false };
                try {
                    try {
                        fs.mkdirpSync(outdir);
                    }
                    catch (e) {
                        throw new toolkit_error_1.ToolkitError(`Could not create output directory at '${outdir}' (${e.message}).`);
                    }
                    const execution = __addDisposableResource(env_2, await prepare_source_1.ExecutionEnvironment.create(services, {
                        outdir,
                        resolveDefaultAppEnv: props.resolveDefaultEnvironment ?? true,
                    }), true);
                    const commandLine = await execution.guessExecutable(app);
                    const synthParams = (0, prepare_source_1.parametersFromSynthOptions)(props.synthOptions);
                    const fullContext = {
                        ...await contextStore.read(),
                        ...synthParams.context,
                    };
                    await services.ioHelper.defaults.debug((0, util_1.format)('context:', fullContext));
                    const env = (0, util_2.noUndefined)({
                        // Need to start with full env of `writeContextToEnv` will not be able to do the size
                        // calculation correctly.
                        ...process.env,
                        // User gave us something
                        ...props.env,
                        // Versioning, outdir, default account and region
                        ...await execution.defaultEnvVars(),
                        // Environment variables derived from settings
                        ...synthParams.env,
                    });
                    const cleanupTemp = (0, prepare_source_1.writeContextToEnv)(env, fullContext, 'env-is-complete');
                    try {
                        await (0, exec_1.execInChildProcess)(commandLine.join(' '), {
                            eventPublisher: async (type, line) => {
                                switch (type) {
                                    case 'data_stdout':
                                        await services.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I1001.msg(line));
                                        break;
                                    case 'data_stderr':
                                        await services.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_E1002.msg(line));
                                        break;
                                }
                            },
                            env,
                            cwd: workingDirectory,
                        });
                    }
                    finally {
                        await cleanupTemp();
                    }
                    const asm = await (0, prepare_source_1.assemblyFromDirectory)(outdir, services.ioHelper, props.loadAssemblyOptions);
                    const success = await execution.markSuccessful();
                    const deleteOnDispose = props.disposeOutdir ?? execution.shouldDisposeOutDir;
                    return new readable_assembly_1.ReadableCloudAssembly(asm, success.readLock, { deleteOnDispose });
                }
                catch (e_2) {
                    env_2.error = e_2;
                    env_2.hasError = true;
                }
                finally {
                    const result_2 = __disposeResources(env_2);
                    if (result_2)
                        await result_2;
                }
            },
        }, contextAssemblyProps);
    }
}
exports.CloudAssemblySourceBuilder = CloudAssemblySourceBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic291cmNlLWJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzb3VyY2UtYnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBQzdCLCtCQUE4QjtBQUU5Qix5Q0FBeUM7QUFDekMsK0JBQStCO0FBQy9CLG1EQUF3RjtBQUN4RixzQ0FBbUM7QUFDbkMsbURBQXNEO0FBRXRELHlFQUFpRjtBQUNqRix5Q0FBb0Q7QUFDcEQsNkRBQXNJO0FBQ3RJLG1FQUFvRTtBQUdwRSwrREFBMEU7QUFDMUUscUNBQXlDO0FBQ3pDLDJDQUFtQztBQUNuQywrQ0FBNEU7QUErUTVFLE1BQXNCLDBCQUEwQjtJQU85Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0JHO0lBQ0ksS0FBSyxDQUFDLG1CQUFtQixDQUM5QixPQUF3QixFQUN4QixRQUFvQyxFQUFFO1FBRXRDLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFDcEQsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLFlBQVksSUFBSSxJQUFJLDZCQUFhLEVBQUUsQ0FBQztRQUMvRCxNQUFNLG9CQUFvQixHQUFtQztZQUMzRCxRQUFRO1lBQ1IsWUFBWTtZQUNaLE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTztTQUN2QixDQUFDO1FBRUYsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUVyRSxPQUFPLElBQUksc0RBQStCLENBQ3hDO1lBQ0UsT0FBTyxFQUFFLEtBQUssSUFBSSxFQUFFOzs7b0JBQ2xCLE1BQVksU0FBUyxrQ0FBRyxNQUFNLHFDQUFvQixDQUFDLE1BQU0sQ0FBQyxRQUFRLEVB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LENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7d0NBQ2hFLE1BQU07b0NBQ1IsS0FBSyxhQUFhO3dDQUNoQixNQUFNLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzt3Q0FDaEUsTUFBTTtnQ0FDVixDQUFDOzRCQUNILENBQUM7NEJBQ0QsR0FBRzs0QkFDSCxHQUFHLEVBQUUsZ0JBQWdCO3lCQUN0QixDQUFDLENBQUM7b0JBQ0wsQ0FBQzs0QkFBUyxDQUFDO3dCQUNULE1BQU0sV0FBVyxFQUFFLENBQUM7b0JBQ3RCLENBQUM7b0JBRUQsTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFBLHNDQUFxQixFQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO29CQUU5RixNQUFNLE9BQU8sR0FBRyxNQUFNLFNBQVMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztvQkFDakQsTUFBTSxlQUFlLEdBQUcsS0FBSyxDQUFDLGFBQWEsSUFBSSxTQUFTLENBQUMsbUJBQW1CLENBQUM7b0JBQzdFLE9BQU8sSUFBSSx5Q0FBcUIsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUM7Ozs7Ozs7Ozs7O2FBQzlFO1NBQ0YsRUFDRCxvQkFBb0IsQ0FDckIsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQTdQRCxnRUE2UEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgdHlwZSAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgQ2RrQXBwTXVsdGlDb250ZXh0LCBNZW1vcnlDb250ZXh0LCB0eXBlIElDb250ZXh0U3RvcmUgfSBmcm9tICcuL2NvbnRleHQtc3RvcmUnO1xuaW1wb3J0IHsgUldMb2NrIH0gZnJvbSAnLi4vcndsb2NrJztcbmltcG9ydCB7IENhY2hlZENsb3VkQXNzZW1ibHkgfSBmcm9tICcuL2NhY2hlZC1zb3VyY2UnO1xuaW1wb3J0IHR5cGUgeyBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5UHJvcHMgfSBmcm9tICcuL3ByaXZhdGUvY29udGV4dC1hd2FyZS1zb3VyY2UnO1xuaW1wb3J0IHsgQ29udGV4dEF3YXJlQ2xvdWRBc3NlbWJseVNvdXJjZSB9IGZyb20gJy4vcHJpdmF0ZS9jb250ZXh0LWF3YXJlLXNvdXJjZSc7XG5pbXBvcnQgeyBleGVjSW5DaGlsZFByb2Nlc3MgfSBmcm9tICcuL3ByaXZhdGUvZXhlYyc7XG5pbXBvcnQgeyBFeGVjdXRpb25FbnZpcm9ubWVudCwgYXNzZW1ibHlGcm9tRGlyZWN0b3J5LCBwYXJhbWV0ZXJzRnJvbVN5bnRoT3B0aW9ucywgd3JpdGVDb250ZXh0VG9FbnYgfSBmcm9tICcuL3ByaXZhdGUvcHJlcGFyZS1zb3VyY2UnO1xuaW1wb3J0IHsgUmVhZGFibGVDbG91ZEFzc2VtYmx5IH0gZnJvbSAnLi9wcml2YXRlL3JlYWRhYmxlLWFzc2VtYmx5JztcbmltcG9ydCB0eXBlIHsgSUNsb3VkQXNzZW1ibHlTb3VyY2UgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgVG9vbGtpdFNlcnZpY2VzIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9wcml2YXRlJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciwgQXNzZW1ibHlFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvdG9vbGtpdC1lcnJvcic7XG5pbXBvcnQgeyBub1VuZGVmaW5lZCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgSU8gfSBmcm9tICcuLi9pby9wcml2YXRlJztcbmltcG9ydCB7IG1pc3NpbmdDb250ZXh0S2V5cywgdGVtcG9yYXJpbHlXcml0ZUVudiB9IGZyb20gJy4vcHJpdmF0ZS9oZWxwZXJzJztcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHRoZSBidWlsZGVyIGZ1bmN0aW9uIHJlY2VpdmVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFzc2VtYmx5QnVpbGRlclByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgZGlyZWN0b3J5IGludG8gd2hpY2ggdG8gdGhlIGJ1aWxkZXIgYXBwIHdpbGwgZW1pdCBzeW50aGVzaXplZCBhcnRpZmFjdHMuXG4gICAqL1xuICByZWFkb25seSBvdXRkaXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZXh0IHByb3ZpZGVkIHRwIHRoZSBidWlsZGVyIGFwcCB0byBzeW50aGVzaXplIHRoZSBDbG91ZCBBc3NlbWJseSwgaW5jbHVkaW5nIGxvb2tlZC11cCBjb250ZXh0LlxuICAgKi9cbiAgcmVhZG9ubHkgY29udGV4dD86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG5cbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIHBhc3NlZCB0byBhIENESyBhcHAgdXNpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAqXG4gICAqIFRoaXMgY29udGFpbnMgdmFyaWFibGVzIGludGVuZGVkIGZvciB0aGUgdXNlciBwb3J0aW9uIG9mIGEgQ0RLIGFwcCAobm90YWJseVxuICAgKiBgQ0RLX0RFRkFVTFRfQUNDT1VOVGAgYW5kIGBDREtfREVGQVVMVF9SRUdJT05gKSwgd2hpY2ggeW91IGNhbiBmcmVlbHkgcmVhZC5cbiAgICpcbiAgICogSXQgYWxzbyBjb250YWlucyB2YXJpYWJsZXMgaW50ZW5kZWQgZm9yIHRoZSBDREsgVG9vbGtpdCB0byBjb21tdW5pY2F0ZSB3aXRoXG4gICAqIHRoZSBpbnRlcm5hbHMgb2YgdGhlIGNvbnN0cnVjdCBsaWJyYXJ5LCBsaWtlIGBDREtfREVCVUdgIGFuZFxuICAgKiBgQ0RLX0NMSV9BU01fVkVSU0lPTmAuIFJlYWRpbmcgdGhlc2UgbGF0dGVyIHZhcmlhYmxlcyBpcyBwb3NzaWJsZSBidXQgbm90XG4gICAqIHJlY29tbWVuZGVkLCBhcyB0aGVpciBtZWFuaW5nIG1heSBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gICAqL1xuICByZWFkb25seSBlbnY6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIHN5bnRoZXNpcyBwYXJhbWV0ZXJzIGFuZCBwcm9kdWNlcyBhIENsb3VkIEFzc2VtYmx5XG4gKlxuICogTW9zdCB0eXBpY2FsbHksIHRoZSBwcm9wZXJ0aWVzIHBhc3NlZCBoZXJlIHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgYVxuICogYGNkay5BcHBgLCBhbmQgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGBhcHAuc3ludGgoKWAuXG4gKi9cbmV4cG9ydCB0eXBlIEFzc2VtYmx5QnVpbGRlciA9IChwcm9wczogQXNzZW1ibHlCdWlsZGVyUHJvcHMpID0+IFByb21pc2U8Y3hzY2hlbWEuSUNsb3VkQXNzZW1ibHk+O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgQ0xJIGZyb20gYW4gQVdTIENESyBBcHAgZGlyZWN0b3J5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXNzZW1ibHlEaXJlY3RvcnlQcm9wcyB7XG4gIC8qKlxuICAgKiBPcHRpb25zIHRvIGNvbmZpZ3VyZSBsb2FkaW5nIG9mIHRoZSBhc3NlbWJseSBhZnRlciBpdCBoYXMgYmVlbiBzeW50aGVzaXplZFxuICAgKi9cbiAgcmVhZG9ubHkgbG9hZEFzc2VtYmx5T3B0aW9ucz86IExvYWRBc3NlbWJseU9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIGZhaWwgaWYgdGhlIHN5bnRoZXNpemVkIGFzc2VtYmx5IGNvbnRhaW5zXG4gICAqIG1pc3NpbmcgY29udGV4dFxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBmYWlsT25NaXNzaW5nQ29udGV4dD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBDTEkgZnJvbSBhbiBBV1MgQ0RLIEFwcCBkaXJlY3RvcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBc3NlbWJseVNvdXJjZVByb3BzIHtcbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBzeW50aGVzaXplZCBjbG91ZCBhc3NlbWJseSBpbnRvIHRoZSBnaXZlbiBkaXJlY3RvcnlcbiAgICpcbiAgICogQGRlZmF1bHQgXCJjZGsub3V0XCJcbiAgICovXG4gIHJlYWRvbmx5IG91dGRpcj86IHN0cmluZztcblxuICAvKipcbiAgICogUGVyZm9ybSBjb250ZXh0IGxvb2t1cHMuXG4gICAqXG4gICAqIFN5bnRoZXNpcyBmYWlscyBpZiB0aGlzIGlzIGRpc2FibGVkIGFuZCBjb250ZXh0IGxvb2t1cHMgbmVlZCB0byBiZSBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGxvb2t1cHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIGNvbnRleHQgc3RvcmUgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAqXG4gICAqIFRoZSBjb250ZXh0IHN0b3JlIHdpbGwgYmUgdXNlZCB0byBzb3VyY2UgaW5pdGlhbCBjb250ZXh0IHZhbHVlcyxcbiAgICogYW5kIHVwZGF0ZWQgdmFsdWVzIHdpbGwgYmUgc3RvcmVkIGhlcmUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVwZW5kcyBvbiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICByZWFkb25seSBjb250ZXh0U3RvcmU/OiBJQ29udGV4dFN0b3JlO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0aHJvdWdoIHRoZSBjb250ZXh0IHRvIGEgQ0RLIGFwcCBvbiBzeW50aFxuICAgKi9cbiAgcmVhZG9ubHkgc3ludGhPcHRpb25zPzogQXBwU3ludGhPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIHRvIGNvbmZpZ3VyZSBsb2FkaW5nIG9mIHRoZSBhc3NlbWJseSBhZnRlciBpdCBoYXMgYmVlbiBzeW50aGVzaXplZFxuICAgKi9cbiAgcmVhZG9ubHkgbG9hZEFzc2VtYmx5T3B0aW9ucz86IExvYWRBc3NlbWJseU9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgYG91dGRpcmAgd2hlbiB0aGUgYXNzZW1ibHkgaXMgZGlzcG9zZWRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBgdHJ1ZWAgaWYgYG91dGRpcmAgaXMgbm90IGdpdmVuLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgcmVhZG9ubHkgZGlzcG9zZU91dGRpcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIGN1cnJlbnQgZGVmYXVsdCBlbnZpcm9ubWVudCBhbiBwcm92aWRlIGFzIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB0aGUgYXBwLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbWFrZSBhIChjYWNoZWQpIGNhbGwgdG8gU1RTIHRvIHJlc29sdmUgdGhlIGN1cnJlbnQgYWNjb3VudCB1c2luZ1xuICAgKiBiYXNlIGNyZWRlbnRpYWxzLiBUaGUgYmVoYXZpb3IgaXMgbm90IGFsd2F5cyBkZXNpcmFibGUgYW5kIGNhbiBhZGRcbiAgICogdW5uZWNlc3NhcnkgZGVsYXlzLCBlLmcuIHdoZW4gYW4gYXBwIHNwZWNpZmllcyBhbiBlbnZpcm9ubWVudCBleHBsaWNpdGx5XG4gICAqIG9yIHdoZW4gbG9jYWwgYWN0aW9ucyBhcmUgYmUgcGVyZm9ybWVkIHdpdGhvdXQgaW50ZXJuZXQgYWNjZXNzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSByZXNvbHZlRGVmYXVsdEVudmlyb25tZW50PzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgYGZyb21Bc3NlbWJseUJ1aWxkZXJgIEFzc2VtYmx5IFNvdXJjZSBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZyb21Bc3NlbWJseUJ1aWxkZXJPcHRpb25zIGV4dGVuZHMgQXNzZW1ibHlTb3VyY2VQcm9wcyB7XG4gIC8qKlxuICAgKiBNdXRhdGUgY3VycmVudCBwcm9jZXNzJyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gY29tbXVuaWNhdGUgd2l0aCBDREsgYXBwXG4gICAqXG4gICAqIFRoZXJlIGFyZSBhIG51bWJlciBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhlIFRvb2xraXQgdXNlcyB0byBwYXNzXG4gICAqIGluZm9ybWF0aW9uIHRvIHRoZSBDREsgYXBwLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBjdXJyZW50XG4gICAqIHByb2Nlc3MnIGdsb2JhbCBzaGFyZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGJlZm9yZSB0aGUgYnVpbGRlciBpcyBpbnZva2VkLFxuICAgKiBhbmQgeW91IGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgZWxzZS4gSG93ZXZlciwgYmVjYXVzZSB0aGlzIG11dGF0ZXNcbiAgICogc2hhcmVkIHN0YXRlIGl0IGlzIG5vdCBzYWZlIHRvIHJ1biBtdWx0aXBsZSBidWlsZGVycyBjb25jdXJyZW50bHkuXG4gICAqXG4gICAqIFNldCB0aGlzIHRvIGBmYWxzZWAgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIHNoYXJlZCBlbnZpcm9ubWVudC4gSW5zdGVhZCxcbiAgICogeW91IHdpbGwgbmVlZCB0byBwYXNzIHRoZSBgb3V0ZGlyYCBhbmQgYGNvbnRleHRgIHRvIHRoZSBgQXBwYCBjb25zdHJ1Y3RvclxuICAgKiBkaXJlY3RseSBpbiB5b3VyIGJ1aWxkZXIsIGFuZCBpbnNwZWN0IHRoZSBgZW52YCBtYXAgZGlyZWN0bHlcbiAgICogZm9yIGluZm9ybWF0aW9uIGxpa2UgdGhlIGBDREtfREVGQVVMVF9BQ0NPVU5UYCBhbmQgYENES19ERUZBVUxUX1JFR0lPTmAuXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IGN4ID0gYXdhaXQgdG9vbGtpdC5mcm9tQXNzZW1ibHlCdWlsZGVyKGFzeW5jIChwcm9wcykgPT4ge1xuICAgKiAgIC8vIEltcG9ydGFudDogcGFzcyBvbiBzeW50aGVzaXMgcGFyYW1ldGVyc1xuICAgKiAgIGNvbnN0IGFwcCA9IG5ldyBjb3JlLkFwcCh7XG4gICAqICAgICBvdXRkaXI6IHByb3BzLm91dGRpcixcbiAgICogICAgIGNvbnRleHQ6IHByb3BzLmNvbnRleHQsXG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgbmV3IE15U3RhY2soYXBwLCAnTXlTdGFjaycsIHtcbiAgICogICAgIGVudjoge1xuICAgKiAgICAgICBhY2NvdW50OiBwcm9wcy5lbnYuQ0RLX0RFRkFVTFRfQUNDT1VOVCxcbiAgICogICAgICAgcmVnaW9uOiBwcm9wcy5lbnYuQ0RLX0RFRkFVTFRfUkVHSU9OLFxuICAgKiAgICAgfSxcbiAgICogICB9KTtcbiAgICpcbiAgICogICAvLyAuLi5cbiAgICogfSwge1xuICAgKiAgIGNsb2JiZXJFbnY6IGZhbHNlLFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGNsb2JiZXJFbnY/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSBgZnJvbUNka0FwcGAgQXNzZW1ibHkgU291cmNlIGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnJvbUNka0FwcE9wdGlvbnMgZXh0ZW5kcyBBc3NlbWJseVNvdXJjZVByb3BzIHtcbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIGFwcGxpY2F0aW9uIGluIHRoaXMgd29ya2luZyBkaXJlY3RvcnkuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQ3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICAgKi9cbiAgcmVhZG9ubHkgd29ya2luZ0RpcmVjdG9yeT86IHN0cmluZztcblxuICAvKipcbiAgICogQWRkaXRpb25hbCBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICpcbiAgICogVGhlc2UgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpbGwgYmUgc2V0IGluIGFkZGl0aW9uIHRvIHRoZSBlbnZpcm9ubWVudFxuICAgKiB2YXJpYWJsZXMgY3VycmVudGx5IHNldCBpbiB0aGUgcHJvY2Vzcy4gQSB2YWx1ZSBvZiBgdW5kZWZpbmVkYCB3aWxsXG4gICAqIHVuc2V0IGEgcGFydGljdWxhciBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICovXG4gIHJlYWRvbmx5IGVudj86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD47XG59XG5cbi8qKlxuICogU2V0dGluZ3MgdGhhdCBhcmUgcGFzc2VkIHRvIGEgQ0RLIGFwcCB2aWEgdGhlIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcHBTeW50aE9wdGlvbnMge1xuICAvKipcbiAgICogRGVidWcgdGhlIENESyBhcHAuXG4gICAqIExvZ3MgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBkdXJpbmcgc3ludGhlc2lzLCBzdWNoIGFzIGNyZWF0aW9uIHN0YWNrIHRyYWNlcyBvZiB0b2tlbnMuXG4gICAqIFRoaXMgYWxzbyBzZXRzIHRoZSBgQ0RLX0RFQlVHYCBlbnYgdmFyaWFibGUgYW5kIHdpbGwgc2xvdyBkb3duIHN5bnRoZXNpcy5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGRlYnVnPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgZW1iZWRkaW5nIG9mIHRoZSBcImF3czpjZGs6cGF0aFwiIGluIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBwYXRoTWV0YWRhdGE/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhlIGNvbGxlY3Rpb24gYW5kIHJlcG9ydGluZyBvZiB2ZXJzaW9uIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uUmVwb3J0aW5nPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hlIGVuYWJsZWQsIGBhd3M6YXNzZXQ6eHh4YCBtZXRhZGF0YSBlbnRyaWVzIGFyZSBhZGRlZCB0byB0aGUgdGVtcGxhdGUuXG4gICAqXG4gICAqIERpc2FibGluZyB0aGlzIGNhbiBiZSB1c2VmdWwgaW4gY2VydGFpbiBjYXNlcyBsaWtlIGludGVncmF0aW9uIHRlc3RzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBhc3NldE1ldGFkYXRhPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRW5hYmxlIGFzc2V0IHN0YWdpbmcuXG4gICAqXG4gICAqIERpc2FibGluZyBhc3NldCBzdGFnaW5nIG1lYW5zIHRoYXQgY29weWFibGUgYXNzZXRzIHdpbGwgbm90IGJlIGNvcGllZCB0byB0aGVcbiAgICogb3V0cHV0IGRpcmVjdG9yeSBhbmQgd2lsbCBiZSByZWZlcmVuY2VkIHdpdGggYWJzb2x1dGUgcGF0aHMuXG4gICAqXG4gICAqIE5vdCBjb3BpZWQgdG8gdGhlIG91dHB1dCBkaXJlY3Rvcnk6IHRoaXMgaXMgc28gdXNlcnMgY2FuIGl0ZXJhdGUgb24gdGhlXG4gICAqIExhbWJkYSBzb3VyY2UgYW5kIHJ1biBTQU0gQ0xJIHdpdGhvdXQgaGF2aW5nIHRvIHJlLXJ1biBDREsgKG5vdGU6IHdlXG4gICAqIGNhbm5vdCBhY2hpZXZlIHRoaXMgZm9yIGJ1bmRsZWQgYXNzZXRzLCBpZiBhc3NldHMgYXJlIGJ1bmRsZWQgdGhleVxuICAgKiB3aWxsIGhhdmUgdG8gcmUtcnVuIENESyBDTEkgdG8gcmUtYnVuZGxlIHVwZGF0ZWQgdmVyc2lvbnMpLlxuICAgKlxuICAgKiBBYnNvbHV0ZSBwYXRoOiBTQU0gQ0xJIGV4cGVjdHMgYGN3ZGAtcmVsYXRpdmUgcGF0aHMgaW4gYSByZXNvdXJjZSdzXG4gICAqIGBhd3M6YXNzZXQ6cGF0aGAgbWV0YWRhdGEuIEluIG9yZGVyIHRvIGJlIHByZWRpY3RhYmxlLCB3ZSB3aWxsIGFsd2F5cyBvdXRwdXRcbiAgICogYWJzb2x1dGUgcGF0aHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGFzc2V0U3RhZ2luZz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB3aGljaCBzdGFja3Mgc2hvdWxkIGhhdmUgYXNzZXQgYnVuZGxpbmcgZW5hYmxlZFxuICAgKlxuICAgKiBAZGVmYXVsdCBbXCIqKlwiXSAtIGFsbCBzdGFja3NcbiAgICovXG4gIHJlYWRvbmx5IGJ1bmRsaW5nRm9yU3RhY2tzPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgdG8gY29uZmlndXJlIGxvYWRpbmcgb2YgdGhlIGFzc2VtYmx5IGFmdGVyIGl0IGhhcyBiZWVuIHN5bnRoZXNpemVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZEFzc2VtYmx5T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBDaGVjayB0aGUgVG9vbGtpdCBzdXBwb3J0cyB0aGUgQ2xvdWQgQXNzZW1ibHkgU2NoZW1hIHZlcnNpb25cbiAgICpcbiAgICogV2hlbiBkaXNhYmxlZCwgYWxsb3dzIHRvIFRvb2xraXQgdG8gcmVhZCBhIG5ld2VyIGNsb3VkIGFzc2VtYmx5IHRoYW4gdGhlIENYIEFQSSBpcyBkZXNpZ25lZFxuICAgKiB0byBzdXBwb3J0LiBZb3VyIGFwcGxpY2F0aW9uIG1heSBub3QgYmUgYXdhcmUgb2YgYWxsIGZlYXR1cmVzIHRoYXQgaW4gdXNlIGluIHRoZSBDbG91ZCBBc3NlbWJseS5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgY2hlY2tWZXJzaW9uPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVmFsaWRhdGUgZW51bXMgdG8gb25seSBoYXZlIGtub3duIHZhbHVlc1xuICAgKlxuICAgKiBXaGVuIGRpc2FibGVkLCB0aGUgVG9vbGtpdCBtYXkgcmVhZCBlbnVtIHZhbHVlcyBpdCBkb2Vzbid0IGtub3cgYWJvdXQgeWV0LlxuICAgKiBZb3Ugd2lsbCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXMgY2hlY2sgdGhlIHZhbHVlcyBvZiBlbnVtcyB5b3UgZW5jb3VudGVyIGluIHRoZSBtYW5pZmVzdC5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgY2hlY2tFbnVtcz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDbG91ZEFzc2VtYmx5U291cmNlQnVpbGRlciB7XG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gcHJvdmlkZSB0aGUgQ2xvdWRBc3NlbWJseVNvdXJjZUJ1aWxkZXIgd2l0aCByZXF1aXJlZCB0b29sa2l0IHNlcnZpY2VzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHNvdXJjZUJ1aWxkZXJTZXJ2aWNlcygpOiBQcm9taXNlPFRvb2xraXRTZXJ2aWNlcz47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIENsb3VkIEFzc2VtYmx5IGZyb20gYSBDbG91ZCBBc3NlbWJseSBidWlsZGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAjIyBPdXRkaXJcbiAgICpcbiAgICogSWYgbm8gb3V0cHV0IGRpcmVjdG9yeSBpcyBnaXZlbiwgaXQgd2lsbCBzeW50aGVzaXplIGludG8gYSB0ZW1wb3Jhcnkgc3lzdGVtXG4gICAqIGRpcmVjdG9yeS4gVGhlIHRlbXBvcmFyeSBkaXJlY3Rvcnkgd2lsbCBiZSBjbGVhbmVkIHVwLCB1bmxlc3NcbiAgICogYGRpc3Bvc2VPdXRkaXI6IGZhbHNlYC5cbiAgICpcbiAgICogQSB3cml0ZSBsb2NrIHdpbGwgYmUgYWNxdWlyZWQgb24gdGhlIG91dHB1dCBkaXJlY3RvcnkgZm9yIHRoZSBkdXJhdGlvbiBvZlxuICAgKiB0aGUgQ0RLIGFwcCBzeW50aGVzaXMgKHdoaWNoIG1lYW5zIHRoYXQgbm8gdHdvIGFwcHMgY2FuIHN5bnRoZXNpemUgYXQgdGhlXG4gICAqIHNhbWUgdGltZSksIGFuZCBhZnRlciBzeW50aGVzaXMgYSByZWFkIGxvY2sgd2lsbCBiZSBhY3F1aXJlZCBvbiB0aGVcbiAgICogZGlyZWN0b3J5LiBUaGlzIG1lYW5zIHRoYXQgd2hpbGUgdGhlIENsb3VkQXNzZW1ibHkgaXMgYmVpbmcgdXNlZCwgbm8gQ0RLXG4gICAqIGFwcCBzeW50aGVzaXMgY2FuIHRha2UgcGxhY2UgaW50byB0aGF0IGRpcmVjdG9yeS5cbiAgICpcbiAgICogIyMgQ29udGV4dFxuICAgKlxuICAgKiBJZiBubyBgY29udGV4dFN0b3JlYCBpcyBnaXZlbiwgYSBgTWVtb3J5Q29udGV4dGAgd2lsbCBiZSB1c2VkLiBUaGlzIG1lYW5zXG4gICAqIG5vIHByb3ZpZGVyIGxvb2t1cHMgd2lsbCBiZSBwZXJzaXN0ZWQgYW55d2hlcmUgYnkgZGVmYXVsdC4gVXNlIGEgZGlmZmVyZW50XG4gICAqIHR5cGUgb2YgY29udGV4dCBzdG9yZSBpZiB5b3Ugd2FudCBwZXJzaXN0ZW5jZSBiZXR3ZWVuIHN5bnRoIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBidWlsZGVyIC0gdGhlIGJ1aWxkZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHByb3BzIC0gYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXNcbiAgICogQHJldHVybnMgdGhlIENsb3VkQXNzZW1ibHkgc291cmNlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZnJvbUFzc2VtYmx5QnVpbGRlcihcbiAgICBidWlsZGVyOiBBc3NlbWJseUJ1aWxkZXIsXG4gICAgcHJvcHM6IEZyb21Bc3NlbWJseUJ1aWxkZXJPcHRpb25zID0ge30sXG4gICk6IFByb21pc2U8SUNsb3VkQXNzZW1ibHlTb3VyY2U+IHtcbiAgICBjb25zdCBzZXJ2aWNlcyA9IGF3YWl0IHRoaXMuc291cmNlQnVpbGRlclNlcnZpY2VzKCk7XG4gICAgY29uc3QgY29udGV4dFN0b3JlID0gcHJvcHMuY29udGV4dFN0b3JlID8/IG5ldyBNZW1vcnlDb250ZXh0KCk7XG4gICAgY29uc3QgY29udGV4dEFzc2VtYmx5UHJvcHM6IENvbnRleHRBd2FyZUNsb3VkQXNzZW1ibHlQcm9wcyA9IHtcbiAgICAgIHNlcnZpY2VzLFxuICAgICAgY29udGV4dFN0b3JlLFxuICAgICAgbG9va3VwczogcHJvcHMubG9va3VwcyxcbiAgICB9O1xuXG4gICAgY29uc3Qgb3V0ZGlyID0gcHJvcHMub3V0ZGlyID8gcGF0aC5yZXNvbHZlKHByb3BzLm91dGRpcikgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gbmV3IENvbnRleHRBd2FyZUNsb3VkQXNzZW1ibHlTb3VyY2UoXG4gICAgICB7XG4gICAgICAgIHByb2R1Y2U6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCB1c2luZyBleGVjdXRpb24gPSBhd2FpdCBFeGVjdXRpb25FbnZpcm9ubWVudC5jcmVhdGUoc2VydmljZXMsIHtcbiAgICAgICAgICAgIG91dGRpcixcbiAgICAgICAgICAgIHJlc29sdmVEZWZhdWx0QXBwRW52OiBwcm9wcy5yZXNvbHZlRGVmYXVsdEVudmlyb25tZW50ID8/IHRydWUsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCBzeW50aFBhcmFtcyA9IHBhcmFtZXRlcnNGcm9tU3ludGhPcHRpb25zKHByb3BzLnN5bnRoT3B0aW9ucyk7XG5cbiAgICAgICAgICBjb25zdCBmdWxsQ29udGV4dCA9IHtcbiAgICAgICAgICAgIC4uLmF3YWl0IGNvbnRleHRTdG9yZS5yZWFkKCksXG4gICAgICAgICAgICAuLi5zeW50aFBhcmFtcy5jb250ZXh0LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBhd2FpdCBzZXJ2aWNlcy5pb0hlbHBlci5kZWZhdWx0cy5kZWJ1Zyhmb3JtYXQoJ2NvbnRleHQ6JywgZnVsbENvbnRleHQpKTtcblxuICAgICAgICAgIGNvbnN0IGVudiA9IG5vVW5kZWZpbmVkKHtcbiAgICAgICAgICAgIC8vIFZlcnNpb25pbmcsIG91dGRpciwgZGVmYXVsdCBhY2NvdW50IGFuZCByZWdpb25cbiAgICAgICAgICAgIC4uLmF3YWl0IGV4ZWN1dGlvbi5kZWZhdWx0RW52VmFycygpLFxuICAgICAgICAgICAgLy8gRW52aXJvbm1lbnQgdmFyaWFibGVzIGRlcml2ZWQgZnJvbSBzZXR0aW5nc1xuICAgICAgICAgICAgLi4uc3ludGhQYXJhbXMuZW52LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgY2xlYW51cENvbnRleHRUZW1wID0gd3JpdGVDb250ZXh0VG9FbnYoZW52LCBmdWxsQ29udGV4dCwgJ2Vudi1pcy1jb21wbGV0ZScpO1xuICAgICAgICAgIHVzaW5nIF9jbGVhbnVwRW52ID0gKHByb3BzLmNsb2JiZXJFbnYgPz8gdHJ1ZSkgPyB0ZW1wb3JhcmlseVdyaXRlRW52KGVudikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgbGV0IGFzc2VtYmx5O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlbWJseSA9IGF3YWl0IGJ1aWxkZXIoe1xuICAgICAgICAgICAgICBvdXRkaXI6IGV4ZWN1dGlvbi5vdXRkaXIsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IGZ1bGxDb250ZXh0LFxuICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgICAgICAgICAgLy8gcmUtdGhyb3cgdG9vbGtpdCBlcnJvcnMgdW5jaGFuZ2VkXG4gICAgICAgICAgICBpZiAoVG9vbGtpdEVycm9yLmlzVG9vbGtpdEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgd3JhcCBpbnRvIGFuIGFzc2VtYmx5IGVycm9yXG4gICAgICAgICAgICB0aHJvdyBBc3NlbWJseUVycm9yLndpdGhDYXVzZSgnQXNzZW1ibHkgYnVpbGRlciBmYWlsZWQnLCBlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IGNsZWFudXBDb250ZXh0VGVtcCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbnZlcnQgd2hhdCB3ZSBnb3QgdG8gdGhlIGRlZmluaXRlbHkgY29ycmVjdCB0eXBlIHdlJ3JlIGV4cGVjdGluZywgYSBjeGFwaS5DbG91ZEFzc2VtYmx5XG4gICAgICAgICAgY29uc3QgYXNtID0gY3hhcGkuQ2xvdWRBc3NlbWJseS5pc0Nsb3VkQXNzZW1ibHkoYXNzZW1ibHkpXG4gICAgICAgICAgICA/IGFzc2VtYmx5XG4gICAgICAgICAgICA6IGF3YWl0IGFzc2VtYmx5RnJvbURpcmVjdG9yeShhc3NlbWJseS5kaXJlY3RvcnksIHNlcnZpY2VzLmlvSGVscGVyLCBwcm9wcy5sb2FkQXNzZW1ibHlPcHRpb25zKTtcblxuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBleGVjdXRpb24ubWFya1N1Y2Nlc3NmdWwoKTtcbiAgICAgICAgICBjb25zdCBkZWxldGVPbkRpc3Bvc2UgPSBwcm9wcy5kaXNwb3NlT3V0ZGlyID8/IGV4ZWN1dGlvbi5zaG91bGREaXNwb3NlT3V0RGlyO1xuICAgICAgICAgIHJldHVybiBuZXcgUmVhZGFibGVDbG91ZEFzc2VtYmx5KGFzbSwgc3VjY2Vzcy5yZWFkTG9jaywgeyBkZWxldGVPbkRpc3Bvc2UgfSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgY29udGV4dEFzc2VtYmx5UHJvcHMsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ2xvdWQgQXNzZW1ibHkgZnJvbSBhbiBleGlzdGluZyBhc3NlbWJseSBkaXJlY3RvcnkuXG4gICAqXG4gICAqIEEgcmVhZCBsb2NrIHdpbGwgYmUgYWNxdWlyZWQgZm9yIHRoZSBkaXJlY3RvcnkuIFRoaXMgbWVhbnMgdGhhdCB3aGlsZVxuICAgKiB0aGUgQ2xvdWRBc3NlbWJseSBpcyBiZWluZyB1c2VkLCBubyBDREsgYXBwIHN5bnRoZXNpcyBjYW4gdGFrZSBwbGFjZSBpbnRvXG4gICAqIHRoYXQgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0gZGlyZWN0b3J5IC0gZGlyZWN0b3J5IHRoZSBkaXJlY3Rvcnkgb2YgYSBhbHJlYWR5IHByb2R1Y2VkIENsb3VkIEFzc2VtYmx5LlxuICAgKiBAcmV0dXJucyB0aGUgQ2xvdWRBc3NlbWJseSBzb3VyY2VcbiAgICovXG4gIHB1YmxpYyBhc3luYyBmcm9tQXNzZW1ibHlEaXJlY3RvcnkoZGlyZWN0b3J5OiBzdHJpbmcsIHByb3BzOiBBc3NlbWJseURpcmVjdG9yeVByb3BzID0ge30pOiBQcm9taXNlPElDbG91ZEFzc2VtYmx5U291cmNlPiB7XG4gICAgY29uc3Qgc2VydmljZXM6IFRvb2xraXRTZXJ2aWNlcyA9IGF3YWl0IHRoaXMuc291cmNlQnVpbGRlclNlcnZpY2VzKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgcHJvZHVjZSgpIHtcbiAgICAgICAgYXdhaXQgc2VydmljZXMuaW9IZWxwZXIubm90aWZ5KElPLkNES19BU1NFTUJMWV9JMDE1MC5tc2coJy0tYXBwIHBvaW50cyB0byBhIGNsb3VkIGFzc2VtYmx5LCBzbyB3ZSBieXBhc3Mgc3ludGgnKSk7XG4gICAgICAgIGNvbnN0IHJlYWRMb2NrID0gYXdhaXQgbmV3IFJXTG9jayhkaXJlY3RvcnkpLmFjcXVpcmVSZWFkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYXNtID0gYXdhaXQgYXNzZW1ibHlGcm9tRGlyZWN0b3J5KGRpcmVjdG9yeSwgc2VydmljZXMuaW9IZWxwZXIsIHByb3BzLmxvYWRBc3NlbWJseU9wdGlvbnMpO1xuICAgICAgICAgIGNvbnN0IGFzc2VtYmx5ID0gbmV3IFJlYWRhYmxlQ2xvdWRBc3NlbWJseShhc20sIHJlYWRMb2NrLCB7IGRlbGV0ZU9uRGlzcG9zZTogZmFsc2UgfSk7XG4gICAgICAgICAgaWYgKGFzc2VtYmx5LmNsb3VkQXNzZW1ibHkubWFuaWZlc3QubWlzc2luZyAmJiBhc3NlbWJseS5jbG91ZEFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmZhaWxPbk1pc3NpbmdDb250ZXh0ID8/IHRydWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ0tleXNTZXQgPSBtaXNzaW5nQ29udGV4dEtleXMoYXNzZW1ibHkuY2xvdWRBc3NlbWJseS5tYW5pZmVzdC5taXNzaW5nKTtcbiAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ0tleXMgPSBBcnJheS5mcm9tKG1pc3NpbmdLZXlzU2V0KTtcbiAgICAgICAgICAgICAgdGhyb3cgQXNzZW1ibHlFcnJvci53aXRoQ2F1c2UoXG4gICAgICAgICAgICAgICAgJ0Fzc2VtYmx5IGNvbnRhaW5zIG1pc3NpbmcgY29udGV4dC4gJyArXG4gICAgICAgICAgICAgICAgICBcIk1ha2Ugc3VyZSBhbGwgbmVjZXNzYXJ5IGNvbnRleHQgaXMgYWxyZWFkeSBpbiAnY2RrLmNvbnRleHQuanNvbicgYnkgcnVubmluZyAnY2RrIHN5bnRoJyBvbiBhIG1hY2hpbmUgd2l0aCBzdWZmaWNpZW50IEFXUyBjcmVkZW50aWFscyBhbmQgY29tbWl0dGluZyB0aGUgcmVzdWx0LiBcIiArXG4gICAgICAgICAgICAgICAgICBgTWlzc2luZyBjb250ZXh0IGtleXM6ICcke21pc3NpbmdLZXlzLmpvaW4oJywgJyl9J2AsXG4gICAgICAgICAgICAgICAgJ0Vycm9yIHByb2R1Y2luZyBhc3NlbWJseScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQ2FjaGVkQ2xvdWRBc3NlbWJseShhc3NlbWJseSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBhd2FpdCByZWFkTG9jay5yZWxlYXNlKCk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVc2UgYSBkaXJlY3RvcnkgY29udGFpbmluZyBhbiBBV1MgQ0RLIGFwcCBhcyBzb3VyY2UuXG4gICAqXG4gICAqIFRoZSBzdWJwcm9jZXNzIHdpbGwgZXhlY3V0ZSBpbiBgd29ya2luZ0RpcmVjdG9yeWAsIHdoaWNoIGRlZmF1bHRzIHRvXG4gICAqIHRoZSBjdXJyZW50IHByb2Nlc3MnIHdvcmtpbmcgZGlyZWN0b3J5IGlmIG5vdCBnaXZlbi5cbiAgICpcbiAgICogIyMgT3V0ZGlyXG4gICAqXG4gICAqIElmIGFuIG91dHB1dCBkaXJlY3RvcnkgaXMgc3VwcGxpZWQsIHJlbGF0aXZlIHBhdGhzIGFyZSBldmFsdWF0ZWQgd2l0aFxuICAgKiByZXNwZWN0IHRvIHRoZSBjdXJyZW50IHByb2Nlc3MnIHdvcmtpbmcgZGlyZWN0b3J5LiBJZiBhbiBvdXRwdXQgZGlyZWN0b3J5XG4gICAqIGlzIG5vdCBzdXBwbGllZCwgdGhlIGRlZmF1bHQgaXMgYSBgY2RrLm91dGAgZGlyZWN0b3J5IHVuZGVybmVhdGhcbiAgICogYHdvcmtpbmdEaXJlY3RvcnlgLiBUaGUgb3V0cHV0IGRpcmVjdG9yeSB3aWxsIG5vdCBiZSBjbGVhbmVkIHVwIHVubGVzc1xuICAgKiBgZGlzcG9zZU91dGRpcjogdHJ1ZWAuXG4gICAqXG4gICAqIEEgd3JpdGUgbG9jayB3aWxsIGJlIGFjcXVpcmVkIG9uIHRoZSBvdXRwdXQgZGlyZWN0b3J5IGZvciB0aGUgZHVyYXRpb24gb2ZcbiAgICogdGhlIENESyBhcHAgc3ludGhlc2lzICh3aGljaCBtZWFucyB0aGF0IG5vIHR3byBhcHBzIGNhbiBzeW50aGVzaXplIGF0IHRoZVxuICAgKiBzYW1lIHRpbWUpLCBhbmQgYWZ0ZXIgc3ludGhlc2lzIGEgcmVhZCBsb2NrIHdpbGwgYmUgYWNxdWlyZWQgb24gdGhlXG4gICAqIGRpcmVjdG9yeS4gIFRoaXMgbWVhbnMgdGhhdCB3aGlsZSB0aGUgQ2xvdWRBc3NlbWJseSBpcyBiZWluZyB1c2VkLCBubyBDREtcbiAgICogYXBwIHN5bnRoZXNpcyBjYW4gdGFrZSBwbGFjZSBpbnRvIHRoYXQgZGlyZWN0b3J5LlxuICAgKlxuICAgKiAjIyBDb250ZXh0XG4gICAqXG4gICAqIElmIG5vIGBjb250ZXh0U3RvcmVgIGlzIGdpdmVuLCBhIGBDZGtBcHBNdWx0aUNvbnRleHRgIHdpbGwgYmUgdXNlZCwgaW5pdGlhbGl6ZWRcbiAgICogdG8gdGhlIGFwcCdzIGB3b3JraW5nRGlyZWN0b3J5YC4gVGhpcyBtZWFucyB0aGF0IGNvbnRleHQgd2lsbCBiZSBsb2FkZWQgZnJvbVxuICAgKiBhbGwgdGhlIENESydzIGRlZmF1bHQgY29udGV4dCBzb3VyY2VzLCBhbmQgdXBkYXRlcyB3aWxsIGJlIHdyaXR0ZW4gdG9cbiAgICogYGNkay5jb250ZXh0Lmpzb25gLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgLSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllc1xuICAgKiBAcmV0dXJucyB0aGUgQ2xvdWRBc3NlbWJseSBzb3VyY2VcbiAgICovXG4gIHB1YmxpYyBhc3luYyBmcm9tQ2RrQXBwKGFwcDogc3RyaW5nLCBwcm9wczogRnJvbUNka0FwcE9wdGlvbnMgPSB7fSk6IFByb21pc2U8SUNsb3VkQXNzZW1ibHlTb3VyY2U+IHtcbiAgICBjb25zdCBzZXJ2aWNlczogVG9vbGtpdFNlcnZpY2VzID0gYXdhaXQgdGhpcy5zb3VyY2VCdWlsZGVyU2VydmljZXMoKTtcbiAgICBjb25zdCB3b3JraW5nRGlyZWN0b3J5ID0gcHJvcHMud29ya2luZ0RpcmVjdG9yeSA/PyBwcm9jZXNzLmN3ZCgpO1xuICAgIGNvbnN0IG91dGRpciA9IHByb3BzLm91dGRpciA/IHBhdGgucmVzb2x2ZShwcm9wcy5vdXRkaXIpIDogcGF0aC5yZXNvbHZlKHdvcmtpbmdEaXJlY3RvcnksICdjZGsub3V0Jyk7XG5cbiAgICBjb25zdCBjb250ZXh0U3RvcmUgPSBwcm9wcy5jb250ZXh0U3RvcmUgPz8gbmV3IENka0FwcE11bHRpQ29udGV4dCh3b3JraW5nRGlyZWN0b3J5KTtcblxuICAgIGNvbnN0IGNvbnRleHRBc3NlbWJseVByb3BzOiBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5UHJvcHMgPSB7XG4gICAgICBzZXJ2aWNlcyxcbiAgICAgIGNvbnRleHRTdG9yZSxcbiAgICAgIGxvb2t1cHM6IHByb3BzLmxvb2t1cHMsXG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgQ29udGV4dEF3YXJlQ2xvdWRBc3NlbWJseVNvdXJjZShcbiAgICAgIHtcbiAgICAgICAgcHJvZHVjZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmcy5ta2RpcnBTeW5jKG91dGRpcik7XG4gICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBDb3VsZCBub3QgY3JlYXRlIG91dHB1dCBkaXJlY3RvcnkgYXQgJyR7b3V0ZGlyfScgKCR7ZS5tZXNzYWdlfSkuYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdXNpbmcgZXhlY3V0aW9uID0gYXdhaXQgRXhlY3V0aW9uRW52aXJvbm1lbnQuY3JlYXRlKHNlcnZpY2VzLCB7XG4gICAgICAgICAgICBvdXRkaXIsXG4gICAgICAgICAgICByZXNvbHZlRGVmYXVsdEFwcEVudjogcHJvcHMucmVzb2x2ZURlZmF1bHRFbnZpcm9ubWVudCA/PyB0cnVlLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgY29tbWFuZExpbmUgPSBhd2FpdCBleGVjdXRpb24uZ3Vlc3NFeGVjdXRhYmxlKGFwcCk7XG5cbiAgICAgICAgICBjb25zdCBzeW50aFBhcmFtcyA9IHBhcmFtZXRlcnNGcm9tU3ludGhPcHRpb25zKHByb3BzLnN5bnRoT3B0aW9ucyk7XG5cbiAgICAgICAgICBjb25zdCBmdWxsQ29udGV4dCA9IHtcbiAgICAgICAgICAgIC4uLmF3YWl0IGNvbnRleHRTdG9yZS5yZWFkKCksXG4gICAgICAgICAgICAuLi5zeW50aFBhcmFtcy5jb250ZXh0LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBhd2FpdCBzZXJ2aWNlcy5pb0hlbHBlci5kZWZhdWx0cy5kZWJ1Zyhmb3JtYXQoJ2NvbnRleHQ6JywgZnVsbENvbnRleHQpKTtcblxuICAgICAgICAgIGNvbnN0IGVudiA9IG5vVW5kZWZpbmVkKHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gc3RhcnQgd2l0aCBmdWxsIGVudiBvZiBgd3JpdGVDb250ZXh0VG9FbnZgIHdpbGwgbm90IGJlIGFibGUgdG8gZG8gdGhlIHNpemVcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0aW9uIGNvcnJlY3RseS5cbiAgICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAgICAgLy8gVXNlciBnYXZlIHVzIHNvbWV0aGluZ1xuICAgICAgICAgICAgLi4ucHJvcHMuZW52LFxuICAgICAgICAgICAgLy8gVmVyc2lvbmluZywgb3V0ZGlyLCBkZWZhdWx0IGFjY291bnQgYW5kIHJlZ2lvblxuICAgICAgICAgICAgLi4uYXdhaXQgZXhlY3V0aW9uLmRlZmF1bHRFbnZWYXJzKCksXG4gICAgICAgICAgICAvLyBFbnZpcm9ubWVudCB2YXJpYWJsZXMgZGVyaXZlZCBmcm9tIHNldHRpbmdzXG4gICAgICAgICAgICAuLi5zeW50aFBhcmFtcy5lbnYsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgY2xlYW51cFRlbXAgPSB3cml0ZUNvbnRleHRUb0VudihlbnYsIGZ1bGxDb250ZXh0LCAnZW52LWlzLWNvbXBsZXRlJyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGV4ZWNJbkNoaWxkUHJvY2Vzcyhjb21tYW5kTGluZS5qb2luKCcgJyksIHtcbiAgICAgICAgICAgICAgZXZlbnRQdWJsaXNoZXI6IGFzeW5jICh0eXBlLCBsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdkYXRhX3N0ZG91dCc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlcnZpY2VzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfSTEwMDEubXNnKGxpbmUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdkYXRhX3N0ZGVycic6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlcnZpY2VzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfRTEwMDIubXNnKGxpbmUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgIGN3ZDogd29ya2luZ0RpcmVjdG9yeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBjbGVhbnVwVGVtcCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGFzbSA9IGF3YWl0IGFzc2VtYmx5RnJvbURpcmVjdG9yeShvdXRkaXIsIHNlcnZpY2VzLmlvSGVscGVyLCBwcm9wcy5sb2FkQXNzZW1ibHlPcHRpb25zKTtcblxuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBleGVjdXRpb24ubWFya1N1Y2Nlc3NmdWwoKTtcbiAgICAgICAgICBjb25zdCBkZWxldGVPbkRpc3Bvc2UgPSBwcm9wcy5kaXNwb3NlT3V0ZGlyID8/IGV4ZWN1dGlvbi5zaG91bGREaXNwb3NlT3V0RGlyO1xuICAgICAgICAgIHJldHVybiBuZXcgUmVhZGFibGVDbG91ZEFzc2VtYmx5KGFzbSwgc3VjY2Vzcy5yZWFkTG9jaywgeyBkZWxldGVPbkRpc3Bvc2UgfSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgY29udGV4dEFzc2VtYmx5UHJvcHMsXG4gICAgKTtcbiAgfVxufVxuXG4iXX0=