"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionEnvironment = void 0;
exports.writeContextToEnv = writeContextToEnv;
exports.frameworkSupportsContextOverflow = frameworkSupportsContextOverflow;
exports.assemblyFromDirectory = assemblyFromDirectory;
exports.settingsFromSynthOptions = settingsFromSynthOptions;
exports.parametersFromSynthOptions = parametersFromSynthOptions;
require("../../../private/dispose-polyfill");
const os = require("node:os");
const path = require("node:path");
const node_util_1 = require("node:util");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const semver_1 = require("semver");
const toolkit_error_1 = require("../../../toolkit/toolkit-error");
const util_1 = require("../../../util");
const private_1 = require("../../io/private");
const rwlock_1 = require("../../rwlock");
const settings_1 = require("../../settings");
const tree_1 = require("../../tree");
const environment_1 = require("../environment");
class ExecutionEnvironment {
    /**
     * Create an ExecutionEnvironment
     *
     * An ExecutionEnvironment holds a writer lock on the given directory which will
     * be cleaned up when the object is disposed.
     *
     * A temporary directory will be created if none is supplied, which will be cleaned
     * up when this object is disposed.
     *
     * If `markSuccessful()` is called, the writer lock is converted to a reader lock
     * and temporary directories will not be cleaned up anymore.
     */
    static async create(services, options) {
        let outDirIsTemporary = false;
        let dir = options.outdir;
        if (!dir) {
            outDirIsTemporary = true;
            dir = fs.mkdtempSync(path.join(fs.realpathSync(os.tmpdir()), 'cdk.out'));
        }
        const lock = await new rwlock_1.RWLock(dir).acquireWrite();
        const opts = {
            outdir: dir,
            resolveDefaultAppEnv: options.resolveDefaultAppEnv,
        };
        return new ExecutionEnvironment(services, opts, {
            lock,
            outDirIsTemporary,
        });
    }
    /**
     * Should the outdir be disposed of.
     */
    get shouldDisposeOutDir() {
        return this.shouldClean;
    }
    /**
     * The directory the cloud assembly will be written to.
     */
    outdir;
    options;
    ioHelper;
    sdkProvider;
    debugFn;
    lock;
    shouldClean;
    constructor(services, options, { lock, outDirIsTemporary }) {
        this.ioHelper = services.ioHelper;
        this.sdkProvider = services.sdkProvider;
        this.debugFn = (msg) => this.ioHelper.defaults.debug(msg);
        this.lock = lock;
        this.shouldClean = outDirIsTemporary;
        this.outdir = options.outdir;
        this.options = options;
    }
    async [Symbol.asyncDispose]() {
        await this.lock?.release();
        if (this.shouldDisposeOutDir) {
            await fs.rm(this.outdir, { recursive: true, force: true });
        }
    }
    /**
     * Mark the execution as successful, which stops the writer lock from being released upon disposal
     */
    async markSuccessful() {
        if (!this.lock) {
            throw new TypeError('Cannot mark successful more than once');
        }
        const readLock = await this.lock.convertToReaderLock();
        this.lock = undefined;
        this.shouldClean = false;
        return { readLock };
    }
    /**
     * Begin an execution in this environment
     *
     * This will acquire a write lock on the given environment. The write lock
     * will be released automatically when the return object is disposed, unless it
     * is converted to a reader lock.
     */
    async beginExecution() {
        const lock = await new rwlock_1.RWLock(this.outdir).acquireWrite();
        let converted = false;
        return {
            async writeToReadLock() {
                converted = true;
                return lock.convertToReaderLock();
            },
            [Symbol.asyncDispose]: async () => {
                // Release if not converted
                if (!converted) {
                    await lock.release();
                }
            },
        };
    }
    /**
     * Guess the executable from the command-line argument
     *
     * Only do this if the file is NOT marked as executable. If it is,
     * we'll defer to the shebang inside the file itself.
     *
     * If we're on Windows, we ALWAYS take the handler, since it's hard to
     * verify if registry associations have or have not been set up for this
     * file type, so we'll assume the worst and take control.
     */
    guessExecutable(app) {
        return (0, environment_1.guessExecutable)(app, this.debugFn);
    }
    /**
     * If we don't have region/account defined in context, we fall back to the default SDK behavior
     * where region is retrieved from ~/.aws/config and account is based on default credentials provider
     * chain and then STS is queried.
     *
     * This is done opportunistically: for example, if we can't access STS for some reason or the region
     * is not configured, the context value will be 'null' and there could failures down the line. In
     * some cases, synthesis does not require region/account information at all, so that might be perfectly
     * fine in certain scenarios.
     */
    async defaultEnvVars() {
        const debugFn = (msg) => this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0010.msg(msg));
        const env = this.options.resolveDefaultAppEnv ? await (0, environment_1.prepareDefaultEnvironment)(this.sdkProvider, debugFn) : {};
        env[cxapi.OUTDIR_ENV] = this.outdir;
        await debugFn((0, node_util_1.format)('outdir:', this.outdir));
        // CLI version information
        env[cxapi.CLI_ASM_VERSION_ENV] = cxschema.Manifest.version();
        env[cxapi.CLI_VERSION_ENV] = (0, util_1.versionNumber)();
        await debugFn((0, node_util_1.format)('env:', env));
        return env;
    }
    /**
     * Run code from a different working directory
     */
    async changeDir(block, workingDir) {
        const originalWorkingDir = process.cwd();
        try {
            if (workingDir) {
                process.chdir(workingDir);
            }
            return await block();
        }
        finally {
            if (workingDir) {
                process.chdir(originalWorkingDir);
            }
        }
    }
}
exports.ExecutionEnvironment = ExecutionEnvironment;
/**
 * Serializes the given context to a set if environment variables environment variables
 *
 * Needs to know the size of the rest of the env because that's necessary to do
 * an overflow computation on Windows. This function will mutate the given
 * environment in-place. It should be called as the very last operation on the
 * environment, because afterwards is might be at the maximum size.
 *
 * This *would* have returned an `IAsyncDisposable` but that requires messing
 * with TypeScript type definitions to use it in aws-cdk, so returning an
 * explicit cleanup function is easier.
 *
 * `completeness` indicates whether this `env` block represents the full `env`
 * that will be passed to a subprocess, or whether it will be mixed into
 * `process.env` later.
 */
function writeContextToEnv(env, context, completeness) {
    let contextOverflowLocation = null;
    // On Windows, all envvars together must fit in a 32k block (<https://devblogs.microsoft.com/oldnewthing/20100203-00>)
    // On Linux, a single entry may not exceed 131k; but we're treating it as all together because that's safe
    // and it's a single execution path for both platforms.
    const envVariableSizeLimit = os.platform() === 'win32' ? 32760 : 131072;
    const completeEnv = { ...completeness === 'add-process-env-later' ? process.env : {}, ...env };
    const [smallContext, overflow] = (0, util_1.splitBySize)(context, (0, environment_1.spaceAvailableForContext)(completeEnv, envVariableSizeLimit));
    // Store the safe part in the environment variable
    env[cxapi.CONTEXT_ENV] = JSON.stringify(smallContext);
    // If there was any overflow, write it to a temporary file
    if (Object.keys(overflow ?? {}).length > 0) {
        const contextDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cdk-context'));
        contextOverflowLocation = path.join(contextDir, 'context-overflow.json');
        fs.writeJSONSync(contextOverflowLocation, overflow);
        env[cxapi.CONTEXT_OVERFLOW_LOCATION_ENV] = contextOverflowLocation;
    }
    return async () => {
        if (contextOverflowLocation) {
            await fs.promises.rm(path.dirname(contextOverflowLocation), { recursive: true, force: true });
        }
    };
}
/**
 * Checks if a given assembly supports context overflow, warn otherwise.
 *
 * @param assembly - the assembly to check
 */
async function checkContextOverflowSupport(assembly, ioHelper) {
    const traceFn = (msg) => ioHelper.defaults.trace(msg);
    const tree = await (0, tree_1.loadTree)(assembly, traceFn);
    // We're dealing with an old version of the framework here. It is unaware of the temporary
    // file, which means that it will ignore the context overflow.
    if (!frameworkSupportsContextOverflow(tree)) {
        await ioHelper.notify(private_1.IO.CDK_ASSEMBLY_W0010.msg('Part of the context could not be sent to the application. Please update the AWS CDK library to the latest version.'));
    }
}
/**
 * Checks if the framework supports context overflow
 */
function frameworkSupportsContextOverflow(tree) {
    return !(0, tree_1.some)(tree, node => {
        const fqn = node.constructInfo?.fqn;
        const version = node.constructInfo?.version;
        return (fqn === 'aws-cdk-lib.App' // v2 app
            && version !== '0.0.0' // ignore developer builds
            && version != null && (0, semver_1.lte)(version, '2.38.0') // last version not supporting large context
        ) // v2
            || fqn === '@aws-cdk/core.App'; // v1 app => not supported
    });
}
/**
 * Safely create an assembly from a cloud assembly directory
 */
async function assemblyFromDirectory(assemblyDir, ioHelper, loadOptions = {}) {
    try {
        const assembly = new cxapi.CloudAssembly(assemblyDir, {
            skipVersionCheck: !(loadOptions.checkVersion ?? true),
            skipEnumCheck: !(loadOptions.checkEnums ?? true),
            // We sort as we deploy
            topoSort: false,
        });
        await checkContextOverflowSupport(assembly, ioHelper);
        return assembly;
    }
    catch (err) {
        if (err.message.includes(cxschema.VERSION_MISMATCH)) {
            // this means the CLI version is too old.
            // we instruct the user to upgrade.
            const message = 'This AWS CDK Toolkit is not compatible with the AWS CDK library used by your application. Please upgrade to the latest version.';
            await ioHelper.notify(private_1.IO.CDK_ASSEMBLY_E1111.msg(message, { error: err }));
            throw new toolkit_error_1.ToolkitError(`${message}\n(${err.message}`);
        }
        throw err;
    }
}
function settingsFromSynthOptions(synthOpts = {}) {
    return new settings_1.Settings({
        debug: false,
        pathMetadata: true,
        versionReporting: true,
        assetMetadata: true,
        assetStaging: true,
        ...synthOpts,
    }, true);
}
/**
 * Turn synthesis options into context/environment variables that will go to the CDK app
 *
 * These are parameters that control the synthesis operation, configurable by the user
 * from the outside of the app.
 */
function parametersFromSynthOptions(synthOptions) {
    return (0, environment_1.synthParametersFromSettings)(settingsFromSynthOptions(synthOptions ?? {}));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlcGFyZS1zb3VyY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwcmVwYXJlLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFvT0EsOENBMkJDO0FBcUJELDRFQVdDO0FBS0Qsc0RBb0JDO0FBRUQsNERBU0M7QUFRRCxnRUFFQztBQTdVRCw2Q0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyx5Q0FBbUM7QUFDbkMsMkRBQTJEO0FBQzNELHlDQUF5QztBQUN6QywrQkFBK0I7QUFDL0IsbUNBQTZCO0FBRTdCLGtFQUE4RDtBQUM5RCx3Q0FBMkQ7QUFHM0QsOENBQXNDO0FBRXRDLHlDQUFzQztBQUN0Qyw2Q0FBMEM7QUFFMUMscUNBQTRDO0FBRTVDLGdEQUFtSTtBQW1CbkksTUFBYSxvQkFBb0I7SUFDL0I7Ozs7Ozs7Ozs7O09BV0c7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUF5QixFQUFFLE9BQW9DO1FBQ3hGLElBQUksaUJBQWlCLEdBQUcsS0FBSyxDQUFDO1FBQzlCLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFDekIsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ1QsaUJBQWlCLEdBQUcsSUFBSSxDQUFDO1lBQ3pCLEdBQUcsR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQzNFLENBQUM7UUFDRCxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksZUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDO1FBRWxELE1BQU0sSUFBSSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxvQkFBb0IsRUFBRSxPQUFPLENBQUMsb0JBQW9CO1NBQ25ELENBQUM7UUFFRixPQUFPLElBQUks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QUNsSixNQUFNLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzFFLE1BQU0sSUFBSSw0QkFBWSxDQUFDLEdBQUcsT0FBTyxNQUFNLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ3hELENBQUM7UUFDRCxNQUFNLEdBQUcsQ0FBQztJQUNaLENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBZ0Isd0JBQXdCLENBQUMsWUFBNkIsRUFBRTtJQUN0RSxPQUFPLElBQUksbUJBQVEsQ0FBQztRQUNsQixLQUFLLEVBQUUsS0FBSztRQUNaLFlBQVksRUFBRSxJQUFJO1FBQ2xCLGdCQUFnQixFQUFFLElBQUk7UUFDdEIsYUFBYSxFQUFFLElBQUk7UUFDbkIsWUFBWSxFQUFFLElBQUk7UUFDbEIsR0FBRyxTQUFTO0tBQ2IsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLDBCQUEwQixDQUFDLFlBQThCO0lBQ3ZFLE9BQU8sSUFBQSx5Q0FBMkIsRUFBQyx3QkFBd0IsQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNuRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuLi8uLi8uLi9wcml2YXRlL2Rpc3Bvc2UtcG9seWZpbGwnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnbm9kZTpvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdub2RlOnV0aWwnO1xuaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBsdGUgfSBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHR5cGUgeyBUb29sa2l0U2VydmljZXMgfSBmcm9tICcuLi8uLi8uLi90b29sa2l0L3ByaXZhdGUnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vdG9vbGtpdC90b29sa2l0LWVycm9yJztcbmltcG9ydCB7IHNwbGl0QnlTaXplLCB2ZXJzaW9uTnVtYmVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgdHlwZSB7IFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vLi4vYXdzLWF1dGgvcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IElvSGVscGVyIH0gZnJvbSAnLi4vLi4vaW8vcHJpdmF0ZSc7XG5pbXBvcnQgeyBJTyB9IGZyb20gJy4uLy4uL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBJUmVhZExvY2ssIElXcml0ZUxvY2sgfSBmcm9tICcuLi8uLi9yd2xvY2snO1xuaW1wb3J0IHsgUldMb2NrIH0gZnJvbSAnLi4vLi4vcndsb2NrJztcbmltcG9ydCB7IFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vc2V0dGluZ3MnO1xuaW1wb3J0IHR5cGUgeyBDb25zdHJ1Y3RUcmVlTm9kZSB9IGZyb20gJy4uLy4uL3RyZWUnO1xuaW1wb3J0IHsgbG9hZFRyZWUsIHNvbWUgfSBmcm9tICcuLi8uLi90cmVlJztcbmltcG9ydCB0eXBlIHsgQ29udGV4dCwgRW52IH0gZnJvbSAnLi4vZW52aXJvbm1lbnQnO1xuaW1wb3J0IHsgcHJlcGFyZURlZmF1bHRFbnZpcm9ubWVudCwgc3BhY2VBdmFpbGFibGVGb3JDb250ZXh0LCBndWVzc0V4ZWN1dGFibGUsIHN5bnRoUGFyYW1ldGVyc0Zyb21TZXR0aW5ncyB9IGZyb20gJy4uL2Vudmlyb25tZW50JztcbmltcG9ydCB0eXBlIHsgQXBwU3ludGhPcHRpb25zLCBMb2FkQXNzZW1ibHlPcHRpb25zIH0gZnJvbSAnLi4vc291cmNlLWJ1aWxkZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGlvbkVudmlyb25tZW50T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgZGlyZWN0b3J5IHRoZSBjbG91ZCBhc3NlbWJseSB3aWxsIGJlIHdyaXR0ZW4gdG8uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gdXNlIGEgdGVtcG9yYXJ5IGRpcmVjdG9yeSBhcyBvdXRwdXQgZGlyZWN0b3J5LCB0aGlzIHdpbGwgYmUgY2xlYW5lZCB1cCB3aGVuIHRoaXMgb2JqZWN0IGlzIGRpc3Bvc2VkXG4gICAqL1xuICByZWFkb25seSBvdXRkaXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgYW5kIGFkZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIHRoZSBhcHAncyBkZWZhdWx0IGVudmlyb25tZW50LlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbWFrZSBhIGNhbGwgdG8gU1RTLCB3aGljaCBpcyBub3QgYWx3YXlzIGRlc2lyYWJsZSBlLmcuIGlmIHRoZSBlbnYgaXMgZXhwbGljaXRseSBzcGVjaWZpZWQuXG4gICAqL1xuICByZWFkb25seSByZXNvbHZlRGVmYXVsdEFwcEVudjogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIEV4ZWN1dGlvbkVudmlyb25tZW50IGltcGxlbWVudHMgQXN5bmNEaXNwb3NhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBFeGVjdXRpb25FbnZpcm9ubWVudFxuICAgKlxuICAgKiBBbiBFeGVjdXRpb25FbnZpcm9ubWVudCBob2xkcyBhIHdyaXRlciBsb2NrIG9uIHRoZSBnaXZlbiBkaXJlY3Rvcnkgd2hpY2ggd2lsbFxuICAgKiBiZSBjbGVhbmVkIHVwIHdoZW4gdGhlIG9iamVjdCBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogQSB0ZW1wb3JhcnkgZGlyZWN0b3J5IHdpbGwgYmUgY3JlYXRlZCBpZiBub25lIGlzIHN1cHBsaWVkLCB3aGljaCB3aWxsIGJlIGNsZWFuZWRcbiAgICogdXAgd2hlbiB0aGlzIG9iamVjdCBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogSWYgYG1hcmtTdWNjZXNzZnVsKClgIGlzIGNhbGxlZCwgdGhlIHdyaXRlciBsb2NrIGlzIGNvbnZlcnRlZCB0byBhIHJlYWRlciBsb2NrXG4gICAqIGFuZCB0ZW1wb3JhcnkgZGlyZWN0b3JpZXMgd2lsbCBub3QgYmUgY2xlYW5lZCB1cCBhbnltb3JlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBjcmVhdGUoc2VydmljZXM6IFRvb2xraXRTZXJ2aWNlcywgb3B0aW9uczogRXhlY3V0aW9uRW52aXJvbm1lbnRPcHRpb25zKSB7XG4gICAgbGV0IG91dERpcklzVGVtcG9yYXJ5ID0gZmFsc2U7XG4gICAgbGV0IGRpciA9IG9wdGlvbnMub3V0ZGlyO1xuICAgIGlmICghZGlyKSB7XG4gICAgICBvdXREaXJJc1RlbXBvcmFyeSA9IHRydWU7XG4gICAgICBkaXIgPSBmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4oZnMucmVhbHBhdGhTeW5jKG9zLnRtcGRpcigpKSwgJ2Nkay5vdXQnKSk7XG4gICAgfVxuICAgIGNvbnN0IGxvY2sgPSBhd2FpdCBuZXcgUldMb2NrKGRpcikuYWNxdWlyZVdyaXRlKCk7XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgb3V0ZGlyOiBkaXIsXG4gICAgICByZXNvbHZlRGVmYXVsdEFwcEVudjogb3B0aW9ucy5yZXNvbHZlRGVmYXVsdEFwcEVudixcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBFeGVjdXRpb25FbnZpcm9ubWVudChzZXJ2aWNlcywgb3B0cywge1xuICAgICAgbG9jayxcbiAgICAgIG91dERpcklzVGVtcG9yYXJ5LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3VsZCB0aGUgb3V0ZGlyIGJlIGRpc3Bvc2VkIG9mLlxuICAgKi9cbiAgcHVibGljIGdldCBzaG91bGREaXNwb3NlT3V0RGlyKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnNob3VsZENsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RvcnkgdGhlIGNsb3VkIGFzc2VtYmx5IHdpbGwgYmUgd3JpdHRlbiB0by5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBvdXRkaXI6IHN0cmluZztcblxuICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFJlcXVpcmVkPEV4ZWN1dGlvbkVudmlyb25tZW50T3B0aW9ucz47XG4gIHByaXZhdGUgcmVhZG9ubHkgaW9IZWxwZXI6IElvSGVscGVyO1xuICBwcml2YXRlIHJlYWRvbmx5IHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBkZWJ1Z0ZuOiAobXNnOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIHByaXZhdGUgbG9jazogSVdyaXRlTG9jayB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBzaG91bGRDbGVhbjogYm9vbGVhbjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHNlcnZpY2VzOiBUb29sa2l0U2VydmljZXMsXG4gICAgb3B0aW9uczogUmVxdWlyZWQ8RXhlY3V0aW9uRW52aXJvbm1lbnRPcHRpb25zPixcbiAgICB7IGxvY2ssIG91dERpcklzVGVtcG9yYXJ5IH06IHtcbiAgICAgIHJlYWRvbmx5IG91dERpcklzVGVtcG9yYXJ5OiBib29sZWFuO1xuICAgICAgcmVhZG9ubHkgbG9jazogSVdyaXRlTG9jaztcbiAgICB9LFxuICApIHtcbiAgICB0aGlzLmlvSGVscGVyID0gc2VydmljZXMuaW9IZWxwZXI7XG4gICAgdGhpcy5zZGtQcm92aWRlciA9IHNlcnZpY2VzLnNka1Byb3ZpZGVyO1xuICAgIHRoaXMuZGVidWdGbiA9IChtc2c6IHN0cmluZykgPT4gdGhpcy5pb0hlbHBlci5kZWZhdWx0cy5kZWJ1Zyhtc2cpO1xuICAgIHRoaXMubG9jayA9IGxvY2s7XG4gICAgdGhpcy5zaG91bGRDbGVhbiA9IG91dERpcklzVGVtcG9yYXJ5O1xuICAgIHRoaXMub3V0ZGlyID0gb3B0aW9ucy5vdXRkaXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBbU3ltYm9sLmFzeW5jRGlzcG9zZV0oKSB7XG4gICAgYXdhaXQgdGhpcy5sb2NrPy5yZWxlYXNlKCk7XG5cbiAgICBpZiAodGhpcy5zaG91bGREaXNwb3NlT3V0RGlyKSB7XG4gICAgICBhd2FpdCBmcy5ybSh0aGlzLm91dGRpciwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIHRoZSBleGVjdXRpb24gYXMgc3VjY2Vzc2Z1bCwgd2hpY2ggc3RvcHMgdGhlIHdyaXRlciBsb2NrIGZyb20gYmVpbmcgcmVsZWFzZWQgdXBvbiBkaXNwb3NhbFxuICAgKi9cbiAgcHVibGljIGFzeW5jIG1hcmtTdWNjZXNzZnVsKCkge1xuICAgIGlmICghdGhpcy5sb2NrKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgbWFyayBzdWNjZXNzZnVsIG1vcmUgdGhhbiBvbmNlJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRMb2NrID0gYXdhaXQgdGhpcy5sb2NrLmNvbnZlcnRUb1JlYWRlckxvY2soKTtcbiAgICB0aGlzLmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zaG91bGRDbGVhbiA9IGZhbHNlO1xuICAgIHJldHVybiB7IHJlYWRMb2NrIH07XG4gIH1cblxuICAvKipcbiAgICogQmVnaW4gYW4gZXhlY3V0aW9uIGluIHRoaXMgZW52aXJvbm1lbnRcbiAgICpcbiAgICogVGhpcyB3aWxsIGFjcXVpcmUgYSB3cml0ZSBsb2NrIG9uIHRoZSBnaXZlbiBlbnZpcm9ubWVudC4gVGhlIHdyaXRlIGxvY2tcbiAgICogd2lsbCBiZSByZWxlYXNlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHJldHVybiBvYmplY3QgaXMgZGlzcG9zZWQsIHVubGVzcyBpdFxuICAgKiBpcyBjb252ZXJ0ZWQgdG8gYSByZWFkZXIgbG9jay5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBiZWdpbkV4ZWN1dGlvbigpOiBQcm9taXNlPHsgd3JpdGVUb1JlYWRMb2NrKCk6IFByb21pc2U8SVJlYWRMb2NrPiB9ICYgQXN5bmNEaXNwb3NhYmxlPiB7XG4gICAgY29uc3QgbG9jayA9IGF3YWl0IG5ldyBSV0xvY2sodGhpcy5vdXRkaXIpLmFjcXVpcmVXcml0ZSgpO1xuXG4gICAgbGV0IGNvbnZlcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyB3cml0ZVRvUmVhZExvY2soKSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBsb2NrLmNvbnZlcnRUb1JlYWRlckxvY2soKTtcbiAgICAgIH0sXG4gICAgICBbU3ltYm9sLmFzeW5jRGlzcG9zZV06IGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gUmVsZWFzZSBpZiBub3QgY29udmVydGVkXG4gICAgICAgIGlmICghY29udmVydGVkKSB7XG4gICAgICAgICAgYXdhaXQgbG9jay5yZWxlYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHdWVzcyB0aGUgZXhlY3V0YWJsZSBmcm9tIHRoZSBjb21tYW5kLWxpbmUgYXJndW1lbnRcbiAgICpcbiAgICogT25seSBkbyB0aGlzIGlmIHRoZSBmaWxlIGlzIE5PVCBtYXJrZWQgYXMgZXhlY3V0YWJsZS4gSWYgaXQgaXMsXG4gICAqIHdlJ2xsIGRlZmVyIHRvIHRoZSBzaGViYW5nIGluc2lkZSB0aGUgZmlsZSBpdHNlbGYuXG4gICAqXG4gICAqIElmIHdlJ3JlIG9uIFdpbmRvd3MsIHdlIEFMV0FZUyB0YWtlIHRoZSBoYW5kbGVyLCBzaW5jZSBpdCdzIGhhcmQgdG9cbiAgICogdmVyaWZ5IGlmIHJlZ2lzdHJ5IGFzc29jaWF0aW9ucyBoYXZlIG9yIGhhdmUgbm90IGJlZW4gc2V0IHVwIGZvciB0aGlzXG4gICAqIGZpbGUgdHlwZSwgc28gd2UnbGwgYXNzdW1lIHRoZSB3b3JzdCBhbmQgdGFrZSBjb250cm9sLlxuICAgKi9cbiAgcHVibGljIGd1ZXNzRXhlY3V0YWJsZShhcHA6IHN0cmluZykge1xuICAgIHJldHVybiBndWVzc0V4ZWN1dGFibGUoYXBwLCB0aGlzLmRlYnVnRm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlIGRvbid0IGhhdmUgcmVnaW9uL2FjY291bnQgZGVmaW5lZCBpbiBjb250ZXh0LCB3ZSBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgU0RLIGJlaGF2aW9yXG4gICAqIHdoZXJlIHJlZ2lvbiBpcyByZXRyaWV2ZWQgZnJvbSB+Ly5hd3MvY29uZmlnIGFuZCBhY2NvdW50IGlzIGJhc2VkIG9uIGRlZmF1bHQgY3JlZGVudGlhbHMgcHJvdmlkZXJcbiAgICogY2hhaW4gYW5kIHRoZW4gU1RTIGlzIHF1ZXJpZWQuXG4gICAqXG4gICAqIFRoaXMgaXMgZG9uZSBvcHBvcnR1bmlzdGljYWxseTogZm9yIGV4YW1wbGUsIGlmIHdlIGNhbid0IGFjY2VzcyBTVFMgZm9yIHNvbWUgcmVhc29uIG9yIHRoZSByZWdpb25cbiAgICogaXMgbm90IGNvbmZpZ3VyZWQsIHRoZSBjb250ZXh0IHZhbHVlIHdpbGwgYmUgJ251bGwnIGFuZCB0aGVyZSBjb3VsZCBmYWlsdXJlcyBkb3duIHRoZSBsaW5lLiBJblxuICAgKiBzb21lIGNhc2VzLCBzeW50aGVzaXMgZG9lcyBub3QgcmVxdWlyZSByZWdpb24vYWNjb3VudCBpbmZvcm1hdGlvbiBhdCBhbGwsIHNvIHRoYXQgbWlnaHQgYmUgcGVyZmVjdGx5XG4gICAqIGZpbmUgaW4gY2VydGFpbiBzY2VuYXJpb3MuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVmYXVsdEVudlZhcnMoKTogUHJvbWlzZTxFbnY+IHtcbiAgICBjb25zdCBkZWJ1Z0ZuID0gKG1zZzogc3RyaW5nKSA9PiB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfSTAwMTAubXNnKG1zZykpO1xuICAgIGNvbnN0IGVudiA9IHRoaXMub3B0aW9ucy5yZXNvbHZlRGVmYXVsdEFwcEVudiA/IGF3YWl0IHByZXBhcmVEZWZhdWx0RW52aXJvbm1lbnQodGhpcy5zZGtQcm92aWRlciwgZGVidWdGbikgOiB7fTtcblxuICAgIGVudltjeGFwaS5PVVRESVJfRU5WXSA9IHRoaXMub3V0ZGlyO1xuICAgIGF3YWl0IGRlYnVnRm4oZm9ybWF0KCdvdXRkaXI6JywgdGhpcy5vdXRkaXIpKTtcblxuICAgIC8vIENMSSB2ZXJzaW9uIGluZm9ybWF0aW9uXG4gICAgZW52W2N4YXBpLkNMSV9BU01fVkVSU0lPTl9FTlZdID0gY3hzY2hlbWEuTWFuaWZlc3QudmVyc2lvbigpO1xuICAgIGVudltjeGFwaS5DTElfVkVSU0lPTl9FTlZdID0gdmVyc2lvbk51bWJlcigpO1xuXG4gICAgYXdhaXQgZGVidWdGbihmb3JtYXQoJ2VudjonLCBlbnYpKTtcbiAgICByZXR1cm4gZW52O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBjb2RlIGZyb20gYSBkaWZmZXJlbnQgd29ya2luZyBkaXJlY3RvcnlcbiAgICovXG4gIHB1YmxpYyBhc3luYyBjaGFuZ2VEaXI8VD4oYmxvY2s6ICgpID0+IFByb21pc2U8VD4sIHdvcmtpbmdEaXI/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBvcmlnaW5hbFdvcmtpbmdEaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAod29ya2luZ0Rpcikge1xuICAgICAgICBwcm9jZXNzLmNoZGlyKHdvcmtpbmdEaXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgYmxvY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHdvcmtpbmdEaXIpIHtcbiAgICAgICAgcHJvY2Vzcy5jaGRpcihvcmlnaW5hbFdvcmtpbmdEaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIGNvbnRleHQgdG8gYSBzZXQgaWYgZW52aXJvbm1lbnQgdmFyaWFibGVzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICpcbiAqIE5lZWRzIHRvIGtub3cgdGhlIHNpemUgb2YgdGhlIHJlc3Qgb2YgdGhlIGVudiBiZWNhdXNlIHRoYXQncyBuZWNlc3NhcnkgdG8gZG9cbiAqIGFuIG92ZXJmbG93IGNvbXB1dGF0aW9uIG9uIFdpbmRvd3MuIFRoaXMgZnVuY3Rpb24gd2lsbCBtdXRhdGUgdGhlIGdpdmVuXG4gKiBlbnZpcm9ubWVudCBpbi1wbGFjZS4gSXQgc2hvdWxkIGJlIGNhbGxlZCBhcyB0aGUgdmVyeSBsYXN0IG9wZXJhdGlvbiBvbiB0aGVcbiAqIGVudmlyb25tZW50LCBiZWNhdXNlIGFmdGVyd2FyZHMgaXMgbWlnaHQgYmUgYXQgdGhlIG1heGltdW0gc2l6ZS5cbiAqXG4gKiBUaGlzICp3b3VsZCogaGF2ZSByZXR1cm5lZCBhbiBgSUFzeW5jRGlzcG9zYWJsZWAgYnV0IHRoYXQgcmVxdWlyZXMgbWVzc2luZ1xuICogd2l0aCBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgdG8gdXNlIGl0IGluIGF3cy1jZGssIHNvIHJldHVybmluZyBhblxuICogZXhwbGljaXQgY2xlYW51cCBmdW5jdGlvbiBpcyBlYXNpZXIuXG4gKlxuICogYGNvbXBsZXRlbmVzc2AgaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBgZW52YCBibG9jayByZXByZXNlbnRzIHRoZSBmdWxsIGBlbnZgXG4gKiB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIGEgc3VicHJvY2Vzcywgb3Igd2hldGhlciBpdCB3aWxsIGJlIG1peGVkIGludG9cbiAqIGBwcm9jZXNzLmVudmAgbGF0ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUNvbnRleHRUb0VudihlbnY6IEVudiwgY29udGV4dDogQ29udGV4dCwgY29tcGxldGVuZXNzOiAnYWRkLXByb2Nlc3MtZW52LWxhdGVyJyB8ICdlbnYtaXMtY29tcGxldGUnKSB7XG4gIGxldCBjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbiA9IG51bGw7XG5cbiAgLy8gT24gV2luZG93cywgYWxsIGVudnZhcnMgdG9nZXRoZXIgbXVzdCBmaXQgaW4gYSAzMmsgYmxvY2sgKDxodHRwczovL2RldmJsb2dzLm1pY3Jvc29mdC5jb20vb2xkbmV3dGhpbmcvMjAxMDAyMDMtMDA+KVxuICAvLyBPbiBMaW51eCwgYSBzaW5nbGUgZW50cnkgbWF5IG5vdCBleGNlZWQgMTMxazsgYnV0IHdlJ3JlIHRyZWF0aW5nIGl0IGFzIGFsbCB0b2dldGhlciBiZWNhdXNlIHRoYXQncyBzYWZlXG4gIC8vIGFuZCBpdCdzIGEgc2luZ2xlIGV4ZWN1dGlvbiBwYXRoIGZvciBib3RoIHBsYXRmb3Jtcy5cbiAgY29uc3QgZW52VmFyaWFibGVTaXplTGltaXQgPSBvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInID8gMzI3NjAgOiAxMzEwNzI7XG5cbiAgY29uc3QgY29tcGxldGVFbnYgPSB7IC4uLmNvbXBsZXRlbmVzcyA9PT0gJ2FkZC1wcm9jZXNzLWVudi1sYXRlcicgPyBwcm9jZXNzLmVudiA6IHt9LCAuLi5lbnYgfTtcbiAgY29uc3QgW3NtYWxsQ29udGV4dCwgb3ZlcmZsb3ddID0gc3BsaXRCeVNpemUoY29udGV4dCwgc3BhY2VBdmFpbGFibGVGb3JDb250ZXh0KGNvbXBsZXRlRW52LCBlbnZWYXJpYWJsZVNpemVMaW1pdCkpO1xuXG4gIC8vIFN0b3JlIHRoZSBzYWZlIHBhcnQgaW4gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlXG4gIGVudltjeGFwaS5DT05URVhUX0VOVl0gPSBKU09OLnN0cmluZ2lmeShzbWFsbENvbnRleHQpO1xuXG4gIC8vIElmIHRoZXJlIHdhcyBhbnkgb3ZlcmZsb3csIHdyaXRlIGl0IHRvIGEgdGVtcG9yYXJ5IGZpbGVcbiAgaWYgKE9iamVjdC5rZXlzKG92ZXJmbG93ID8/IHt9KS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY29udGV4dERpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nkay1jb250ZXh0JykpO1xuICAgIGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uID0gcGF0aC5qb2luKGNvbnRleHREaXIsICdjb250ZXh0LW92ZXJmbG93Lmpzb24nKTtcbiAgICBmcy53cml0ZUpTT05TeW5jKGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uLCBvdmVyZmxvdyk7XG4gICAgZW52W2N4YXBpLkNPTlRFWFRfT1ZFUkZMT1dfTE9DQVRJT05fRU5WXSA9IGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBpZiAoY29udGV4dE92ZXJmbG93TG9jYXRpb24pIHtcbiAgICAgIGF3YWl0IGZzLnByb21pc2VzLnJtKHBhdGguZGlybmFtZShjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbiksIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYXNzZW1ibHkgc3VwcG9ydHMgY29udGV4dCBvdmVyZmxvdywgd2FybiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIGFzc2VtYmx5IC0gdGhlIGFzc2VtYmx5IHRvIGNoZWNrXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQ29udGV4dE92ZXJmbG93U3VwcG9ydChhc3NlbWJseTogY3hhcGkuQ2xvdWRBc3NlbWJseSwgaW9IZWxwZXI6IElvSGVscGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHRyYWNlRm4gPSAobXNnOiBzdHJpbmcpID0+IGlvSGVscGVyLmRlZmF1bHRzLnRyYWNlKG1zZyk7XG4gIGNvbnN0IHRyZWUgPSBhd2FpdCBsb2FkVHJlZShhc3NlbWJseSwgdHJhY2VGbik7XG5cbiAgLy8gV2UncmUgZGVhbGluZyB3aXRoIGFuIG9sZCB2ZXJzaW9uIG9mIHRoZSBmcmFtZXdvcmsgaGVyZS4gSXQgaXMgdW5hd2FyZSBvZiB0aGUgdGVtcG9yYXJ5XG4gIC8vIGZpbGUsIHdoaWNoIG1lYW5zIHRoYXQgaXQgd2lsbCBpZ25vcmUgdGhlIGNvbnRleHQgb3ZlcmZsb3cuXG4gIGlmICghZnJhbWV3b3JrU3VwcG9ydHNDb250ZXh0T3ZlcmZsb3codHJlZSkpIHtcbiAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX0FTU0VNQkxZX1cwMDEwLm1zZygnUGFydCBvZiB0aGUgY29udGV4dCBjb3VsZCBub3QgYmUgc2VudCB0byB0aGUgYXBwbGljYXRpb24uIFBsZWFzZSB1cGRhdGUgdGhlIEFXUyBDREsgbGlicmFyeSB0byB0aGUgbGF0ZXN0IHZlcnNpb24uJykpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBmcmFtZXdvcmsgc3VwcG9ydHMgY29udGV4dCBvdmVyZmxvd1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJhbWV3b3JrU3VwcG9ydHNDb250ZXh0T3ZlcmZsb3codHJlZTogQ29uc3RydWN0VHJlZU5vZGUgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgcmV0dXJuICFzb21lKHRyZWUsIG5vZGUgPT4ge1xuICAgIGNvbnN0IGZxbiA9IG5vZGUuY29uc3RydWN0SW5mbz8uZnFuO1xuICAgIGNvbnN0IHZlcnNpb24gPSBub2RlLmNvbnN0cnVjdEluZm8/LnZlcnNpb247XG4gICAgcmV0dXJuIChcbiAgICAgIGZxbiA9PT0gJ2F3cy1jZGstbGliLkFwcCcgLy8gdjIgYXBwXG4gICAgICAmJiB2ZXJzaW9uICE9PSAnMC4wLjAnIC8vIGlnbm9yZSBkZXZlbG9wZXIgYnVpbGRzXG4gICAgICAmJiB2ZXJzaW9uICE9IG51bGwgJiYgbHRlKHZlcnNpb24sICcyLjM4LjAnKSAvLyBsYXN0IHZlcnNpb24gbm90IHN1cHBvcnRpbmcgbGFyZ2UgY29udGV4dFxuICAgICkgLy8gdjJcbiAgICB8fCBmcW4gPT09ICdAYXdzLWNkay9jb3JlLkFwcCc7IC8vIHYxIGFwcCA9PiBub3Qgc3VwcG9ydGVkXG4gIH0pO1xufVxuXG4vKipcbiAqIFNhZmVseSBjcmVhdGUgYW4gYXNzZW1ibHkgZnJvbSBhIGNsb3VkIGFzc2VtYmx5IGRpcmVjdG9yeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXNzZW1ibHlGcm9tRGlyZWN0b3J5KGFzc2VtYmx5RGlyOiBzdHJpbmcsIGlvSGVscGVyOiBJb0hlbHBlciwgbG9hZE9wdGlvbnM6IExvYWRBc3NlbWJseU9wdGlvbnMgPSB7fSkge1xuICB0cnkge1xuICAgIGNvbnN0IGFzc2VtYmx5ID0gbmV3IGN4YXBpLkNsb3VkQXNzZW1ibHkoYXNzZW1ibHlEaXIsIHtcbiAgICAgIHNraXBWZXJzaW9uQ2hlY2s6ICEobG9hZE9wdGlvbnMuY2hlY2tWZXJzaW9uID8/IHRydWUpLFxuICAgICAgc2tpcEVudW1DaGVjazogIShsb2FkT3B0aW9ucy5jaGVja0VudW1zID8/IHRydWUpLFxuICAgICAgLy8gV2Ugc29ydCBhcyB3ZSBkZXBsb3lcbiAgICAgIHRvcG9Tb3J0OiBmYWxzZSxcbiAgICB9KTtcbiAgICBhd2FpdCBjaGVja0NvbnRleHRPdmVyZmxvd1N1cHBvcnQoYXNzZW1ibHksIGlvSGVscGVyKTtcbiAgICByZXR1cm4gYXNzZW1ibHk7XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKGN4c2NoZW1hLlZFUlNJT05fTUlTTUFUQ0gpKSB7XG4gICAgICAvLyB0aGlzIG1lYW5zIHRoZSBDTEkgdmVyc2lvbiBpcyB0b28gb2xkLlxuICAgICAgLy8gd2UgaW5zdHJ1Y3QgdGhlIHVzZXIgdG8gdXBncmFkZS5cbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnVGhpcyBBV1MgQ0RLIFRvb2xraXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgQVdTIENESyBsaWJyYXJ5IHVzZWQgYnkgeW91ciBhcHBsaWNhdGlvbi4gUGxlYXNlIHVwZ3JhZGUgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLic7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX0FTU0VNQkxZX0UxMTExLm1zZyhtZXNzYWdlLCB7IGVycm9yOiBlcnIgfSkpO1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgJHttZXNzYWdlfVxcbigke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHRpbmdzRnJvbVN5bnRoT3B0aW9ucyhzeW50aE9wdHM6IEFwcFN5bnRoT3B0aW9ucyA9IHt9KTogU2V0dGluZ3Mge1xuICByZXR1cm4gbmV3IFNldHRpbmdzKHtcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgcGF0aE1ldGFkYXRhOiB0cnVlLFxuICAgIHZlcnNpb25SZXBvcnRpbmc6IHRydWUsXG4gICAgYXNzZXRNZXRhZGF0YTogdHJ1ZSxcbiAgICBhc3NldFN0YWdpbmc6IHRydWUsXG4gICAgLi4uc3ludGhPcHRzLFxuICB9LCB0cnVlKTtcbn1cblxuLyoqXG4gKiBUdXJuIHN5bnRoZXNpcyBvcHRpb25zIGludG8gY29udGV4dC9lbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCB3aWxsIGdvIHRvIHRoZSBDREsgYXBwXG4gKlxuICogVGhlc2UgYXJlIHBhcmFtZXRlcnMgdGhhdCBjb250cm9sIHRoZSBzeW50aGVzaXMgb3BlcmF0aW9uLCBjb25maWd1cmFibGUgYnkgdGhlIHVzZXJcbiAqIGZyb20gdGhlIG91dHNpZGUgb2YgdGhlIGFwcC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcmFtZXRlcnNGcm9tU3ludGhPcHRpb25zKHN5bnRoT3B0aW9ucz86IEFwcFN5bnRoT3B0aW9ucykge1xuICByZXR1cm4gc3ludGhQYXJhbWV0ZXJzRnJvbVNldHRpbmdzKHNldHRpbmdzRnJvbVN5bnRoT3B0aW9ucyhzeW50aE9wdGlvbnMgPz8ge30pKTtcbn1cbiJdfQ==