"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextAwareCloudAssemblySource = void 0;
const contextproviders = require("../../../context-providers");
const toolkit_error_1 = require("../../../toolkit/toolkit-error");
const private_1 = require("../../io/private");
const helpers_1 = require("./helpers");
const sets_1 = require("../../../util/sets");
/**
 * A CloudAssemblySource that wraps another CloudAssemblySource and runs a lookup loop on it
 *
 * This means that if the underlying CloudAssemblySource produces a manifest
 * with provider queries in it, the `ContextAwareCloudAssemblySource` will
 * perform the necessary context lookups and invoke the underlying
 * `CloudAssemblySource` again with thew missing context information.
 *
 * This is only useful if the underlying `CloudAssemblySource` can respond to
 * this new context information (it must be a CDK app source); if it is just a
 * static directory, then the contents of the assembly won't change in response
 * to context.
 *
 * The context is passed between `ContextAwareCloudAssemblySource` and the wrapped
 * cloud assembly source via a contex file on disk, so the wrapped assembly source
 * should re-read the context file on every invocation.
 */
class ContextAwareCloudAssemblySource {
    source;
    props;
    canLookup;
    context;
    ioHelper;
    constructor(source, props) {
        this.source = source;
        this.props = props;
        this.canLookup = props.lookups ?? true;
        this.context = props.contextStore;
        this.ioHelper = props.services.ioHelper;
    }
    /**
     * Produce a Cloud Assembly, i.e. a set of stacks
     */
    async produce() {
        // We may need to run the cloud assembly source multiple times in order to satisfy all missing context
        // (When the source producer runs, it will tell us about context it wants to use
        // but it missing. We'll then look up the context and run the executable again, and
        // again, until it doesn't complain anymore or we've stopped making progress).
        let previouslyMissingKeys;
        while (true) {
            const readableAsm = await this.source.produce();
            const assembly = readableAsm.cloudAssembly;
            if (assembly.manifest.missing && assembly.manifest.missing.length > 0) {
                const missingKeysSet = (0, helpers_1.missingContextKeys)(assembly.manifest.missing);
                const missingKeys = Array.from(missingKeysSet);
                if (!this.canLookup) {
                    throw new toolkit_error_1.ToolkitError('Context lookups have been disabled. '
                        + 'Make sure all necessary context is already in \'cdk.context.json\' by running \'cdk synth\' on a machine with sufficient AWS credentials and committing the result. '
                        + `Missing context keys: '${missingKeys.join(', ')}'`);
                }
                let tryLookup = true;
                if (previouslyMissingKeys && (0, sets_1.equalSets)(missingKeysSet, previouslyMissingKeys)) {
                    await this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0240.msg('Not making progress trying to resolve environmental context. Giving up.', { missingKeys }));
                    tryLookup = false;
                }
                previouslyMissingKeys = missingKeysSet;
                if (tryLookup) {
                    await this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0241.msg('Some context information is missing. Fetching...', { missingKeys }));
                    const contextUpdates = await contextproviders.provideContextValues(assembly.manifest.missing, this.props.services.sdkProvider, this.props.services.pluginHost, this.ioHelper);
                    await this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0042.msg('Writing context updates...', {
                        context: contextUpdates,
                    }));
                    await this.context.update(contextUpdates);
                    // Execute again. Unlock the assembly here so that the producer can acquire
                    // a read lock on the directory again.
                    await readableAsm._unlock();
                    continue;
                }
            }
            return readableAsm;
        }
    }
}
exports.ContextAwareCloudAssemblySource = ContextAwareCloudAssemblySource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC1hd2FyZS1zb3VyY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb250ZXh0LWF3YXJlLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrREFBK0Q7QUFFL0Qsa0VBQThEO0FBRTlELDhDQUFzQztBQUd0Qyx1Q0FBK0M7QUFDL0MsNkNBQStDO0FBd0IvQzs7Ozs7Ozs7Ozs7Ozs7OztHQWdCRztBQUNILE1BQWEsK0JBQStCO0lBS2I7SUFBK0M7SUFKcEUsU0FBUyxDQUFVO0lBQ25CLE9BQU8sQ0FBZ0I7SUFDdkIsUUFBUSxDQUFXO0lBRTNCLFlBQTZCLE1BQTRCLEVBQW1CLEtBQXFDO1FBQXBGLFdBQU0sR0FBTixNQUFNLENBQXNCO1FBQW1CLFVBQUssR0FBTCxLQUFLLENBQWdDO1FBQy9HLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUM7UUFDdkMsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUM7SUFDMUMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLE9BQU87UUFDbEIsc0dBQXNHO1FBQ3RHLGdGQUFnRjtRQUNoRixtRkFBbUY7UUFDbkYsOEVBQThFO1FBQzlFLElBQUkscUJBQThDLENBQUM7UUFDbkQsT0FBTyxJQUFJLEVBQUUsQ0FBQztZQUNaLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUVoRCxNQUFNLFFBQVEsR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFDO1lBQzNDLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUN0RSxNQUFNLGNBQWMsR0FBRyxJQUFBLDRCQUFrQixFQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3JFLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBRS9DLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7b0JBQ3BCLE1BQU0sSUFBSSw0QkFBWSxDQUNwQixzQ0FBc0M7MEJBQ3BDLHNLQUFzSzswQkFDdEssMEJBQTBCLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRCxDQUFDO2dCQUVELElBQUksU0FBUyxHQUFHLElBQUksQ0FBQztnQkFDckIsSUFBSSxxQkFBcUIsSUFBSSxJQUFBLGdCQUFTLEVBQUMsY0FBYyxFQUFFLHFCQUFxQixDQUFDLEVBQUUsQ0FBQztvQkFDOUUsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFFLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLHlFQUF5RSxFQUFFLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUNsSixTQUFTLEdBQUcsS0FBSyxDQUFDO2dCQUNwQixDQUFDO2dCQUVELHFCQUFxQixHQUFHLGNBQWMsQ0FBQztnQkFFdkMsSUFBSSxTQUFTLEVBQUUsQ0FBQztvQkFDZCxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsa0RBQWtELEVBQUUsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQzNILE1BQU0sY0FBYyxHQUFHLE1BQU0sZ0JBQWdCLENBQUMsb0JBQW9CLENBQ2hFLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUN6QixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQy9CLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFDOUIsSUFBSSxDQUFDLFFBQVEsQ0FDZCxDQUFDO29CQUVGLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsRUFBRTt3QkFDakYsT0FBTyxFQUFFLGNBQWM7cUJBQ3hCLENBQUMsQ0FBQyxDQUFDO29CQUNKLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7b0JBRTFDLDJFQUEyRTtvQkFDM0Usc0NBQXNDO29CQUN0QyxNQUFNLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDNUIsU0FBUztnQkFDWCxDQUFDO1lBQ0gsQ0FBQztZQUVELE9BQU8sV0FBVyxDQUFDO1FBQ3JCLENBQUM7SUFDSCxDQUFDO0NBQ0Y7QUFuRUQsMEVBbUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29udGV4dHByb3ZpZGVycyBmcm9tICcuLi8uLi8uLi9jb250ZXh0LXByb3ZpZGVycyc7XG5pbXBvcnQgdHlwZSB7IFRvb2xraXRTZXJ2aWNlcyB9IGZyb20gJy4uLy4uLy4uL3Rvb2xraXQvcHJpdmF0ZSc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi8uLi90b29sa2l0L3Rvb2xraXQtZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBJb0hlbHBlciB9IGZyb20gJy4uLy4uL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHsgSU8gfSBmcm9tICcuLi8uLi9pby9wcml2YXRlJztcbmltcG9ydCB0eXBlIHsgSUNvbnRleHRTdG9yZSB9IGZyb20gJy4uL2NvbnRleHQtc3RvcmUnO1xuaW1wb3J0IHR5cGUgeyBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgSVJlYWRhYmxlQ2xvdWRBc3NlbWJseSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IG1pc3NpbmdDb250ZXh0S2V5cyB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBlcXVhbFNldHMgfSBmcm9tICcuLi8uLi8uLi91dGlsL3NldHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRleHRBd2FyZUNsb3VkQXNzZW1ibHlQcm9wcyB7XG4gIC8qKlxuICAgKiBBV1Mgb2JqZWN0ICh1c2VkIGJ5IGNvbnRleHRwcm92aWRlcilcbiAgICogQGRlcHJlY2F0ZWQgY29udGV4dCBzaG91bGQgYmUgbW92ZWQgdG8gdGhlIHRvb2xraXQgaXRzZWxmXG4gICAqL1xuICByZWFkb25seSBzZXJ2aWNlczogVG9vbGtpdFNlcnZpY2VzO1xuXG4gIC8qKlxuICAgKiBMb2NhdGlvbiB0byByZWFkIGFuZCB3cml0ZSBjb250ZXh0XG4gICAqL1xuICByZWFkb25seSBjb250ZXh0U3RvcmU6IElDb250ZXh0U3RvcmU7XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBjb250ZXh0IGxvb2t1cHMuXG4gICAqXG4gICAqIFByb2R1Y2luZyBhIGBjeGFwaS5DbG91ZEFzc2VtYmx5YCB3aWxsIGZhaWwgaWYgdGhpcyBpcyBkaXNhYmxlZCBhbmQgY29udGV4dCBsb29rdXBzIG5lZWQgdG8gYmUgcGVyZm9ybWVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBsb29rdXBzPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIENsb3VkQXNzZW1ibHlTb3VyY2UgdGhhdCB3cmFwcyBhbm90aGVyIENsb3VkQXNzZW1ibHlTb3VyY2UgYW5kIHJ1bnMgYSBsb29rdXAgbG9vcCBvbiBpdFxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgdW5kZXJseWluZyBDbG91ZEFzc2VtYmx5U291cmNlIHByb2R1Y2VzIGEgbWFuaWZlc3RcbiAqIHdpdGggcHJvdmlkZXIgcXVlcmllcyBpbiBpdCwgdGhlIGBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5U291cmNlYCB3aWxsXG4gKiBwZXJmb3JtIHRoZSBuZWNlc3NhcnkgY29udGV4dCBsb29rdXBzIGFuZCBpbnZva2UgdGhlIHVuZGVybHlpbmdcbiAqIGBDbG91ZEFzc2VtYmx5U291cmNlYCBhZ2FpbiB3aXRoIHRoZXcgbWlzc2luZyBjb250ZXh0IGluZm9ybWF0aW9uLlxuICpcbiAqIFRoaXMgaXMgb25seSB1c2VmdWwgaWYgdGhlIHVuZGVybHlpbmcgYENsb3VkQXNzZW1ibHlTb3VyY2VgIGNhbiByZXNwb25kIHRvXG4gKiB0aGlzIG5ldyBjb250ZXh0IGluZm9ybWF0aW9uIChpdCBtdXN0IGJlIGEgQ0RLIGFwcCBzb3VyY2UpOyBpZiBpdCBpcyBqdXN0IGFcbiAqIHN0YXRpYyBkaXJlY3RvcnksIHRoZW4gdGhlIGNvbnRlbnRzIG9mIHRoZSBhc3NlbWJseSB3b24ndCBjaGFuZ2UgaW4gcmVzcG9uc2VcbiAqIHRvIGNvbnRleHQuXG4gKlxuICogVGhlIGNvbnRleHQgaXMgcGFzc2VkIGJldHdlZW4gYENvbnRleHRBd2FyZUNsb3VkQXNzZW1ibHlTb3VyY2VgIGFuZCB0aGUgd3JhcHBlZFxuICogY2xvdWQgYXNzZW1ibHkgc291cmNlIHZpYSBhIGNvbnRleCBmaWxlIG9uIGRpc2ssIHNvIHRoZSB3cmFwcGVkIGFzc2VtYmx5IHNvdXJjZVxuICogc2hvdWxkIHJlLXJlYWQgdGhlIGNvbnRleHQgZmlsZSBvbiBldmVyeSBpbnZvY2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQ29udGV4dEF3YXJlQ2xvdWRBc3NlbWJseVNvdXJjZSBpbXBsZW1lbnRzIElDbG91ZEFzc2VtYmx5U291cmNlIHtcbiAgcHJpdmF0ZSBjYW5Mb29rdXA6IGJvb2xlYW47XG4gIHByaXZhdGUgY29udGV4dDogSUNvbnRleHRTdG9yZTtcbiAgcHJpdmF0ZSBpb0hlbHBlcjogSW9IZWxwZXI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBzb3VyY2U6IElDbG91ZEFzc2VtYmx5U291cmNlLCBwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5UHJvcHMpIHtcbiAgICB0aGlzLmNhbkxvb2t1cCA9IHByb3BzLmxvb2t1cHMgPz8gdHJ1ZTtcbiAgICB0aGlzLmNvbnRleHQgPSBwcm9wcy5jb250ZXh0U3RvcmU7XG4gICAgdGhpcy5pb0hlbHBlciA9IHByb3BzLnNlcnZpY2VzLmlvSGVscGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgYSBDbG91ZCBBc3NlbWJseSwgaS5lLiBhIHNldCBvZiBzdGFja3NcbiAgICovXG4gIHB1YmxpYyBhc3luYyBwcm9kdWNlKCk6IFByb21pc2U8SVJlYWRhYmxlQ2xvdWRBc3NlbWJseT4ge1xuICAgIC8vIFdlIG1heSBuZWVkIHRvIHJ1biB0aGUgY2xvdWQgYXNzZW1ibHkgc291cmNlIG11bHRpcGxlIHRpbWVzIGluIG9yZGVyIHRvIHNhdGlzZnkgYWxsIG1pc3NpbmcgY29udGV4dFxuICAgIC8vIChXaGVuIHRoZSBzb3VyY2UgcHJvZHVjZXIgcnVucywgaXQgd2lsbCB0ZWxsIHVzIGFib3V0IGNvbnRleHQgaXQgd2FudHMgdG8gdXNlXG4gICAgLy8gYnV0IGl0IG1pc3NpbmcuIFdlJ2xsIHRoZW4gbG9vayB1cCB0aGUgY29udGV4dCBhbmQgcnVuIHRoZSBleGVjdXRhYmxlIGFnYWluLCBhbmRcbiAgICAvLyBhZ2FpbiwgdW50aWwgaXQgZG9lc24ndCBjb21wbGFpbiBhbnltb3JlIG9yIHdlJ3ZlIHN0b3BwZWQgbWFraW5nIHByb2dyZXNzKS5cbiAgICBsZXQgcHJldmlvdXNseU1pc3NpbmdLZXlzOiBTZXQ8c3RyaW5nPiB8IHVuZGVmaW5lZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgcmVhZGFibGVBc20gPSBhd2FpdCB0aGlzLnNvdXJjZS5wcm9kdWNlKCk7XG5cbiAgICAgIGNvbnN0IGFzc2VtYmx5ID0gcmVhZGFibGVBc20uY2xvdWRBc3NlbWJseTtcbiAgICAgIGlmIChhc3NlbWJseS5tYW5pZmVzdC5taXNzaW5nICYmIGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBtaXNzaW5nS2V5c1NldCA9IG1pc3NpbmdDb250ZXh0S2V5cyhhc3NlbWJseS5tYW5pZmVzdC5taXNzaW5nKTtcbiAgICAgICAgY29uc3QgbWlzc2luZ0tleXMgPSBBcnJheS5mcm9tKG1pc3NpbmdLZXlzU2V0KTtcblxuICAgICAgICBpZiAoIXRoaXMuY2FuTG9va3VwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICAgICdDb250ZXh0IGxvb2t1cHMgaGF2ZSBiZWVuIGRpc2FibGVkLiAnXG4gICAgICAgICAgICArICdNYWtlIHN1cmUgYWxsIG5lY2Vzc2FyeSBjb250ZXh0IGlzIGFscmVhZHkgaW4gXFwnY2RrLmNvbnRleHQuanNvblxcJyBieSBydW5uaW5nIFxcJ2NkayBzeW50aFxcJyBvbiBhIG1hY2hpbmUgd2l0aCBzdWZmaWNpZW50IEFXUyBjcmVkZW50aWFscyBhbmQgY29tbWl0dGluZyB0aGUgcmVzdWx0LiAnXG4gICAgICAgICAgICArIGBNaXNzaW5nIGNvbnRleHQga2V5czogJyR7bWlzc2luZ0tleXMuam9pbignLCAnKX0nYCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdHJ5TG9va3VwID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByZXZpb3VzbHlNaXNzaW5nS2V5cyAmJiBlcXVhbFNldHMobWlzc2luZ0tleXNTZXQsIHByZXZpb3VzbHlNaXNzaW5nS2V5cykpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfSTAyNDAubXNnKCdOb3QgbWFraW5nIHByb2dyZXNzIHRyeWluZyB0byByZXNvbHZlIGVudmlyb25tZW50YWwgY29udGV4dC4gR2l2aW5nIHVwLicsIHsgbWlzc2luZ0tleXMgfSkpO1xuICAgICAgICAgIHRyeUxvb2t1cCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNseU1pc3NpbmdLZXlzID0gbWlzc2luZ0tleXNTZXQ7XG5cbiAgICAgICAgaWYgKHRyeUxvb2t1cCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkNES19BU1NFTUJMWV9JMDI0MS5tc2coJ1NvbWUgY29udGV4dCBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nLiBGZXRjaGluZy4uLicsIHsgbWlzc2luZ0tleXMgfSkpO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHRVcGRhdGVzID0gYXdhaXQgY29udGV4dHByb3ZpZGVycy5wcm92aWRlQ29udGV4dFZhbHVlcyhcbiAgICAgICAgICAgIGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcsXG4gICAgICAgICAgICB0aGlzLnByb3BzLnNlcnZpY2VzLnNka1Byb3ZpZGVyLFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5zZXJ2aWNlcy5wbHVnaW5Ib3N0LFxuICAgICAgICAgICAgdGhpcy5pb0hlbHBlcixcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX0FTU0VNQkxZX0kwMDQyLm1zZygnV3JpdGluZyBjb250ZXh0IHVwZGF0ZXMuLi4nLCB7XG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0VXBkYXRlcyxcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jb250ZXh0LnVwZGF0ZShjb250ZXh0VXBkYXRlcyk7XG5cbiAgICAgICAgICAvLyBFeGVjdXRlIGFnYWluLiBVbmxvY2sgdGhlIGFzc2VtYmx5IGhlcmUgc28gdGhhdCB0aGUgcHJvZHVjZXIgY2FuIGFjcXVpcmVcbiAgICAgICAgICAvLyBhIHJlYWQgbG9jayBvbiB0aGUgZGlyZWN0b3J5IGFnYWluLlxuICAgICAgICAgIGF3YWl0IHJlYWRhYmxlQXNtLl91bmxvY2soKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhZGFibGVBc207XG4gICAgfVxuICB9XG59XG4iXX0=