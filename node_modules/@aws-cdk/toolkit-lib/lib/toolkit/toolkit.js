"use strict";
var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.Toolkit = void 0;
require("../private/dispose-polyfill");
const path = require("node:path");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const chokidar = require("chokidar");
const fs = require("fs-extra");
const non_interactive_io_host_1 = require("./non-interactive-io-host");
const private_1 = require("./private");
const toolkit_error_1 = require("./toolkit-error");
const bootstrap_1 = require("../actions/bootstrap");
const deploy_1 = require("../actions/deploy");
const private_2 = require("../actions/deploy/private");
const private_3 = require("../actions/diff/private");
const private_4 = require("../actions/watch/private");
const aws_auth_1 = require("../api/aws-auth");
const awscli_compatible_1 = require("../api/aws-auth/awscli-compatible");
const private_5 = require("../api/aws-auth/private");
const bootstrap_2 = require("../api/bootstrap");
const cloud_assembly_1 = require("../api/cloud-assembly");
const private_6 = require("../api/cloud-assembly/private");
const source_builder_1 = require("../api/cloud-assembly/source-builder");
const deployments_1 = require("../api/deployments");
const diff_1 = require("../api/diff");
const drift_1 = require("../api/drift");
const drift_formatter_1 = require("../api/drift/drift-formatter");
const private_7 = require("../api/io/private");
const logs_monitor_1 = require("../api/logs-monitor");
const plugin_1 = require("../api/plugin");
const refactoring_1 = require("../api/refactoring");
const cloudformation_1 = require("../api/refactoring/cloudformation");
const context_1 = require("../api/refactoring/context");
const resource_import_1 = require("../api/resource-import");
const private_8 = require("../api/tags/private");
const toolkit_info_1 = require("../api/toolkit-info");
const work_graph_1 = require("../api/work-graph");
const payloads_1 = require("../payloads");
const util_1 = require("../util");
const concurrency_1 = require("../util/concurrency");
const promises_1 = require("../util/promises");
/**
 * The AWS CDK Programmatic Toolkit
 */
class Toolkit extends source_builder_1.CloudAssemblySourceBuilder {
    props;
    /**
     * The toolkit stack name used for bootstrapping resources.
     */
    toolkitStackName;
    /**
     * The IoHost of this Toolkit
     */
    ioHost;
    /**
     * The plugin host for loading and managing plugins
     */
    pluginHost;
    /**
     * Cache of the internal SDK Provider instance
     */
    sdkProviderCache;
    baseCredentials;
    unstableFeatures;
    constructor(props = {}) {
        super();
        this.props = props;
        this.toolkitStackName = props.toolkitStackName ?? toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        this.pluginHost = props.pluginHost ?? new plugin_1.PluginHost();
        let ioHost = props.ioHost ?? new non_interactive_io_host_1.NonInteractiveIoHost();
        if (props.emojis === false) {
            ioHost = (0, private_7.withoutEmojis)(ioHost);
        }
        if (props.color === false) {
            ioHost = (0, private_7.withoutColor)(ioHost);
        }
        // After removing emojis and color, we might end up with floating whitespace at either end of the message
        // This also removes newlines that we currently emit for CLI backwards compatibility.
        this.ioHost = (0, private_7.withTrimmedWhitespace)(ioHost);
        this.baseCredentials = props.sdkConfig?.baseCredentials ?? aws_auth_1.BaseCredentials.awsCliCompatible();
        this.unstableFeatures = props.unstableFeatures ?? [];
    }
    /**
     * Access to the AWS SDK
     * @internal
     */
    async sdkProvider(action) {
        // @todo this needs to be different instance per action
        if (!this.sdkProviderCache) {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, action);
            const clientConfig = {
                requestHandler: (0, awscli_compatible_1.sdkRequestHandler)(this.props.sdkConfig?.httpOptions?.agent),
            };
            const config = await this.baseCredentials.sdkBaseConfig(ioHelper, clientConfig);
            this.sdkProviderCache = new private_5.SdkProvider(config.credentialProvider, config.defaultRegion, {
                ioHelper,
                logger: new private_5.IoHostSdkLogger(ioHelper),
                pluginHost: this.pluginHost,
                requestHandler: clientConfig.requestHandler,
            });
        }
        return this.sdkProviderCache;
    }
    /**
     * Helper to provide the CloudAssemblySourceBuilder with required toolkit services
     * @internal
     */
    async sourceBuilderServices() {
        return {
            ioHelper: (0, private_7.asIoHelper)(this.ioHost, 'assembly'),
            sdkProvider: await this.sdkProvider('assembly'),
            pluginHost: this.pluginHost,
        };
    }
    /**
     * Bootstrap Action
     */
    async bootstrap(environments, options = {}) {
        const startTime = Date.now();
        const results = [];
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'bootstrap');
        const bootstrapEnvironments = await environments.getEnvironments(this.ioHost);
        const source = options.source ?? bootstrap_1.BootstrapSource.default();
        const parameters = options.parameters;
        const bootstrapper = new bootstrap_2.Bootstrapper(source, ioHelper);
        const sdkProvider = await this.sdkProvider('bootstrap');
        const limit = (0, concurrency_1.pLimit)(20);
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        await Promise.all(bootstrapEnvironments.map((environment, currentIdx) => limit(async () => {
            const bootstrapSpan = await ioHelper.span(private_7.SPAN.BOOTSTRAP_SINGLE)
                .begin(`${chalk.bold(environment.name)}: bootstrapping...`, {
                total: bootstrapEnvironments.length,
                current: currentIdx + 1,
                environment,
            });
            try {
                const bootstrapResult = await bootstrapper.bootstrapEnvironment(environment, sdkProvider, {
                    ...options,
                    toolkitStackName: this.toolkitStackName,
                    source,
                    parameters: parameters?.parameters,
                    usePreviousParameters: parameters?.keepExistingParameters,
                });
                const message = bootstrapResult.noOp
                    ? ` ✅  ${environment.name} (no changes)`
                    : ` ✅  ${environment.name}`;
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I9900.msg(chalk.green('\n' + message), { environment }));
                const envTime = await bootstrapSpan.end();
                const result = {
                    environment,
                    status: bootstrapResult.noOp ? 'no-op' : 'success',
                    duration: envTime.asMs,
                };
                results.push(result);
            }
            catch (e) {
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E9900.msg(`\n ❌  ${chalk.bold(environment.name)} failed: ${(0, util_1.formatErrorMessage)(e)}`, { error: e }));
                throw e;
            }
        })));
        return {
            environments: results,
            duration: Date.now() - startTime,
        };
    }
    /**
     * Synth Action
     *
     * The caller assumes ownership of the `CachedCloudAssembly` and is responsible for calling `dispose()` on
     * it after use.
     */
    async synth(cx, options = {}) {
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'synth');
        const selectStacks = options.stacks ?? private_6.ALL_STACKS;
        const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        // NOTE: NOT 'await using' because we return ownership to the caller
        const assembly = await (0, private_1.assemblyFromSource)(synthSpan.asHelper, cx);
        const stacks = await assembly.selectStacksV2(selectStacks);
        const autoValidateStacks = options.validateStacks ? [assembly.selectStacksForValidation()] : [];
        await this.validateStacksMetadata(stacks.concat(...autoValidateStacks), synthSpan.asHelper);
        await synthSpan.end();
        // if we have a single stack, print it to STDOUT
        const message = `Successfully synthesized to ${chalk.blue(path.resolve(stacks.assembly.directory))}`;
        const assemblyData = {
            assemblyDirectory: stacks.assembly.directory,
            stacksCount: stacks.stackCount,
            stackIds: stacks.hierarchicalIds,
        };
        if (stacks.stackCount === 1) {
            const firstStack = stacks.firstStack;
            const template = firstStack.template;
            const obscuredTemplate = (0, util_1.obscureTemplate)(template);
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I1901.msg(message, {
                ...assemblyData,
                stack: {
                    stackName: firstStack.stackName,
                    hierarchicalId: firstStack.hierarchicalId,
                    template,
                    stringifiedJson: (0, util_1.serializeStructure)(obscuredTemplate, true),
                    stringifiedYaml: (0, util_1.serializeStructure)(obscuredTemplate, false),
                },
            }));
        }
        else {
            // not outputting template to stdout, let's explain things to the user a little bit...
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I1902.msg(chalk.green(message), assemblyData));
            await ioHelper.defaults.info(`Supply a stack id (${stacks.stackArtifacts.map((s) => chalk.green(s.hierarchicalId)).join(', ')}) to display its template.`);
        }
        return new cloud_assembly_1.CachedCloudAssembly(assembly);
    }
    /**
     * Diff Action
     */
    async diff(cx, options = {}) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'diff');
            const selectStacks = options.stacks ?? private_6.ALL_STACKS;
            const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
            const assembly = __addDisposableResource(env_1, await (0, private_1.assemblyFromSource)(synthSpan.asHelper, cx), true);
            const stacks = await assembly.selectStacksV2(selectStacks);
            await synthSpan.end();
            const diffSpan = await ioHelper.span(private_7.SPAN.DIFF_STACK).begin({ stacks: selectStacks });
            const deployments = await this.deploymentsForAction('diff');
            const strict = !!options.strict;
            const contextLines = options.contextLines || 3;
            let diffs = 0;
            const templateInfos = await (0, private_3.prepareDiff)(diffSpan.asHelper, stacks, deployments, await this.sdkProvider('diff'), options);
            const templateDiffs = {};
            for (const templateInfo of templateInfos) {
                const formatter = new diff_1.DiffFormatter({ templateInfo });
                const stackDiff = formatter.formatStackDiff({ strict, contextLines });
                // Security Diff
                const securityDiff = formatter.formatSecurityDiff();
                const formattedSecurityDiff = securityDiff.permissionChangeType !== payloads_1.PermissionChangeType.NONE ? stackDiff.formattedDiff : undefined;
                // We only warn about BROADENING changes
                if (securityDiff.permissionChangeType == payloads_1.PermissionChangeType.BROADENING) {
                    const warningMessage = 'This deployment will make potentially sensitive changes according to your current security approval level.\nPlease confirm you intend to make the following modifications:\n';
                    await diffSpan.defaults.warn(warningMessage);
                    await diffSpan.defaults.info(securityDiff.formattedDiff);
                }
                // Stack Diff
                diffs += stackDiff.numStacksWithChanges;
                (0, private_3.appendObject)(templateDiffs, formatter.diffs);
                await diffSpan.notify(private_7.IO.CDK_TOOLKIT_I4002.msg(stackDiff.formattedDiff, {
                    stack: templateInfo.newTemplate,
                    diffs: formatter.diffs,
                    numStacksWithChanges: stackDiff.numStacksWithChanges,
                    permissionChanges: securityDiff.permissionChangeType,
                    formattedDiff: {
                        diff: stackDiff.formattedDiff,
                        security: formattedSecurityDiff,
                    },
                }));
            }
            await diffSpan.end(`✨ Number of stacks with differences: ${diffs}`, {
                numStacksWithChanges: diffs,
                diffs: templateDiffs,
            });
            return templateDiffs;
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            const result_1 = __disposeResources(env_1);
            if (result_1)
                await result_1;
        }
    }
    /**
     * Drift Action
     */
    async drift(cx, options = {}) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'drift');
            const selectStacks = options.stacks ?? private_6.ALL_STACKS;
            const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
            const assembly = __addDisposableResource(env_2, await (0, private_1.assemblyFromSource)(synthSpan.asHelper, cx), true);
            const stacks = await assembly.selectStacksV2(selectStacks);
            await synthSpan.end();
            const driftSpan = await ioHelper.span(private_7.SPAN.DRIFT_APP).begin({ stacks: selectStacks });
            const allDriftResults = {};
            const unavailableDrifts = [];
            const sdkProvider = await this.sdkProvider('drift');
            for (const stack of stacks.stackArtifacts) {
                const cfn = (await sdkProvider.forEnvironment(stack.environment, plugin_1.Mode.ForReading)).sdk.cloudFormation();
                const driftResults = await (0, drift_1.detectStackDrift)(cfn, driftSpan.asHelper, stack.stackName);
                if (!driftResults.StackResourceDrifts) {
                    const stackName = stack.displayName ?? stack.stackName;
                    unavailableDrifts.push(stackName);
                    await driftSpan.notify(private_7.IO.CDK_TOOLKIT_W4591.msg(`${stackName}: No drift results available`, { stack }));
                    continue;
                }
                const formatter = new drift_formatter_1.DriftFormatter({ stack, resourceDrifts: driftResults.StackResourceDrifts });
                const driftOutput = formatter.formatStackDrift();
                const stackDrift = {
                    numResourcesWithDrift: driftOutput.numResourcesWithDrift,
                    numResourcesUnchecked: driftOutput.numResourcesUnchecked,
                    formattedDrift: {
                        unchanged: driftOutput.unchanged,
                        unchecked: driftOutput.unchecked,
                        modified: driftOutput.modified,
                        deleted: driftOutput.deleted,
                    },
                };
                allDriftResults[formatter.stackName] = stackDrift;
                // header
                await driftSpan.defaults.info(driftOutput.stackHeader);
                // print the different sections at different levels
                if (driftOutput.unchanged) {
                    await driftSpan.defaults.debug(driftOutput.unchanged);
                }
                if (driftOutput.unchecked) {
                    await driftSpan.defaults.debug(driftOutput.unchecked);
                }
                if (driftOutput.modified) {
                    await driftSpan.defaults.info(driftOutput.modified);
                }
                if (driftOutput.deleted) {
                    await driftSpan.defaults.info(driftOutput.deleted);
                }
                // main stack result
                await driftSpan.notify(private_7.IO.CDK_TOOLKIT_I4590.msg(driftOutput.summary, {
                    stack,
                    drift: stackDrift,
                }));
            }
            // print summary
            const totalDrifts = Object.values(allDriftResults).reduce((total, current) => total + (current.numResourcesWithDrift ?? 0), 0);
            const totalUnchecked = Object.values(allDriftResults).reduce((total, current) => total + (current.numResourcesUnchecked ?? 0), 0);
            await driftSpan.end(`\n✨  Number of resources with drift: ${totalDrifts}${totalUnchecked ? ` (${totalUnchecked} unchecked)` : ''}`);
            if (unavailableDrifts.length) {
                await driftSpan.defaults.warn(`\n⚠️  Failed to check drift for ${unavailableDrifts.length} stack(s). Check log for more details.`);
            }
            return allDriftResults;
        }
        catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
        }
        finally {
            const result_2 = __disposeResources(env_2);
            if (result_2)
                await result_2;
        }
    }
    /**
     * List Action
     *
     * List selected stacks and their dependencies
     */
    async list(cx, options = {}) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'list');
            const selectStacks = options.stacks ?? private_6.ALL_STACKS;
            const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
            const assembly = __addDisposableResource(env_3, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            const stackCollection = await assembly.selectStacksV2(selectStacks);
            await synthSpan.end();
            const stacks = stackCollection.withDependencies();
            const message = stacks.map(s => s.id).join('\n');
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I2901.msg(message, { stacks }));
            return stacks;
        }
        catch (e_3) {
            env_3.error = e_3;
            env_3.hasError = true;
        }
        finally {
            const result_3 = __disposeResources(env_3);
            if (result_3)
                await result_3;
        }
    }
    /**
     * Deploy Action
     *
     * Deploys the selected stacks into an AWS account
     */
    async deploy(cx, options = {}) {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'deploy');
            const assembly = __addDisposableResource(env_4, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            return await this._deploy(assembly, 'deploy', options);
        }
        catch (e_4) {
            env_4.error = e_4;
            env_4.hasError = true;
        }
        finally {
            const result_4 = __disposeResources(env_4);
            if (result_4)
                await result_4;
        }
    }
    /**
     * Helper to allow deploy being called as part of the watch action.
     */
    async _deploy(assembly, action, options = {}) {
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, action);
        const selectStacks = options.stacks ?? private_6.ALL_STACKS;
        const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        const stackCollection = await assembly.selectStacksV2(selectStacks);
        await this.validateStacksMetadata(stackCollection, ioHelper);
        const synthDuration = await synthSpan.end();
        const ret = {
            stacks: [],
        };
        if (stackCollection.stackCount === 0) {
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E5001.msg('This app contains no stacks'));
            return ret;
        }
        const deployments = await this.deploymentsForAction('deploy');
        const migrator = new resource_import_1.ResourceMigrator({ deployments, ioHelper });
        await migrator.tryMigrateResources(stackCollection, options);
        const parameterMap = (0, private_2.buildParameterMap)(options.parameters?.parameters);
        if (options.deploymentMethod?.method === 'hotswap') {
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_W5400.msg([
                '⚠️ Hotswap deployments deliberately introduce CloudFormation drift to speed up deployments',
                '⚠️ They should only be used for development - never use them for your production Stacks!',
            ].join('\n')));
        }
        const stacks = stackCollection.stackArtifacts;
        const stackOutputs = {};
        const outputsFile = options.outputsFile;
        const buildAsset = async (assetNode) => {
            const buildAssetSpan = await ioHelper.span(private_7.SPAN.BUILD_ASSET).begin({
                asset: assetNode.asset,
            });
            await deployments.buildSingleAsset(assetNode.assetManifestArtifact, assetNode.assetManifest, assetNode.asset, {
                stack: assetNode.parentStack,
                roleArn: options.roleArn,
                stackName: assetNode.parentStack.stackName,
            });
            await buildAssetSpan.end();
        };
        const publishAsset = async (assetNode) => {
            const publishAssetSpan = await ioHelper.span(private_7.SPAN.PUBLISH_ASSET).begin({
                asset: assetNode.asset,
            });
            await deployments.publishSingleAsset(assetNode.assetManifest, assetNode.asset, {
                stack: assetNode.parentStack,
                roleArn: options.roleArn,
                stackName: assetNode.parentStack.stackName,
                forcePublish: options.forceAssetPublishing,
            });
            await publishAssetSpan.end();
        };
        const deployStack = async (stackNode) => {
            const stack = stackNode.stack;
            if (stackCollection.stackCount !== 1) {
                await ioHelper.defaults.info(chalk.bold(stack.displayName));
            }
            if (!stack.environment) {
                throw new toolkit_error_1.ToolkitError(`Stack ${stack.displayName} does not define an environment, and AWS credentials could not be obtained from standard locations or no region was configured.`);
            }
            // The generated stack has no resources
            if (Object.keys(stack.template.Resources || {}).length === 0) {
                // stack is empty and doesn't exist => do nothing
                const stackExists = await deployments.stackExists({ stack });
                if (!stackExists) {
                    return ioHelper.notify(private_7.IO.CDK_TOOLKIT_W5021.msg(`${chalk.bold(stack.displayName)}: stack has no resources, skipping deployment.`));
                }
                // stack is empty, but exists => delete
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_W5022.msg(`${chalk.bold(stack.displayName)}: stack has no resources, deleting existing stack.`));
                await this._destroy(assembly, 'deploy', {
                    stacks: { patterns: [stack.hierarchicalId], strategy: cloud_assembly_1.StackSelectionStrategy.PATTERN_MUST_MATCH_SINGLE },
                    roleArn: options.roleArn,
                });
                return;
            }
            const currentTemplate = await deployments.readCurrentTemplate(stack);
            const formatter = new diff_1.DiffFormatter({
                templateInfo: {
                    oldTemplate: currentTemplate,
                    newTemplate: stack,
                },
            });
            const securityDiff = formatter.formatSecurityDiff();
            // Send a request response with the formatted security diff as part of the message,
            // and the template diff as data
            // (IoHost decides whether to print depending on permissionChangeType)
            const deployMotivation = '"--require-approval" is enabled and stack includes security-sensitive updates.';
            const deployQuestion = `${securityDiff.formattedDiff}\n\n${deployMotivation}\nDo you wish to deploy these changes`;
            const deployConfirmed = await ioHelper.requestResponse(private_7.IO.CDK_TOOLKIT_I5060.req(deployQuestion, {
                motivation: deployMotivation,
                concurrency,
                permissionChangeType: securityDiff.permissionChangeType,
                templateDiffs: formatter.diffs,
            }));
            if (!deployConfirmed) {
                throw new toolkit_error_1.ToolkitError('Aborted by user');
            }
            // Following are the same semantics we apply with respect to Notification ARNs (dictated by the SDK)
            //
            //  - undefined  =>  cdk ignores it, as if it wasn't supported (allows external management).
            //  - []:        =>  cdk manages it, and the user wants to wipe it out.
            //  - ['arn-1']  =>  cdk manages it, and the user wants to set it to ['arn-1'].
            const notificationArns = (!!options.notificationArns || !!stack.notificationArns)
                ? (options.notificationArns ?? []).concat(stack.notificationArns ?? [])
                : undefined;
            for (const notificationArn of notificationArns ?? []) {
                if (!(0, util_1.validateSnsTopicArn)(notificationArn)) {
                    throw new toolkit_error_1.ToolkitError(`Notification arn ${notificationArn} is not a valid arn for an SNS topic`);
                }
            }
            const stackIndex = stacks.indexOf(stack) + 1;
            const deploySpan = await ioHelper.span(private_7.SPAN.DEPLOY_STACK)
                .begin(`${chalk.bold(stack.displayName)}: deploying... [${stackIndex}/${stackCollection.stackCount}]`, {
                total: stackCollection.stackCount,
                current: stackIndex,
                stack,
            });
            let tags = options.tags;
            if (!tags || tags.length === 0) {
                tags = (0, private_8.tagsForStack)(stack);
            }
            let deployDuration;
            try {
                let deployResult;
                let rollback = options.rollback;
                let iteration = 0;
                while (!deployResult) {
                    if (++iteration > 2) {
                        throw new toolkit_error_1.ToolkitError('This loop should have stabilized in 2 iterations, but didn\'t. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose');
                    }
                    const r = await deployments.deployStack({
                        stack,
                        deployName: stack.stackName,
                        roleArn: options.roleArn,
                        toolkitStackName: this.toolkitStackName,
                        reuseAssets: options.reuseAssets,
                        notificationArns,
                        tags,
                        deploymentMethod: options.deploymentMethod,
                        forceDeployment: options.forceDeployment,
                        parameters: Object.assign({}, parameterMap['*'], parameterMap[stack.stackName]),
                        usePreviousParameters: options.parameters?.keepExistingParameters,
                        rollback,
                        extraUserAgent: options.extraUserAgent,
                        assetParallelism: options.assetParallelism,
                    });
                    switch (r.type) {
                        case 'did-deploy-stack':
                            deployResult = r;
                            break;
                        case 'failpaused-need-rollback-first': {
                            const motivation = r.reason === 'replacement'
                                ? `Stack is in a paused fail state (${r.status}) and change includes a replacement which cannot be deployed with "--no-rollback"`
                                : `Stack is in a paused fail state (${r.status}) and command line arguments do not include "--no-rollback"`;
                            const question = `${motivation}. Perform a regular deployment`;
                            const confirmed = await ioHelper.requestResponse(private_7.IO.CDK_TOOLKIT_I5050.req(question, {
                                motivation,
                                concurrency,
                            }));
                            if (!confirmed) {
                                throw new toolkit_error_1.ToolkitError('Aborted by user');
                            }
                            // Perform a rollback
                            await this._rollback(assembly, action, {
                                stacks: {
                                    patterns: [stack.hierarchicalId],
                                    strategy: cloud_assembly_1.StackSelectionStrategy.PATTERN_MUST_MATCH_SINGLE,
                                },
                                orphanFailedResources: options.orphanFailedResourcesDuringRollback,
                            });
                            // Go around through the 'while' loop again but switch rollback to true.
                            rollback = true;
                            break;
                        }
                        case 'replacement-requires-rollback': {
                            const motivation = 'Change includes a replacement which cannot be deployed with "--no-rollback"';
                            const question = `${motivation}. Perform a regular deployment`;
                            const confirmed = await ioHelper.requestResponse(private_7.IO.CDK_TOOLKIT_I5050.req(question, {
                                motivation,
                                concurrency,
                            }));
                            if (!confirmed) {
                                throw new toolkit_error_1.ToolkitError('Aborted by user');
                            }
                            // Go around through the 'while' loop again but switch rollback to true.
                            rollback = true;
                            break;
                        }
                        default:
                            throw new toolkit_error_1.ToolkitError(`Unexpected result type from deployStack: ${JSON.stringify(r)}. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose`);
                    }
                }
                const message = deployResult.noOp
                    ? ` ✅  ${stack.displayName} (no changes)`
                    : ` ✅  ${stack.displayName}`;
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5900.msg(chalk.green('\n' + message), deployResult));
                deployDuration = await deploySpan.timing(private_7.IO.CDK_TOOLKIT_I5000);
                if (Object.keys(deployResult.outputs).length > 0) {
                    const buffer = ['Outputs:'];
                    stackOutputs[stack.stackName] = deployResult.outputs;
                    for (const name of Object.keys(deployResult.outputs).sort()) {
                        const value = deployResult.outputs[name];
                        buffer.push(`${chalk.cyan(stack.id)}.${chalk.cyan(name)} = ${chalk.underline(chalk.cyan(value))}`);
                    }
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5901.msg(buffer.join('\n')));
                }
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5901.msg(`Stack ARN:\n${deployResult.stackArn}`));
                ret.stacks.push({
                    stackName: stack.stackName,
                    environment: {
                        account: stack.environment.account,
                        region: stack.environment.region,
                    },
                    stackArn: deployResult.stackArn,
                    outputs: deployResult.outputs,
                    hierarchicalId: stack.hierarchicalId,
                });
            }
            catch (e) {
                // It has to be exactly this string because an integration test tests for
                // "bold(stackname) failed: ResourceNotReady: <error>"
                throw new toolkit_error_1.ToolkitError([`❌  ${chalk.bold(stack.stackName)} failed:`, ...(e.name ? [`${e.name}:`] : []), e.message].join(' '));
            }
            finally {
                if (options.traceLogs) {
                    // deploy calls that originate from watch will come with their own cloudWatchLogMonitor
                    const cloudWatchLogMonitor = options.cloudWatchLogMonitor ?? new logs_monitor_1.CloudWatchLogEventMonitor({ ioHelper });
                    const foundLogGroupsResult = await (0, logs_monitor_1.findCloudWatchLogGroups)(await this.sdkProvider('deploy'), ioHelper, stack);
                    cloudWatchLogMonitor.addLogGroups(foundLogGroupsResult.env, foundLogGroupsResult.sdk, foundLogGroupsResult.logGroupNames);
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5031.msg(`The following log groups are added: ${foundLogGroupsResult.logGroupNames}`));
                }
                // If an outputs file has been specified, create the file path and write stack outputs to it once.
                // Outputs are written after all stacks have been deployed. If a stack deployment fails,
                // all of the outputs from successfully deployed stacks before the failure will still be written.
                if (outputsFile) {
                    fs.ensureFileSync(outputsFile);
                    await fs.writeJson(outputsFile, stackOutputs, {
                        spaces: 2,
                        encoding: 'utf8',
                    });
                }
            }
            const duration = synthDuration.asMs + (deployDuration?.asMs ?? 0);
            await deploySpan.end(`\n✨  Total time: ${(0, util_1.formatTime)(duration)}s\n`, { duration });
        };
        const assetBuildTime = options.assetBuildTime ?? deploy_1.AssetBuildTime.ALL_BEFORE_DEPLOY;
        const prebuildAssets = assetBuildTime === deploy_1.AssetBuildTime.ALL_BEFORE_DEPLOY;
        const concurrency = options.concurrency || 1;
        const stacksAndTheirAssetManifests = stacks.flatMap((stack) => [
            stack,
            ...stack.dependencies.filter(x => cxapi.AssetManifestArtifact.isAssetManifestArtifact(x)),
        ]);
        const workGraph = new work_graph_1.WorkGraphBuilder(ioHelper, prebuildAssets).build(stacksAndTheirAssetManifests);
        // Unless we are running with '--force', skip already published assets
        if (!options.forceAssetPublishing) {
            await (0, private_2.removePublishedAssetsFromWorkGraph)(workGraph, deployments, options);
        }
        const graphConcurrency = {
            'stack': concurrency,
            'asset-build': 1, // This will be CPU-bound/memory bound, mostly matters for Docker builds
            'asset-publish': (options.assetParallelism ?? true) ? 8 : 1, // This will be I/O-bound, 8 in parallel seems reasonable
        };
        await workGraph.doParallel(graphConcurrency, {
            deployStack,
            buildAsset,
            publishAsset,
        });
        return ret;
    }
    /**
     * Watch Action
     *
     * Continuously observe project files and deploy the selected stacks
     * automatically when changes are detected. Defaults to hotswap deployments.
     *
     * This function returns immediately, starting a watcher in the background.
     */
    async watch(cx, options = {}) {
        const env_5 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'watch');
            const assembly = __addDisposableResource(env_5, await (0, private_1.assemblyFromSource)(ioHelper, cx, false), true);
            const rootDir = options.watchDir ?? process.cwd();
            // For the "include" setting, the behavior is:
            // 1. "watch" setting without an "include" key? We default to observing "**".
            // 2. "watch" setting with an empty "include" key? We default to observing "**".
            // 3. Non-empty "include" key? Just use the "include" key.
            const watchIncludes = options.include ?? [];
            if (watchIncludes.length <= 0) {
                watchIncludes.push('**');
            }
            // For the "exclude" setting, the behavior is to add some default excludes in addition to
            // patterns specified by the user sensible default patterns:
            const watchExcludes = options.exclude ?? [...private_4.WATCH_EXCLUDE_DEFAULTS];
            // 1. The CDK output directory, if it is under the rootDir
            const relativeOutDir = path.relative(rootDir, assembly.directory);
            if (Boolean(relativeOutDir && !relativeOutDir.startsWith('..' + path.sep) && !path.isAbsolute(relativeOutDir))) {
                watchExcludes.push(`${relativeOutDir}/**`);
            }
            // 2. Any file whose name starts with a dot.
            watchExcludes.push('.*', '**/.*');
            // 3. Any directory's content whose name starts with a dot.
            watchExcludes.push('**/.*/**');
            // 4. Any node_modules and its content (even if it's not a JS/TS project, you might be using a local aws-cli package)
            watchExcludes.push('**/node_modules/**');
            // Print some debug information on computed settings
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5310.msg([
                `root directory used for 'watch' is: ${rootDir}`,
                `'include' patterns for 'watch': ${JSON.stringify(watchIncludes)}`,
                `'exclude' patterns for 'watch': ${JSON.stringify(watchExcludes)}`,
            ].join('\n'), {
                watchDir: rootDir,
                includes: watchIncludes,
                excludes: watchExcludes,
            }));
            let latch = 'pre-ready';
            const cloudWatchLogMonitor = options.traceLogs ? new logs_monitor_1.CloudWatchLogEventMonitor({ ioHelper }) : undefined;
            const deployAndWatch = async () => {
                latch = 'deploying';
                await cloudWatchLogMonitor?.deactivate();
                await this.invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor);
                // If latch is still 'deploying' after the 'await', that's fine,
                // but if it's 'queued', that means we need to deploy again
                while (latch === 'queued') {
                    // TypeScript doesn't realize latch can change between 'awaits',
                    // and thinks the above 'while' condition is always 'false' without the cast
                    latch = 'deploying';
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5315.msg("Detected file changes during deployment. Invoking 'cdk deploy' again"));
                    await this.invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor);
                }
                latch = 'open';
                await cloudWatchLogMonitor?.activate();
            };
            const watcher = chokidar
                .watch(watchIncludes, {
                ignored: watchExcludes,
                cwd: rootDir,
            })
                .on('ready', async () => {
                latch = 'open';
                await ioHelper.defaults.debug("'watch' received the 'ready' event. From now on, all file changes will trigger a deployment");
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5314.msg("Triggering initial 'cdk deploy'"));
                await deployAndWatch();
            })
                .on('all', async (event, filePath) => {
                const watchEvent = {
                    event,
                    path: filePath,
                };
                if (latch === 'pre-ready') {
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5311.msg(`'watch' is observing ${event === 'addDir' ? 'directory' : 'the file'} '${filePath}' for changes`, watchEvent));
                }
                else if (latch === 'open') {
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5312.msg(`Detected change to '${filePath}' (type: ${event}). Triggering 'cdk deploy'`, watchEvent));
                    await deployAndWatch();
                }
                else {
                    // this means latch is either 'deploying' or 'queued'
                    latch = 'queued';
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5313.msg(`Detected change to '${filePath}' (type: ${event}) while 'cdk deploy' is still running. Will queue for another deployment after this one finishes'`, watchEvent));
                }
            });
            const stoppedPromise = (0, promises_1.promiseWithResolvers)();
            return {
                async dispose() {
                    // stop the logs monitor, if it exists
                    await cloudWatchLogMonitor?.deactivate();
                    // close the watcher itself
                    await watcher.close();
                    // Prevents Node from staying alive. There is no 'end' event that the watcher emits
                    // that we can know it's definitely done, so best we can do is tell it to stop watching,
                    // stop keeping Node alive, and then pretend that's everything we needed to do.
                    watcher.unref();
                    stoppedPromise.resolve();
                    return stoppedPromise.promise;
                },
                async waitForEnd() {
                    return stoppedPromise.promise;
                },
                async [Symbol.asyncDispose]() {
                    return this.dispose();
                },
            };
        }
        catch (e_5) {
            env_5.error = e_5;
            env_5.hasError = true;
        }
        finally {
            const result_5 = __disposeResources(env_5);
            if (result_5)
                await result_5;
        }
    }
    /**
     * Rollback Action
     *
     * Rolls back the selected stacks.
     */
    async rollback(cx, options = {}) {
        const env_6 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'rollback');
            const assembly = __addDisposableResource(env_6, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            return await this._rollback(assembly, 'rollback', options);
        }
        catch (e_6) {
            env_6.error = e_6;
            env_6.hasError = true;
        }
        finally {
            const result_6 = __disposeResources(env_6);
            if (result_6)
                await result_6;
        }
    }
    /**
     * Helper to allow rollback being called as part of the deploy or watch action.
     */
    async _rollback(assembly, action, options) {
        const selectStacks = options.stacks ?? private_6.ALL_STACKS;
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, action);
        const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        const stacks = await assembly.selectStacksV2(selectStacks);
        await this.validateStacksMetadata(stacks, ioHelper);
        await synthSpan.end();
        const ret = {
            stacks: [],
        };
        if (stacks.stackCount === 0) {
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E6001.msg('No stacks selected'));
            return ret;
        }
        let anyRollbackable = false;
        for (const [index, stack] of stacks.stackArtifacts.entries()) {
            const rollbackSpan = await ioHelper.span(private_7.SPAN.ROLLBACK_STACK).begin(`Rolling back ${chalk.bold(stack.displayName)}`, {
                total: stacks.stackCount,
                current: index + 1,
                stack,
            });
            const deployments = await this.deploymentsForAction('rollback');
            try {
                const stackResult = await deployments.rollbackStack({
                    stack,
                    roleArn: options.roleArn,
                    toolkitStackName: this.toolkitStackName,
                    orphanFailedResources: options.orphanFailedResources,
                    validateBootstrapStackVersion: options.validateBootstrapStackVersion,
                    orphanLogicalIds: options.orphanLogicalIds,
                });
                if (!stackResult.notInRollbackableState) {
                    anyRollbackable = true;
                }
                await rollbackSpan.end();
                ret.stacks.push({
                    environment: {
                        account: stack.environment.account,
                        region: stack.environment.region,
                    },
                    stackName: stack.stackName,
                    stackArn: stackResult.stackArn,
                    result: stackResult.notInRollbackableState ? 'already-stable' : 'rolled-back',
                });
            }
            catch (e) {
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E6900.msg(`\n ❌  ${chalk.bold(stack.displayName)} failed: ${(0, util_1.formatErrorMessage)(e)}`, { error: e }));
                throw toolkit_error_1.ToolkitError.withCause('Rollback failed (use --force to orphan failing resources)', e);
            }
        }
        if (!anyRollbackable) {
            throw new toolkit_error_1.ToolkitError('No stacks were in a state that could be rolled back');
        }
        return ret;
    }
    /**
     * Refactor Action. Moves resources from one location (stack + logical ID) to another.
     */
    async refactor(cx, options = {}) {
        const env_7 = { stack: [], error: void 0, hasError: false };
        try {
            this.requireUnstableFeature('refactor');
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'refactor');
            const assembly = __addDisposableResource(env_7, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            return await this._refactor(assembly, ioHelper, options);
        }
        catch (e_7) {
            env_7.error = e_7;
            env_7.hasError = true;
        }
        finally {
            const result_7 = __disposeResources(env_7);
            if (result_7)
                await result_7;
        }
    }
    async _refactor(assembly, ioHelper, options = {}) {
        if (!options.dryRun) {
            throw new toolkit_error_1.ToolkitError('Refactor is not available yet. Too see the proposed changes, use the --dry-run flag.');
        }
        const sdkProvider = await this.sdkProvider('refactor');
        const selectedStacks = await assembly.selectStacksV2(options.stacks ?? private_6.ALL_STACKS);
        const groups = await (0, refactoring_1.groupStacks)(sdkProvider, selectedStacks.stackArtifacts, options.additionalStackNames ?? []);
        for (let { environment, localStacks, deployedStacks } of groups) {
            await ioHelper.defaults.info((0, refactoring_1.formatEnvironmentSectionHeader)(environment));
            try {
                const context = new context_1.RefactoringContext({
                    environment,
                    deployedStacks,
                    localStacks,
                    overrides: getOverrides(environment, deployedStacks, localStacks),
                });
                const mappings = context.mappings;
                if (mappings.length === 0 && context.ambiguousPaths.length === 0) {
                    await ioHelper.defaults.info('Nothing to refactor.');
                    continue;
                }
                const typedMappings = mappings
                    .map(m => m.toTypedMapping())
                    .filter(m => m.type !== 'AWS::CDK::Metadata');
                let refactorMessage = (0, refactoring_1.formatTypedMappings)(typedMappings);
                const refactorResult = { typedMappings };
                if (context.ambiguousPaths.length > 0) {
                    const paths = context.ambiguousPaths;
                    refactorMessage += '\n' + (0, refactoring_1.formatAmbiguousMappings)(paths);
                    refactorResult.ambiguousPaths = paths;
                }
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I8900.msg(refactorMessage, refactorResult));
            }
            catch (e) {
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E8900.msg(e.message, { error: e }));
            }
        }
        function getOverrides(environment, deployedStacks, localStacks) {
            const mappingGroup = options.overrides
                ?.find(g => g.region === environment.region && g.account === environment.account);
            let overrides = [];
            if (mappingGroup != null) {
                overrides = Object.entries(mappingGroup.resources ?? {}).map(([source, destination]) => {
                    const sourceStack = findStack(source, deployedStacks);
                    const sourceLogicalId = source.split('.')[1];
                    const destinationStack = findStack(destination, localStacks);
                    const destinationLogicalId = destination.split('.')[1];
                    return new cloudformation_1.ResourceMapping(new cloudformation_1.ResourceLocation(sourceStack, sourceLogicalId), new cloudformation_1.ResourceLocation(destinationStack, destinationLogicalId));
                });
            }
            return overrides;
            function findStack(location, stacks) {
                const result = stacks.find(stack => {
                    const [stackName, logicalId] = location.split('.');
                    if (stackName == null || logicalId == null) {
                        throw new toolkit_error_1.ToolkitError(`Invalid location '${location}'`);
                    }
                    return stack.stackName === stackName && stack.template.Resources?.[logicalId] != null;
                });
                if (result == null) {
                    throw new toolkit_error_1.ToolkitError(`Cannot find resource in location ${location}`);
                }
                return result;
            }
        }
    }
    /**
     * Destroy Action
     *
     * Destroys the selected Stacks.
     */
    async destroy(cx, options = {}) {
        const env_8 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'destroy');
            const assembly = __addDisposableResource(env_8, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            return await this._destroy(assembly, 'destroy', options);
        }
        catch (e_8) {
            env_8.error = e_8;
            env_8.hasError = true;
        }
        finally {
            const result_8 = __disposeResources(env_8);
            if (result_8)
                await result_8;
        }
    }
    /**
     * Helper to allow destroy being called as part of the deploy action.
     */
    async _destroy(assembly, action, options) {
        const selectStacks = options.stacks ?? private_6.ALL_STACKS;
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, action);
        const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        // The stacks will have been ordered for deployment, so reverse them for deletion.
        const stacks = (await assembly.selectStacksV2(selectStacks)).reversed();
        await synthSpan.end();
        const ret = {
            stacks: [],
        };
        const motivation = 'Destroying stacks is an irreversible action';
        const question = `Are you sure you want to delete: ${chalk.red(stacks.hierarchicalIds.join(', '))}`;
        const confirmed = await ioHelper.requestResponse(private_7.IO.CDK_TOOLKIT_I7010.req(question, { motivation }));
        if (!confirmed) {
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E7010.msg('Aborted by user'));
            return ret;
        }
        const destroySpan = await ioHelper.span(private_7.SPAN.DESTROY_ACTION).begin({
            stacks: stacks.stackArtifacts,
        });
        try {
            for (const [index, stack] of stacks.stackArtifacts.entries()) {
                try {
                    const singleDestroySpan = await ioHelper.span(private_7.SPAN.DESTROY_STACK)
                        .begin(chalk.green(`${chalk.blue(stack.displayName)}: destroying... [${index + 1}/${stacks.stackCount}]`), {
                        total: stacks.stackCount,
                        current: index + 1,
                        stack,
                    });
                    const deployments = await this.deploymentsForAction(action);
                    const result = await deployments.destroyStack({
                        stack,
                        deployName: stack.stackName,
                        roleArn: options.roleArn,
                    });
                    ret.stacks.push({
                        environment: {
                            account: stack.environment.account,
                            region: stack.environment.region,
                        },
                        stackName: stack.stackName,
                        stackArn: result.stackArn,
                        stackExisted: result.stackArn !== undefined,
                    });
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I7900.msg(chalk.green(`\n ✅  ${chalk.blue(stack.displayName)}: ${action}ed`), stack));
                    await singleDestroySpan.end();
                }
                catch (e) {
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E7900.msg(`\n ❌  ${chalk.blue(stack.displayName)}: ${action} failed ${e}`, { error: e }));
                    throw e;
                }
            }
            return ret;
        }
        finally {
            await destroySpan.end();
        }
    }
    /**
     * Validate the stacks for errors and warnings according to the CLI's current settings
     */
    async validateStacksMetadata(stacks, ioHost) {
        const builder = (level) => {
            switch (level) {
                case 'error':
                    return private_7.IO.CDK_ASSEMBLY_E9999;
                case 'warn':
                    return private_7.IO.CDK_ASSEMBLY_W9999;
                default:
                    return private_7.IO.CDK_ASSEMBLY_I9999;
            }
        };
        await stacks.validateMetadata(this.props.assemblyFailureAt, async (level, msg) => ioHost.notify(builder(level).msg(`[${level} at ${msg.id}] ${msg.entry.data}`, msg)));
    }
    /**
     * Create a deployments class
     */
    async deploymentsForAction(action) {
        return new deployments_1.Deployments({
            sdkProvider: await this.sdkProvider(action),
            toolkitStackName: this.toolkitStackName,
            ioHelper: (0, private_7.asIoHelper)(this.ioHost, action),
        });
    }
    async invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor) {
        // watch defaults to hotswap deployment
        const deploymentMethod = options.deploymentMethod ?? { method: 'hotswap' };
        const deployOptions = {
            ...options,
            cloudWatchLogMonitor,
            deploymentMethod,
            extraUserAgent: `cdk-watch/hotswap-${deploymentMethod.method === 'hotswap' ? 'on' : 'off'}`,
        };
        try {
            await this._deploy(assembly, 'watch', deployOptions);
        }
        catch {
            // just continue - deploy will show the error
        }
    }
    /**
     * Retrieve feature flag information from the cloud assembly
     */
    async flags(cx) {
        const env_9 = { stack: [], error: void 0, hasError: false };
        try {
            this.requireUnstableFeature('flags');
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'flags');
            const assembly = __addDisposableResource(env_9, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            const artifacts = Object.values(assembly.cloudAssembly.manifest.artifacts ?? {});
            const featureFlagReports = artifacts.filter(a => a.type === cloud_assembly_schema_1.ArtifactType.FEATURE_FLAG_REPORT);
            const flags = featureFlagReports.flatMap(report => {
                const properties = report.properties;
                const moduleName = properties.module;
                const flagsWithUnconfiguredBehavesLike = Object.entries(properties.flags)
                    .filter(([_, flagInfo]) => flagInfo.unconfiguredBehavesLike != undefined);
                const shouldIncludeUnconfiguredBehavesLike = flagsWithUnconfiguredBehavesLike.length > 0;
                return Object.entries(properties.flags).map(([flagName, flagInfo]) => {
                    const baseFlag = {
                        module: moduleName,
                        name: flagName,
                        recommendedValue: flagInfo.recommendedValue,
                        userValue: flagInfo.userValue ?? undefined,
                        explanation: flagInfo.explanation ?? '',
                    };
                    if (shouldIncludeUnconfiguredBehavesLike) {
                        return {
                            ...baseFlag,
                            unconfiguredBehavesLike: {
                                v2: flagInfo.unconfiguredBehavesLike?.v2 ?? false,
                            },
                        };
                    }
                    return baseFlag;
                });
            });
            return flags;
        }
        catch (e_9) {
            env_9.error = e_9;
            env_9.hasError = true;
        }
        finally {
            const result_9 = __disposeResources(env_9);
            if (result_9)
                await result_9;
        }
    }
    requireUnstableFeature(requestedFeature) {
        if (!this.unstableFeatures.includes(requestedFeature)) {
            throw new toolkit_error_1.ToolkitError(`Unstable feature '${requestedFeature}' is not enabled. Please enable it under 'unstableFeatures'`);
        }
    }
}
exports.Toolkit = Toolkit;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRvb2xraXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHVDQUFxQztBQUNyQyxrQ0FBa0M7QUFFbEMsMEVBQThEO0FBRTlELHlDQUF5QztBQUN6QywrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLCtCQUErQjtBQUMvQix1RUFBaUU7QUFFakUsdUNBQStDO0FBQy9DLG1EQUErQztBQVEvQyxvREFBdUQ7QUFDdkQsOENBQXVFO0FBQ3ZFLHVEQUltQztBQUduQyxxREFBb0U7QUFPcEUsc0RBQWtFO0FBQ2xFLDhDQUt5QjtBQUN6Qix5RUFBc0U7QUFDdEUscURBQXVFO0FBQ3ZFLGdEQUFnRDtBQUVoRCwwREFBb0Y7QUFFcEYsMkRBQTJEO0FBQzNELHlFQUFrRjtBQUVsRixvREFBaUQ7QUFDakQsc0NBQTRDO0FBQzVDLHdDQUFnRDtBQUNoRCxrRUFBOEQ7QUFHOUQsK0NBQTZHO0FBQzdHLHNEQUF5RjtBQUN6RiwwQ0FBaUQ7QUFDakQsb0RBSzRCO0FBRTVCLHNFQUFzRjtBQUN0Rix3REFBZ0U7QUFDaEUsNERBQTBEO0FBQzFELGlEQUFtRDtBQUNuRCxzREFBaUU7QUFFakUsa0RBQXFEO0FBRXJELDBDQUFtRDtBQUNuRCxrQ0FBbUg7QUFDbkgscURBQTZDO0FBQzdDLCtDQUF3RDtBQXFFeEQ7O0dBRUc7QUFDSCxNQUFhLE9BQVEsU0FBUSwyQ0FBMEI7SUF5QmpCO0lBeEJwQzs7T0FFRztJQUNhLGdCQUFnQixDQUFTO0lBRXpDOztPQUVHO0lBQ2EsTUFBTSxDQUFVO0lBRWhDOztPQUVHO0lBQ2EsVUFBVSxDQUFhO0lBRXZDOztPQUVHO0lBQ0ssZ0JBQWdCLENBQWU7SUFFL0IsZUFBZSxDQUEyQjtJQUVqQyxnQkFBZ0IsQ0FBeUI7SUFFMUQsWUFBb0MsUUFBd0IsRUFBRTtRQUM1RCxLQUFL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QUMsV0FBVyxJQUFJLEVBQUU7cUJBQ3hDLENBQUM7b0JBRUYsSUFBSSxvQ0FBb0MsRUFBRSxDQUFDO3dCQUN6QyxPQUFPOzRCQUNMLEdBQUcsUUFBUTs0QkFDWCx1QkFBdUIsRUFBRTtnQ0FDdkIsRUFBRSxFQUFFLFFBQVEsQ0FBQyx1QkFBdUIsRUFBRSxFQUFFLElBQUksS0FBSzs2QkFDbEQ7eUJBQ0YsQ0FBQztvQkFDSixDQUFDO29CQUVELE9BQU8sUUFBUSxDQUFDO2dCQUNsQixDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBRUgsT0FBTyxLQUFLLENBQUM7Ozs7Ozs7Ozs7O0tBQ2Q7SUFFTyxzQkFBc0IsQ0FBQyxnQkFBaUM7UUFDOUQsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO1lBQ3RELE1BQU0sSUFBSSw0QkFBWSxDQUFDLHFCQUFxQixnQkFBZ0IsNkRBQTZELENBQUMsQ0FBQztRQUM3SCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBdHBDRCwwQkFzcENDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuLi9wcml2YXRlL2Rpc3Bvc2UtcG9seWZpbGwnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHR5cGUgeyBGZWF0dXJlRmxhZ1JlcG9ydFByb3BlcnRpZXMgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0IHsgQXJ0aWZhY3RUeXBlIH0gZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCB0eXBlIHsgVGVtcGxhdGVEaWZmIH0gZnJvbSAnQGF3cy1jZGsvY2xvdWRmb3JtYXRpb24tZGlmZic7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgY2hva2lkYXIgZnJvbSAnY2hva2lkYXInO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgTm9uSW50ZXJhY3RpdmVJb0hvc3QgfSBmcm9tICcuL25vbi1pbnRlcmFjdGl2ZS1pby1ob3N0JztcbmltcG9ydCB0eXBlIHsgVG9vbGtpdFNlcnZpY2VzIH0gZnJvbSAnLi9wcml2YXRlJztcbmltcG9ydCB7IGFzc2VtYmx5RnJvbVNvdXJjZSB9IGZyb20gJy4vcHJpdmF0ZSc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuL3Rvb2xraXQtZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBGZWF0dXJlRmxhZywgRGVwbG95UmVzdWx0LCBEZXN0cm95UmVzdWx0LCBSb2xsYmFja1Jlc3VsdCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBCb290c3RyYXBFbnZpcm9ubWVudHMsXG4gIEJvb3RzdHJhcE9wdGlvbnMsXG4gIEJvb3RzdHJhcFJlc3VsdCxcbiAgRW52aXJvbm1lbnRCb290c3RyYXBSZXN1bHQsXG59IGZyb20gJy4uL2FjdGlvbnMvYm9vdHN0cmFwJztcbmltcG9ydCB7IEJvb3RzdHJhcFNvdXJjZSB9IGZyb20gJy4uL2FjdGlvbnMvYm9vdHN0cmFwJztcbmltcG9ydCB7IEFzc2V0QnVpbGRUaW1lLCB0eXBlIERlcGxveU9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL2RlcGxveSc7XG5pbXBvcnQge1xuICBidWlsZFBhcmFtZXRlck1hcCxcbiAgdHlwZSBQcml2YXRlRGVwbG95T3B0aW9ucyxcbiAgcmVtb3ZlUHVibGlzaGVkQXNzZXRzRnJvbVdvcmtHcmFwaCxcbn0gZnJvbSAnLi4vYWN0aW9ucy9kZXBsb3kvcHJpdmF0ZSc7XG5pbXBvcnQgeyB0eXBlIERlc3Ryb3lPcHRpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy9kZXN0cm95JztcbmltcG9ydCB0eXBlIHsgRGlmZk9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL2RpZmYnO1xuaW1wb3J0IHsgYXBwZW5kT2JqZWN0LCBwcmVwYXJlRGlmZiB9IGZyb20gJy4uL2FjdGlvbnMvZGlmZi9wcml2YXRlJztcbmltcG9ydCB0eXBlIHsgRHJpZnRPcHRpb25zLCBEcmlmdFJlc3VsdCB9IGZyb20gJy4uL2FjdGlvbnMvZHJpZnQnO1xuaW1wb3J0IHsgdHlwZSBMaXN0T3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvbGlzdCc7XG5pbXBvcnQgdHlwZSB7IFJlZmFjdG9yT3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvcmVmYWN0b3InO1xuaW1wb3J0IHsgdHlwZSBSb2xsYmFja09wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL3JvbGxiYWNrJztcbmltcG9ydCB7IHR5cGUgU3ludGhPcHRpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy9zeW50aCc7XG5pbXBvcnQgdHlwZSB7IElXYXRjaGVyLCBXYXRjaE9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL3dhdGNoJztcbmltcG9ydCB7IFdBVENIX0VYQ0xVREVfREVGQVVMVFMgfSBmcm9tICcuLi9hY3Rpb25zL3dhdGNoL3ByaXZhdGUnO1xuaW1wb3J0IHtcbiAgQmFzZUNyZWRlbnRpYWxzLFxuICB0eXBlIElCYXNlQ3JlZGVudGlhbHNQcm92aWRlcixcbiAgdHlwZSBTZGtCYXNlQ2xpZW50Q29uZmlnLFxuICB0eXBlIFNka0NvbmZpZyxcbn0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoJztcbmltcG9ydCB7IHNka1JlcXVlc3RIYW5kbGVyIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoL2F3c2NsaS1jb21wYXRpYmxlJztcbmltcG9ydCB7IElvSG9zdFNka0xvZ2dlciwgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hcGkvYXdzLWF1dGgvcHJpdmF0ZSc7XG5pbXBvcnQgeyBCb290c3RyYXBwZXIgfSBmcm9tICcuLi9hcGkvYm9vdHN0cmFwJztcbmltcG9ydCB0eXBlIHsgSUNsb3VkQXNzZW1ibHlTb3VyY2UgfSBmcm9tICcuLi9hcGkvY2xvdWQtYXNzZW1ibHknO1xuaW1wb3J0IHsgQ2FjaGVkQ2xvdWRBc3NlbWJseSwgU3RhY2tTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4uL2FwaS9jbG91ZC1hc3NlbWJseSc7XG5pbXBvcnQgdHlwZSB7IFN0YWNrQXNzZW1ibHkgfSBmcm9tICcuLi9hcGkvY2xvdWQtYXNzZW1ibHkvcHJpdmF0ZSc7XG5pbXBvcnQgeyBBTExfU1RBQ0tTIH0gZnJvbSAnLi4vYXBpL2Nsb3VkLWFzc2VtYmx5L3ByaXZhdGUnO1xuaW1wb3J0IHsgQ2xvdWRBc3NlbWJseVNvdXJjZUJ1aWxkZXIgfSBmcm9tICcuLi9hcGkvY2xvdWQtYXNzZW1ibHkvc291cmNlLWJ1aWxkZXInO1xuaW1wb3J0IHR5cGUgeyBTdGFja0NvbGxlY3Rpb24gfSBmcm9tICcuLi9hcGkvY2xvdWQtYXNzZW1ibHkvc3RhY2stY29sbGVjdGlvbic7XG5pbXBvcnQgeyBEZXBsb3ltZW50cyB9IGZyb20gJy4uL2FwaS9kZXBsb3ltZW50cyc7XG5pbXBvcnQgeyBEaWZmRm9ybWF0dGVyIH0gZnJvbSAnLi4vYXBpL2RpZmYnO1xuaW1wb3J0IHsgZGV0ZWN0U3RhY2tEcmlmdCB9IGZyb20gJy4uL2FwaS9kcmlmdCc7XG5pbXBvcnQgeyBEcmlmdEZvcm1hdHRlciB9IGZyb20gJy4uL2FwaS9kcmlmdC9kcmlmdC1mb3JtYXR0ZXInO1xuaW1wb3J0IHR5cGUgeyBJSW9Ib3N0LCBJb01lc3NhZ2VMZXZlbCwgVG9vbGtpdEFjdGlvbiB9IGZyb20gJy4uL2FwaS9pbyc7XG5pbXBvcnQgdHlwZSB7IElvSGVscGVyIH0gZnJvbSAnLi4vYXBpL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHsgYXNJb0hlbHBlciwgSU8sIFNQQU4sIHdpdGhvdXRDb2xvciwgd2l0aG91dEVtb2ppcywgd2l0aFRyaW1tZWRXaGl0ZXNwYWNlIH0gZnJvbSAnLi4vYXBpL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHsgQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvciwgZmluZENsb3VkV2F0Y2hMb2dHcm91cHMgfSBmcm9tICcuLi9hcGkvbG9ncy1tb25pdG9yJztcbmltcG9ydCB7IE1vZGUsIFBsdWdpbkhvc3QgfSBmcm9tICcuLi9hcGkvcGx1Z2luJztcbmltcG9ydCB7XG4gIGZvcm1hdEFtYmlndW91c01hcHBpbmdzLFxuICBmb3JtYXRFbnZpcm9ubWVudFNlY3Rpb25IZWFkZXIsXG4gIGZvcm1hdFR5cGVkTWFwcGluZ3MsXG4gIGdyb3VwU3RhY2tzLFxufSBmcm9tICcuLi9hcGkvcmVmYWN0b3JpbmcnO1xuaW1wb3J0IHR5cGUgeyBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi4vYXBpL3JlZmFjdG9yaW5nL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IFJlc291cmNlTWFwcGluZywgUmVzb3VyY2VMb2NhdGlvbiB9IGZyb20gJy4uL2FwaS9yZWZhY3RvcmluZy9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBSZWZhY3RvcmluZ0NvbnRleHQgfSBmcm9tICcuLi9hcGkvcmVmYWN0b3JpbmcvY29udGV4dCc7XG5pbXBvcnQgeyBSZXNvdXJjZU1pZ3JhdG9yIH0gZnJvbSAnLi4vYXBpL3Jlc291cmNlLWltcG9ydCc7XG5pbXBvcnQgeyB0YWdzRm9yU3RhY2sgfSBmcm9tICcuLi9hcGkvdGFncy9wcml2YXRlJztcbmltcG9ydCB7IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FIH0gZnJvbSAnLi4vYXBpL3Rvb2xraXQtaW5mbyc7XG5pbXBvcnQgdHlwZSB7IEFzc2V0QnVpbGROb2RlLCBBc3NldFB1Ymxpc2hOb2RlLCBDb25jdXJyZW5jeSwgU3RhY2tOb2RlIH0gZnJvbSAnLi4vYXBpL3dvcmstZ3JhcGgnO1xuaW1wb3J0IHsgV29ya0dyYXBoQnVpbGRlciB9IGZyb20gJy4uL2FwaS93b3JrLWdyYXBoJztcbmltcG9ydCB0eXBlIHsgQXNzZW1ibHlEYXRhLCBSZWZhY3RvclJlc3VsdCwgU3RhY2tEZXRhaWxzLCBTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQgfSBmcm9tICcuLi9wYXlsb2Fkcyc7XG5pbXBvcnQgeyBQZXJtaXNzaW9uQ2hhbmdlVHlwZSB9IGZyb20gJy4uL3BheWxvYWRzJztcbmltcG9ydCB7IGZvcm1hdEVycm9yTWVzc2FnZSwgZm9ybWF0VGltZSwgb2JzY3VyZVRlbXBsYXRlLCBzZXJpYWxpemVTdHJ1Y3R1cmUsIHZhbGlkYXRlU25zVG9waWNBcm4gfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7IHBMaW1pdCB9IGZyb20gJy4uL3V0aWwvY29uY3VycmVuY3knO1xuaW1wb3J0IHsgcHJvbWlzZVdpdGhSZXNvbHZlcnMgfSBmcm9tICcuLi91dGlsL3Byb21pc2VzJztcblxuZXhwb3J0IGludGVyZmFjZSBUb29sa2l0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgSW9Ib3N0IGltcGxlbWVudGF0aW9uLCBoYW5kbGluZyB0aGUgaW5saW5lIGludGVyYWN0aW9ucyBiZXR3ZWVuIHRoZSBUb29sa2l0IGFuZCBhbiBpbnRlZ3JhdGlvbi5cbiAgICovXG4gIHJlYWRvbmx5IGlvSG9zdD86IElJb0hvc3Q7XG5cbiAgLyoqXG4gICAqIEFsbG93IGVtb2ppcyBpbiBtZXNzYWdlcyBzZW50IHRvIHRoZSBJb0hvc3QuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGVtb2ppcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYWxsb3cgQU5TSSBjb2xvcnMgYW5kIGZvcm1hdHRpbmcgaW4gSW9Ib3N0IG1lc3NhZ2VzLlxuICAgKiBTZXR0aW5nIHRoaXMgdmFsdWUgdG8gYGZhbHNlYCBlbmZvcmNlcyB0aGF0IG5vIGNvbG9yIG9yIHN0eWxlIHNob3dzIHVwXG4gICAqIGluIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIElvSG9zdC5cbiAgICogU2V0dGluZyB0aGlzIHZhbHVlIHRvIHRydWUgaXMgYSBuby1vcDsgaXQgaXMgZXF1aXZhbGVudCB0byB0aGUgZGVmYXVsdC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZXRlY3RzIGNvbG9yIGZyb20gdGhlIFRUWSBzdGF0dXMgb2YgdGhlIElvSG9zdFxuICAgKi9cbiAgcmVhZG9ubHkgY29sb3I/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBTREsuXG4gICAqL1xuICByZWFkb25seSBzZGtDb25maWc/OiBTZGtDb25maWc7XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIHRvb2xraXQgc3RhY2sgdG8gYmUgdXNlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgXCJDREtUb29sa2l0XCJcbiAgICovXG4gIHJlYWRvbmx5IHRvb2xraXRTdGFja05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZhaWwgQ2xvdWQgQXNzZW1ibGllc1xuICAgKlxuICAgKiBAZGVmYXVsdCBcImVycm9yXCJcbiAgICovXG4gIHJlYWRvbmx5IGFzc2VtYmx5RmFpbHVyZUF0PzogJ2Vycm9yJyB8ICd3YXJuJyB8ICdub25lJztcblxuICAvKipcbiAgICogVGhlIHBsdWdpbiBob3N0IHRvIHVzZSBmb3IgbG9hZGluZyBhbmQgcXVlcnlpbmcgcGx1Z2luc1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhIHVuaXF1ZSBpbnN0YW5jZSBvZiBhIHBsdWdpbiBtYW5hZ2luZyBjbGFzcyB3aWxsIGJlIHVzZWQuXG4gICAqXG4gICAqIFVzZSBgdG9vbGtpdC5wbHVnaW5Ib3N0LmxvYWQoKWAgdG8gbG9hZCBwbHVnaW5zIGludG8gdGhlIHBsdWdpbiBob3N0IGZyb20gZGlzay5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBBIGZyZXNoIHBsdWdpbiBob3N0XG4gICAqL1xuICByZWFkb25seSBwbHVnaW5Ib3N0PzogUGx1Z2luSG9zdDtcblxuICAvKipcbiAgICogU2V0IG9mIHVuc3RhYmxlIGZlYXR1cmVzIHRvIG9wdCBpbnRvLiBJZiB5b3UgYXJlIHVzaW5nIGFuIHVuc3RhYmxlIGZlYXR1cmUsXG4gICAqIHlvdSBtdXN0IGV4cGxpY2l0bHkgYWNrbm93bGVkZ2UgdGhhdCB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrcyBvZiB1c2luZyBpdCxcbiAgICogYnkgcGFzc2luZyBpdCBpbiB0aGlzIHNldC5cbiAgICovXG4gIHJlYWRvbmx5IHVuc3RhYmxlRmVhdHVyZXM/OiBBcnJheTxVbnN0YWJsZUZlYXR1cmU+O1xufVxuXG4vKipcbiAqIE5hbWVzIG9mIHRvb2xraXQgZmVhdHVyZXMgdGhhdCBhcmUgc3RpbGwgdW5kZXIgZGV2ZWxvcG1lbnQsIGFuZCBtYXkgY2hhbmdlIGluXG4gKiB0aGUgZnV0dXJlLlxuICovXG5leHBvcnQgdHlwZSBVbnN0YWJsZUZlYXR1cmUgPSAncmVmYWN0b3InIHwgJ2ZsYWdzJztcblxuLyoqXG4gKiBUaGUgQVdTIENESyBQcm9ncmFtbWF0aWMgVG9vbGtpdFxuICovXG5leHBvcnQgY2xhc3MgVG9vbGtpdCBleHRlbmRzIENsb3VkQXNzZW1ibHlTb3VyY2VCdWlsZGVyIHtcbiAgLyoqXG4gICAqIFRoZSB0b29sa2l0IHN0YWNrIG5hbWUgdXNlZCBmb3IgYm9vdHN0cmFwcGluZyByZXNvdXJjZXMuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdG9vbGtpdFN0YWNrTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSW9Ib3N0IG9mIHRoaXMgVG9vbGtpdFxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGlvSG9zdDogSUlvSG9zdDtcblxuICAvKipcbiAgICogVGhlIHBsdWdpbiBob3N0IGZvciBsb2FkaW5nIGFuZCBtYW5hZ2luZyBwbHVnaW5zXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcGx1Z2luSG9zdDogUGx1Z2luSG9zdDtcblxuICAvKipcbiAgICogQ2FjaGUgb2YgdGhlIGludGVybmFsIFNESyBQcm92aWRlciBpbnN0YW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBzZGtQcm92aWRlckNhY2hlPzogU2RrUHJvdmlkZXI7XG5cbiAgcHJpdmF0ZSBiYXNlQ3JlZGVudGlhbHM6IElCYXNlQ3JlZGVudGlhbHNQcm92aWRlcjtcblxuICBwcml2YXRlIHJlYWRvbmx5IHVuc3RhYmxlRmVhdHVyZXM6IEFycmF5PFVuc3RhYmxlRmVhdHVyZT47XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IFRvb2xraXRPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudG9vbGtpdFN0YWNrTmFtZSA9IHByb3BzLnRvb2xraXRTdGFja05hbWUgPz8gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUU7XG5cbiAgICB0aGlzLnBsdWdpbkhvc3QgPSBwcm9wcy5wbHVnaW5Ib3N0ID8/IG5ldyBQbHVnaW5Ib3N0KCk7XG5cbiAgICBsZXQgaW9Ib3N0ID0gcHJvcHMuaW9Ib3N0ID8/IG5ldyBOb25JbnRlcmFjdGl2ZUlvSG9zdCgpO1xuICAgIGlmIChwcm9wcy5lbW9qaXMgPT09IGZhbHNlKSB7XG4gICAgICBpb0hvc3QgPSB3aXRob3V0RW1vamlzKGlvSG9zdCk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb2xvciA9PT0gZmFsc2UpIHtcbiAgICAgIGlvSG9zdCA9IHdpdGhvdXRDb2xvcihpb0hvc3QpO1xuICAgIH1cbiAgICAvLyBBZnRlciByZW1vdmluZyBlbW9qaXMgYW5kIGNvbG9yLCB3ZSBtaWdodCBlbmQgdXAgd2l0aCBmbG9hdGluZyB3aGl0ZXNwYWNlIGF0IGVpdGhlciBlbmQgb2YgdGhlIG1lc3NhZ2VcbiAgICAvLyBUaGlzIGFsc28gcmVtb3ZlcyBuZXdsaW5lcyB0aGF0IHdlIGN1cnJlbnRseSBlbWl0IGZvciBDTEkgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgdGhpcy5pb0hvc3QgPSB3aXRoVHJpbW1lZFdoaXRlc3BhY2UoaW9Ib3N0KTtcblxuICAgIHRoaXMuYmFzZUNyZWRlbnRpYWxzID0gcHJvcHMuc2RrQ29uZmlnPy5iYXNlQ3JlZGVudGlhbHMgPz8gQmFzZUNyZWRlbnRpYWxzLmF3c0NsaUNvbXBhdGlibGUoKTtcbiAgICB0aGlzLnVuc3RhYmxlRmVhdHVyZXMgPSBwcm9wcy51bnN0YWJsZUZlYXR1cmVzID8/IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0byB0aGUgQVdTIFNES1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBzZGtQcm92aWRlcihhY3Rpb246IFRvb2xraXRBY3Rpb24pOiBQcm9taXNlPFNka1Byb3ZpZGVyPiB7XG4gICAgLy8gQHRvZG8gdGhpcyBuZWVkcyB0byBiZSBkaWZmZXJlbnQgaW5zdGFuY2UgcGVyIGFjdGlvblxuICAgIGlmICghdGhpcy5zZGtQcm92aWRlckNhY2hlKSB7XG4gICAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsIGFjdGlvbik7XG4gICAgICBjb25zdCBjbGllbnRDb25maWc6IFNka0Jhc2VDbGllbnRDb25maWcgPSB7XG4gICAgICAgIHJlcXVlc3RIYW5kbGVyOiBzZGtSZXF1ZXN0SGFuZGxlcih0aGlzLnByb3BzLnNka0NvbmZpZz8uaHR0cE9wdGlvbnM/LmFnZW50KSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHRoaXMuYmFzZUNyZWRlbnRpYWxzLnNka0Jhc2VDb25maWcoaW9IZWxwZXIsIGNsaWVudENvbmZpZyk7XG4gICAgICB0aGlzLnNka1Byb3ZpZGVyQ2FjaGUgPSBuZXcgU2RrUHJvdmlkZXIoY29uZmlnLmNyZWRlbnRpYWxQcm92aWRlciwgY29uZmlnLmRlZmF1bHRSZWdpb24sIHtcbiAgICAgICAgaW9IZWxwZXIsXG4gICAgICAgIGxvZ2dlcjogbmV3IElvSG9zdFNka0xvZ2dlcihpb0hlbHBlciksXG4gICAgICAgIHBsdWdpbkhvc3Q6IHRoaXMucGx1Z2luSG9zdCxcbiAgICAgICAgcmVxdWVzdEhhbmRsZXI6IGNsaWVudENvbmZpZy5yZXF1ZXN0SGFuZGxlcixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNka1Byb3ZpZGVyQ2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIHByb3ZpZGUgdGhlIENsb3VkQXNzZW1ibHlTb3VyY2VCdWlsZGVyIHdpdGggcmVxdWlyZWQgdG9vbGtpdCBzZXJ2aWNlc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhc3luYyBzb3VyY2VCdWlsZGVyU2VydmljZXMoKTogUHJvbWlzZTxUb29sa2l0U2VydmljZXM+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaW9IZWxwZXI6IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdhc3NlbWJseScpLFxuICAgICAgc2RrUHJvdmlkZXI6IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoJ2Fzc2VtYmx5JyksXG4gICAgICBwbHVnaW5Ib3N0OiB0aGlzLnBsdWdpbkhvc3QsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb290c3RyYXAgQWN0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYm9vdHN0cmFwKGVudmlyb25tZW50czogQm9vdHN0cmFwRW52aXJvbm1lbnRzLCBvcHRpb25zOiBCb290c3RyYXBPcHRpb25zID0ge30pOiBQcm9taXNlPEJvb3RzdHJhcFJlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmVzdWx0czogRW52aXJvbm1lbnRCb290c3RyYXBSZXN1bHRbXSA9IFtdO1xuXG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnYm9vdHN0cmFwJyk7XG4gICAgY29uc3QgYm9vdHN0cmFwRW52aXJvbm1lbnRzID0gYXdhaXQgZW52aXJvbm1lbnRzLmdldEVudmlyb25tZW50cyh0aGlzLmlvSG9zdCk7XG4gICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy5zb3VyY2UgPz8gQm9vdHN0cmFwU291cmNlLmRlZmF1bHQoKTtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gb3B0aW9ucy5wYXJhbWV0ZXJzO1xuICAgIGNvbnN0IGJvb3RzdHJhcHBlciA9IG5ldyBCb290c3RyYXBwZXIoc291cmNlLCBpb0hlbHBlcik7XG4gICAgY29uc3Qgc2RrUHJvdmlkZXIgPSBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyKCdib290c3RyYXAnKTtcbiAgICBjb25zdCBsaW1pdCA9IHBMaW1pdCgyMCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgICBhd2FpdCBQcm9taXNlLmFsbChib290c3RyYXBFbnZpcm9ubWVudHMubWFwKChlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsIGN1cnJlbnRJZHgpID0+IGxpbWl0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGJvb3RzdHJhcFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uQk9PVFNUUkFQX1NJTkdMRSlcbiAgICAgICAgLmJlZ2luKGAke2NoYWxrLmJvbGQoZW52aXJvbm1lbnQubmFtZSl9OiBib290c3RyYXBwaW5nLi4uYCwge1xuICAgICAgICAgIHRvdGFsOiBib290c3RyYXBFbnZpcm9ubWVudHMubGVuZ3RoLFxuICAgICAgICAgIGN1cnJlbnQ6IGN1cnJlbnRJZHggKyAxLFxuICAgICAgICAgIGVudmlyb25tZW50LFxuICAgICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYm9vdHN0cmFwUmVzdWx0ID0gYXdhaXQgYm9vdHN0cmFwcGVyLmJvb3RzdHJhcEVudmlyb25tZW50KFxuICAgICAgICAgIGVudmlyb25tZW50LFxuICAgICAgICAgIHNka1Byb3ZpZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB0b29sa2l0U3RhY2tOYW1lOiB0aGlzLnRvb2xraXRTdGFja05hbWUsXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzPy5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgdXNlUHJldmlvdXNQYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzPy5rZWVwRXhpc3RpbmdQYXJhbWV0ZXJzLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGJvb3RzdHJhcFJlc3VsdC5ub09wXG4gICAgICAgICAgPyBgIOKchSAgJHtlbnZpcm9ubWVudC5uYW1lfSAobm8gY2hhbmdlcylgXG4gICAgICAgICAgOiBgIOKchSAgJHtlbnZpcm9ubWVudC5uYW1lfWA7XG5cbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k5OTAwLm1zZyhjaGFsay5ncmVlbignXFxuJyArIG1lc3NhZ2UpLCB7IGVudmlyb25tZW50IH0pKTtcbiAgICAgICAgY29uc3QgZW52VGltZSA9IGF3YWl0IGJvb3RzdHJhcFNwYW4uZW5kKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogRW52aXJvbm1lbnRCb290c3RyYXBSZXN1bHQgPSB7XG4gICAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgICAgc3RhdHVzOiBib290c3RyYXBSZXN1bHQubm9PcCA/ICduby1vcCcgOiAnc3VjY2VzcycsXG4gICAgICAgICAgZHVyYXRpb246IGVudlRpbWUuYXNNcyxcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0U5OTAwLm1zZyhgXFxuIOKdjCAgJHtjaGFsay5ib2xkKGVudmlyb25tZW50Lm5hbWUpfSBmYWlsZWQ6ICR7Zm9ybWF0RXJyb3JNZXNzYWdlKGUpfWAsIHsgZXJyb3I6IGUgfSkpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pKSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW52aXJvbm1lbnRzOiByZXN1bHRzLFxuICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aCBBY3Rpb25cbiAgICpcbiAgICogVGhlIGNhbGxlciBhc3N1bWVzIG93bmVyc2hpcCBvZiB0aGUgYENhY2hlZENsb3VkQXNzZW1ibHlgIGFuZCBpcyByZXNwb25zaWJsZSBmb3IgY2FsbGluZyBgZGlzcG9zZSgpYCBvblxuICAgKiBpdCBhZnRlciB1c2UuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGgoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBTeW50aE9wdGlvbnMgPSB7fSk6IFByb21pc2U8Q2FjaGVkQ2xvdWRBc3NlbWJseT4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ3N5bnRoJyk7XG4gICAgY29uc3Qgc2VsZWN0U3RhY2tzID0gb3B0aW9ucy5zdGFja3MgPz8gQUxMX1NUQUNLUztcbiAgICBjb25zdCBzeW50aFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uU1lOVEhfQVNTRU1CTFkpLmJlZ2luKHsgc3RhY2tzOiBzZWxlY3RTdGFja3MgfSk7XG5cbiAgICAvLyBOT1RFOiBOT1QgJ2F3YWl0IHVzaW5nJyBiZWNhdXNlIHdlIHJldHVybiBvd25lcnNoaXAgdG8gdGhlIGNhbGxlclxuICAgIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKHN5bnRoU3Bhbi5hc0hlbHBlciwgY3gpO1xuXG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIoc2VsZWN0U3RhY2tzKTtcbiAgICBjb25zdCBhdXRvVmFsaWRhdGVTdGFja3MgPSBvcHRpb25zLnZhbGlkYXRlU3RhY2tzID8gW2Fzc2VtYmx5LnNlbGVjdFN0YWNrc0ZvclZhbGlkYXRpb24oKV0gOiBbXTtcbiAgICBhd2FpdCB0aGlzLnZhbGlkYXRlU3RhY2tzTWV0YWRhdGEoc3RhY2tzLmNvbmNhdCguLi5hdXRvVmFsaWRhdGVTdGFja3MpLCBzeW50aFNwYW4uYXNIZWxwZXIpO1xuICAgIGF3YWl0IHN5bnRoU3Bhbi5lbmQoKTtcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBzaW5nbGUgc3RhY2ssIHByaW50IGl0IHRvIFNURE9VVFxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgU3VjY2Vzc2Z1bGx5IHN5bnRoZXNpemVkIHRvICR7Y2hhbGsuYmx1ZShwYXRoLnJlc29sdmUoc3RhY2tzLmFzc2VtYmx5LmRpcmVjdG9yeSkpfWA7XG4gICAgY29uc3QgYXNzZW1ibHlEYXRhOiBBc3NlbWJseURhdGEgPSB7XG4gICAgICBhc3NlbWJseURpcmVjdG9yeTogc3RhY2tzLmFzc2VtYmx5LmRpcmVjdG9yeSxcbiAgICAgIHN0YWNrc0NvdW50OiBzdGFja3Muc3RhY2tDb3VudCxcbiAgICAgIHN0YWNrSWRzOiBzdGFja3MuaGllcmFyY2hpY2FsSWRzLFxuICAgIH07XG5cbiAgICBpZiAoc3RhY2tzLnN0YWNrQ291bnQgPT09IDEpIHtcbiAgICAgIGNvbnN0IGZpcnN0U3RhY2sgPSBzdGFja3MuZmlyc3RTdGFjayE7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IGZpcnN0U3RhY2sudGVtcGxhdGU7XG4gICAgICBjb25zdCBvYnNjdXJlZFRlbXBsYXRlID0gb2JzY3VyZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JMTkwMS5tc2cobWVzc2FnZSwge1xuICAgICAgICAuLi5hc3NlbWJseURhdGEsXG4gICAgICAgIHN0YWNrOiB7XG4gICAgICAgICAgc3RhY2tOYW1lOiBmaXJzdFN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICBoaWVyYXJjaGljYWxJZDogZmlyc3RTdGFjay5oaWVyYXJjaGljYWxJZCxcbiAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICBzdHJpbmdpZmllZEpzb246IHNlcmlhbGl6ZVN0cnVjdHVyZShvYnNjdXJlZFRlbXBsYXRlLCB0cnVlKSxcbiAgICAgICAgICBzdHJpbmdpZmllZFlhbWw6IHNlcmlhbGl6ZVN0cnVjdHVyZShvYnNjdXJlZFRlbXBsYXRlLCBmYWxzZSksXG4gICAgICAgIH0sXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vdCBvdXRwdXR0aW5nIHRlbXBsYXRlIHRvIHN0ZG91dCwgbGV0J3MgZXhwbGFpbiB0aGluZ3MgdG8gdGhlIHVzZXIgYSBsaXR0bGUgYml0Li4uXG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTE5MDIubXNnKGNoYWxrLmdyZWVuKG1lc3NhZ2UpLCBhc3NlbWJseURhdGEpKTtcbiAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oYFN1cHBseSBhIHN0YWNrIGlkICgke3N0YWNrcy5zdGFja0FydGlmYWN0cy5tYXAoKHMpID0+IGNoYWxrLmdyZWVuKHMuaGllcmFyY2hpY2FsSWQpKS5qb2luKCcsICcpfSkgdG8gZGlzcGxheSBpdHMgdGVtcGxhdGUuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDYWNoZWRDbG91ZEFzc2VtYmx5KGFzc2VtYmx5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaWZmIEFjdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpZmYoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBEaWZmT3B0aW9ucyA9IHt9KTogUHJvbWlzZTx7IFtuYW1lOiBzdHJpbmddOiBUZW1wbGF0ZURpZmYgfT4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2RpZmYnKTtcbiAgICBjb25zdCBzZWxlY3RTdGFja3MgPSBvcHRpb25zLnN0YWNrcyA/PyBBTExfU1RBQ0tTO1xuICAgIGNvbnN0IHN5bnRoU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5TWU5USF9BU1NFTUJMWSkuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICBhd2FpdCB1c2luZyBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShzeW50aFNwYW4uYXNIZWxwZXIsIGN4KTtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3NWMihzZWxlY3RTdGFja3MpO1xuICAgIGF3YWl0IHN5bnRoU3Bhbi5lbmQoKTtcblxuICAgIGNvbnN0IGRpZmZTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLkRJRkZfU1RBQ0spLmJlZ2luKHsgc3RhY2tzOiBzZWxlY3RTdGFja3MgfSk7XG4gICAgY29uc3QgZGVwbG95bWVudHMgPSBhd2FpdCB0aGlzLmRlcGxveW1lbnRzRm9yQWN0aW9uKCdkaWZmJyk7XG5cbiAgICBjb25zdCBzdHJpY3QgPSAhIW9wdGlvbnMuc3RyaWN0O1xuICAgIGNvbnN0IGNvbnRleHRMaW5lcyA9IG9wdGlvbnMuY29udGV4dExpbmVzIHx8IDM7XG5cbiAgICBsZXQgZGlmZnMgPSAwO1xuXG4gICAgY29uc3QgdGVtcGxhdGVJbmZvcyA9IGF3YWl0IHByZXBhcmVEaWZmKGRpZmZTcGFuLmFzSGVscGVyLCBzdGFja3MsIGRlcGxveW1lbnRzLCBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyKCdkaWZmJyksIG9wdGlvbnMpO1xuICAgIGNvbnN0IHRlbXBsYXRlRGlmZnM6IHsgW25hbWU6IHN0cmluZ106IFRlbXBsYXRlRGlmZiB9ID0ge307XG4gICAgZm9yIChjb25zdCB0ZW1wbGF0ZUluZm8gb2YgdGVtcGxhdGVJbmZvcykge1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IERpZmZGb3JtYXR0ZXIoeyB0ZW1wbGF0ZUluZm8gfSk7XG4gICAgICBjb25zdCBzdGFja0RpZmYgPSBmb3JtYXR0ZXIuZm9ybWF0U3RhY2tEaWZmKHsgc3RyaWN0LCBjb250ZXh0TGluZXMgfSk7XG5cbiAgICAgIC8vIFNlY3VyaXR5IERpZmZcbiAgICAgIGNvbnN0IHNlY3VyaXR5RGlmZiA9IGZvcm1hdHRlci5mb3JtYXRTZWN1cml0eURpZmYoKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFNlY3VyaXR5RGlmZiA9IHNlY3VyaXR5RGlmZi5wZXJtaXNzaW9uQ2hhbmdlVHlwZSAhPT0gUGVybWlzc2lvbkNoYW5nZVR5cGUuTk9ORSA/IHN0YWNrRGlmZi5mb3JtYXR0ZWREaWZmIDogdW5kZWZpbmVkO1xuICAgICAgLy8gV2Ugb25seSB3YXJuIGFib3V0IEJST0FERU5JTkcgY2hhbmdlc1xuICAgICAgaWYgKHNlY3VyaXR5RGlmZi5wZXJtaXNzaW9uQ2hhbmdlVHlwZSA9PSBQZXJtaXNzaW9uQ2hhbmdlVHlwZS5CUk9BREVOSU5HKSB7XG4gICAgICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gJ1RoaXMgZGVwbG95bWVudCB3aWxsIG1ha2UgcG90ZW50aWFsbHkgc2Vuc2l0aXZlIGNoYW5nZXMgYWNjb3JkaW5nIHRvIHlvdXIgY3VycmVudCBzZWN1cml0eSBhcHByb3ZhbCBsZXZlbC5cXG5QbGVhc2UgY29uZmlybSB5b3UgaW50ZW5kIHRvIG1ha2UgdGhlIGZvbGxvd2luZyBtb2RpZmljYXRpb25zOlxcbic7XG4gICAgICAgIGF3YWl0IGRpZmZTcGFuLmRlZmF1bHRzLndhcm4od2FybmluZ01lc3NhZ2UpO1xuICAgICAgICBhd2FpdCBkaWZmU3Bhbi5kZWZhdWx0cy5pbmZvKHNlY3VyaXR5RGlmZi5mb3JtYXR0ZWREaWZmKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhY2sgRGlmZlxuICAgICAgZGlmZnMgKz0gc3RhY2tEaWZmLm51bVN0YWNrc1dpdGhDaGFuZ2VzO1xuICAgICAgYXBwZW5kT2JqZWN0KHRlbXBsYXRlRGlmZnMsIGZvcm1hdHRlci5kaWZmcyk7XG4gICAgICBhd2FpdCBkaWZmU3Bhbi5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTQwMDIubXNnKHN0YWNrRGlmZi5mb3JtYXR0ZWREaWZmLCB7XG4gICAgICAgIHN0YWNrOiB0ZW1wbGF0ZUluZm8ubmV3VGVtcGxhdGUsXG4gICAgICAgIGRpZmZzOiBmb3JtYXR0ZXIuZGlmZnMsXG4gICAgICAgIG51bVN0YWNrc1dpdGhDaGFuZ2VzOiBzdGFja0RpZmYubnVtU3RhY2tzV2l0aENoYW5nZXMsXG4gICAgICAgIHBlcm1pc3Npb25DaGFuZ2VzOiBzZWN1cml0eURpZmYucGVybWlzc2lvbkNoYW5nZVR5cGUsXG4gICAgICAgIGZvcm1hdHRlZERpZmY6IHtcbiAgICAgICAgICBkaWZmOiBzdGFja0RpZmYuZm9ybWF0dGVkRGlmZixcbiAgICAgICAgICBzZWN1cml0eTogZm9ybWF0dGVkU2VjdXJpdHlEaWZmLFxuICAgICAgICB9LFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGF3YWl0IGRpZmZTcGFuLmVuZChg4pyoIE51bWJlciBvZiBzdGFja3Mgd2l0aCBkaWZmZXJlbmNlczogJHtkaWZmc31gLCB7XG4gICAgICBudW1TdGFja3NXaXRoQ2hhbmdlczogZGlmZnMsXG4gICAgICBkaWZmczogdGVtcGxhdGVEaWZmcyxcbiAgICB9KTtcblxuICAgIHJldHVybiB0ZW1wbGF0ZURpZmZzO1xuICB9XG5cbiAgLyoqXG4gICAqIERyaWZ0IEFjdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRyaWZ0KGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgb3B0aW9uczogRHJpZnRPcHRpb25zID0ge30pOiBQcm9taXNlPHsgW25hbWU6IHN0cmluZ106IERyaWZ0UmVzdWx0IH0+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdkcmlmdCcpO1xuICAgIGNvbnN0IHNlbGVjdFN0YWNrcyA9IG9wdGlvbnMuc3RhY2tzID8/IEFMTF9TVEFDS1M7XG4gICAgY29uc3Qgc3ludGhTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlNZTlRIX0FTU0VNQkxZKS5iZWdpbih7IHN0YWNrczogc2VsZWN0U3RhY2tzIH0pO1xuICAgIGF3YWl0IHVzaW5nIGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKHN5bnRoU3Bhbi5hc0hlbHBlciwgY3gpO1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcyk7XG4gICAgYXdhaXQgc3ludGhTcGFuLmVuZCgpO1xuXG4gICAgY29uc3QgZHJpZnRTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLkRSSUZUX0FQUCkuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICBjb25zdCBhbGxEcmlmdFJlc3VsdHM6IHsgW25hbWU6IHN0cmluZ106IERyaWZ0UmVzdWx0IH0gPSB7fTtcbiAgICBjb25zdCB1bmF2YWlsYWJsZURyaWZ0cyA9IFtdO1xuICAgIGNvbnN0IHNka1Byb3ZpZGVyID0gYXdhaXQgdGhpcy5zZGtQcm92aWRlcignZHJpZnQnKTtcblxuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzLnN0YWNrQXJ0aWZhY3RzKSB7XG4gICAgICBjb25zdCBjZm4gPSAoYXdhaXQgc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoc3RhY2suZW52aXJvbm1lbnQsIE1vZGUuRm9yUmVhZGluZykpLnNkay5jbG91ZEZvcm1hdGlvbigpO1xuICAgICAgY29uc3QgZHJpZnRSZXN1bHRzID0gYXdhaXQgZGV0ZWN0U3RhY2tEcmlmdChjZm4sIGRyaWZ0U3Bhbi5hc0hlbHBlciwgc3RhY2suc3RhY2tOYW1lKTtcblxuICAgICAgaWYgKCFkcmlmdFJlc3VsdHMuU3RhY2tSZXNvdXJjZURyaWZ0cykge1xuICAgICAgICBjb25zdCBzdGFja05hbWUgPSBzdGFjay5kaXNwbGF5TmFtZSA/PyBzdGFjay5zdGFja05hbWU7XG4gICAgICAgIHVuYXZhaWxhYmxlRHJpZnRzLnB1c2goc3RhY2tOYW1lKTtcbiAgICAgICAgYXdhaXQgZHJpZnRTcGFuLm5vdGlmeShJTy5DREtfVE9PTEtJVF9XNDU5MS5tc2coYCR7c3RhY2tOYW1lfTogTm8gZHJpZnQgcmVzdWx0cyBhdmFpbGFibGVgLCB7IHN0YWNrIH0pKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBEcmlmdEZvcm1hdHRlcih7IHN0YWNrLCByZXNvdXJjZURyaWZ0czogZHJpZnRSZXN1bHRzLlN0YWNrUmVzb3VyY2VEcmlmdHMgfSk7XG4gICAgICBjb25zdCBkcmlmdE91dHB1dCA9IGZvcm1hdHRlci5mb3JtYXRTdGFja0RyaWZ0KCk7XG4gICAgICBjb25zdCBzdGFja0RyaWZ0ID0ge1xuICAgICAgICBudW1SZXNvdXJjZXNXaXRoRHJpZnQ6IGRyaWZ0T3V0cHV0Lm51bVJlc291cmNlc1dpdGhEcmlmdCxcbiAgICAgICAgbnVtUmVzb3VyY2VzVW5jaGVja2VkOiBkcmlmdE91dHB1dC5udW1SZXNvdXJjZXNVbmNoZWNrZWQsXG4gICAgICAgIGZvcm1hdHRlZERyaWZ0OiB7XG4gICAgICAgICAgdW5jaGFuZ2VkOiBkcmlmdE91dHB1dC51bmNoYW5nZWQsXG4gICAgICAgICAgdW5jaGVja2VkOiBkcmlmdE91dHB1dC51bmNoZWNrZWQsXG4gICAgICAgICAgbW9kaWZpZWQ6IGRyaWZ0T3V0cHV0Lm1vZGlmaWVkLFxuICAgICAgICAgIGRlbGV0ZWQ6IGRyaWZ0T3V0cHV0LmRlbGV0ZWQsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgYWxsRHJpZnRSZXN1bHRzW2Zvcm1hdHRlci5zdGFja05hbWVdID0gc3RhY2tEcmlmdDtcblxuICAgICAgLy8gaGVhZGVyXG4gICAgICBhd2FpdCBkcmlmdFNwYW4uZGVmYXVsdHMuaW5mbyhkcmlmdE91dHB1dC5zdGFja0hlYWRlcik7XG5cbiAgICAgIC8vIHByaW50IHRoZSBkaWZmZXJlbnQgc2VjdGlvbnMgYXQgZGlmZmVyZW50IGxldmVsc1xuICAgICAgaWYgKGRyaWZ0T3V0cHV0LnVuY2hhbmdlZCkge1xuICAgICAgICBhd2FpdCBkcmlmdFNwYW4uZGVmYXVsdHMuZGVidWcoZHJpZnRPdXRwdXQudW5jaGFuZ2VkKTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmlmdE91dHB1dC51bmNoZWNrZWQpIHtcbiAgICAgICAgYXdhaXQgZHJpZnRTcGFuLmRlZmF1bHRzLmRlYnVnKGRyaWZ0T3V0cHV0LnVuY2hlY2tlZCk7XG4gICAgICB9XG4gICAgICBpZiAoZHJpZnRPdXRwdXQubW9kaWZpZWQpIHtcbiAgICAgICAgYXdhaXQgZHJpZnRTcGFuLmRlZmF1bHRzLmluZm8oZHJpZnRPdXRwdXQubW9kaWZpZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGRyaWZ0T3V0cHV0LmRlbGV0ZWQpIHtcbiAgICAgICAgYXdhaXQgZHJpZnRTcGFuLmRlZmF1bHRzLmluZm8oZHJpZnRPdXRwdXQuZGVsZXRlZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1haW4gc3RhY2sgcmVzdWx0XG4gICAgICBhd2FpdCBkcmlmdFNwYW4ubm90aWZ5KElPLkNES19UT09MS0lUX0k0NTkwLm1zZyhkcmlmdE91dHB1dC5zdW1tYXJ5LCB7XG4gICAgICAgIHN0YWNrLFxuICAgICAgICBkcmlmdDogc3RhY2tEcmlmdCxcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBwcmludCBzdW1tYXJ5XG4gICAgY29uc3QgdG90YWxEcmlmdHMgPSBPYmplY3QudmFsdWVzKGFsbERyaWZ0UmVzdWx0cykucmVkdWNlKCh0b3RhbCwgY3VycmVudCkgPT4gdG90YWwgKyAoY3VycmVudC5udW1SZXNvdXJjZXNXaXRoRHJpZnQgPz8gMCksIDApO1xuICAgIGNvbnN0IHRvdGFsVW5jaGVja2VkID0gT2JqZWN0LnZhbHVlcyhhbGxEcmlmdFJlc3VsdHMpLnJlZHVjZSgodG90YWwsIGN1cnJlbnQpID0+IHRvdGFsICsgKGN1cnJlbnQubnVtUmVzb3VyY2VzVW5jaGVja2VkID8/IDApLCAwKTtcbiAgICBhd2FpdCBkcmlmdFNwYW4uZW5kKGBcXG7inKggIE51bWJlciBvZiByZXNvdXJjZXMgd2l0aCBkcmlmdDogJHt0b3RhbERyaWZ0c30ke3RvdGFsVW5jaGVja2VkID8gYCAoJHt0b3RhbFVuY2hlY2tlZH0gdW5jaGVja2VkKWAgOiAnJ31gKTtcbiAgICBpZiAodW5hdmFpbGFibGVEcmlmdHMubGVuZ3RoKSB7XG4gICAgICBhd2FpdCBkcmlmdFNwYW4uZGVmYXVsdHMud2FybihgXFxu4pqg77iPICBGYWlsZWQgdG8gY2hlY2sgZHJpZnQgZm9yICR7dW5hdmFpbGFibGVEcmlmdHMubGVuZ3RofSBzdGFjayhzKS4gQ2hlY2sgbG9nIGZvciBtb3JlIGRldGFpbHMuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbERyaWZ0UmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IEFjdGlvblxuICAgKlxuICAgKiBMaXN0IHNlbGVjdGVkIHN0YWNrcyBhbmQgdGhlaXIgZGVwZW5kZW5jaWVzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdChjeDogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIG9wdGlvbnM6IExpc3RPcHRpb25zID0ge30pOiBQcm9taXNlPFN0YWNrRGV0YWlsc1tdPiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnbGlzdCcpO1xuICAgIGNvbnN0IHNlbGVjdFN0YWNrcyA9IG9wdGlvbnMuc3RhY2tzID8/IEFMTF9TVEFDS1M7XG4gICAgY29uc3Qgc3ludGhTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlNZTlRIX0FTU0VNQkxZKS5iZWdpbih7IHN0YWNrczogc2VsZWN0U3RhY2tzIH0pO1xuICAgIGF3YWl0IHVzaW5nIGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKGlvSGVscGVyLCBjeCk7XG4gICAgY29uc3Qgc3RhY2tDb2xsZWN0aW9uID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIoc2VsZWN0U3RhY2tzKTtcbiAgICBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBzdGFja0NvbGxlY3Rpb24ud2l0aERlcGVuZGVuY2llcygpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBzdGFja3MubWFwKHMgPT4gcy5pZCkuam9pbignXFxuJyk7XG5cbiAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTI5MDEubXNnKG1lc3NhZ2UsIHsgc3RhY2tzIH0pKTtcbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveSBBY3Rpb25cbiAgICpcbiAgICogRGVwbG95cyB0aGUgc2VsZWN0ZWQgc3RhY2tzIGludG8gYW4gQVdTIGFjY291bnRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZXBsb3koY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBEZXBsb3lPcHRpb25zID0ge30pOiBQcm9taXNlPERlcGxveVJlc3VsdD4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2RlcGxveScpO1xuICAgIGF3YWl0IHVzaW5nIGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKGlvSGVscGVyLCBjeCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2RlcGxveShhc3NlbWJseSwgJ2RlcGxveScsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBhbGxvdyBkZXBsb3kgYmVpbmcgY2FsbGVkIGFzIHBhcnQgb2YgdGhlIHdhdGNoIGFjdGlvbi5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2RlcGxveShhc3NlbWJseTogU3RhY2tBc3NlbWJseSwgYWN0aW9uOiAnZGVwbG95JyB8ICd3YXRjaCcsIG9wdGlvbnM6IFByaXZhdGVEZXBsb3lPcHRpb25zID0ge30pOiBQcm9taXNlPERlcGxveVJlc3VsdD4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgYWN0aW9uKTtcbiAgICBjb25zdCBzZWxlY3RTdGFja3MgPSBvcHRpb25zLnN0YWNrcyA/PyBBTExfU1RBQ0tTO1xuICAgIGNvbnN0IHN5bnRoU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5TWU5USF9BU1NFTUJMWSkuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICBjb25zdCBzdGFja0NvbGxlY3Rpb24gPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3NWMihzZWxlY3RTdGFja3MpO1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGVTdGFja3NNZXRhZGF0YShzdGFja0NvbGxlY3Rpb24sIGlvSGVscGVyKTtcbiAgICBjb25zdCBzeW50aER1cmF0aW9uID0gYXdhaXQgc3ludGhTcGFuLmVuZCgpO1xuXG4gICAgY29uc3QgcmV0OiBEZXBsb3lSZXN1bHQgPSB7XG4gICAgICBzdGFja3M6IFtdLFxuICAgIH07XG5cbiAgICBpZiAoc3RhY2tDb2xsZWN0aW9uLnN0YWNrQ291bnQgPT09IDApIHtcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9FNTAwMS5tc2coJ1RoaXMgYXBwIGNvbnRhaW5zIG5vIHN0YWNrcycpKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY29uc3QgZGVwbG95bWVudHMgPSBhd2FpdCB0aGlzLmRlcGxveW1lbnRzRm9yQWN0aW9uKCdkZXBsb3knKTtcbiAgICBjb25zdCBtaWdyYXRvciA9IG5ldyBSZXNvdXJjZU1pZ3JhdG9yKHsgZGVwbG95bWVudHMsIGlvSGVscGVyIH0pO1xuXG4gICAgYXdhaXQgbWlncmF0b3IudHJ5TWlncmF0ZVJlc291cmNlcyhzdGFja0NvbGxlY3Rpb24sIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgcGFyYW1ldGVyTWFwID0gYnVpbGRQYXJhbWV0ZXJNYXAob3B0aW9ucy5wYXJhbWV0ZXJzPy5wYXJhbWV0ZXJzKTtcblxuICAgIGlmIChvcHRpb25zLmRlcGxveW1lbnRNZXRob2Q/Lm1ldGhvZCA9PT0gJ2hvdHN3YXAnKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfVzU0MDAubXNnKFtcbiAgICAgICAgJ+KaoO+4jyBIb3Rzd2FwIGRlcGxveW1lbnRzIGRlbGliZXJhdGVseSBpbnRyb2R1Y2UgQ2xvdWRGb3JtYXRpb24gZHJpZnQgdG8gc3BlZWQgdXAgZGVwbG95bWVudHMnLFxuICAgICAgICAn4pqg77iPIFRoZXkgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgZGV2ZWxvcG1lbnQgLSBuZXZlciB1c2UgdGhlbSBmb3IgeW91ciBwcm9kdWN0aW9uIFN0YWNrcyEnLFxuICAgICAgXS5qb2luKCdcXG4nKSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YWNrcyA9IHN0YWNrQ29sbGVjdGlvbi5zdGFja0FydGlmYWN0cztcbiAgICBjb25zdCBzdGFja091dHB1dHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgICBjb25zdCBvdXRwdXRzRmlsZSA9IG9wdGlvbnMub3V0cHV0c0ZpbGU7XG5cbiAgICBjb25zdCBidWlsZEFzc2V0ID0gYXN5bmMgKGFzc2V0Tm9kZTogQXNzZXRCdWlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGJ1aWxkQXNzZXRTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLkJVSUxEX0FTU0VUKS5iZWdpbih7XG4gICAgICAgIGFzc2V0OiBhc3NldE5vZGUuYXNzZXQsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGRlcGxveW1lbnRzLmJ1aWxkU2luZ2xlQXNzZXQoXG4gICAgICAgIGFzc2V0Tm9kZS5hc3NldE1hbmlmZXN0QXJ0aWZhY3QsXG4gICAgICAgIGFzc2V0Tm9kZS5hc3NldE1hbmlmZXN0LFxuICAgICAgICBhc3NldE5vZGUuYXNzZXQsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGFjazogYXNzZXROb2RlLnBhcmVudFN0YWNrLFxuICAgICAgICAgIHJvbGVBcm46IG9wdGlvbnMucm9sZUFybixcbiAgICAgICAgICBzdGFja05hbWU6IGFzc2V0Tm9kZS5wYXJlbnRTdGFjay5zdGFja05hbWUsXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgYXdhaXQgYnVpbGRBc3NldFNwYW4uZW5kKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHB1Ymxpc2hBc3NldCA9IGFzeW5jIChhc3NldE5vZGU6IEFzc2V0UHVibGlzaE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHB1Ymxpc2hBc3NldFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uUFVCTElTSF9BU1NFVCkuYmVnaW4oe1xuICAgICAgICBhc3NldDogYXNzZXROb2RlLmFzc2V0LFxuICAgICAgfSk7XG4gICAgICBhd2FpdCBkZXBsb3ltZW50cy5wdWJsaXNoU2luZ2xlQXNzZXQoYXNzZXROb2RlLmFzc2V0TWFuaWZlc3QsIGFzc2V0Tm9kZS5hc3NldCwge1xuICAgICAgICBzdGFjazogYXNzZXROb2RlLnBhcmVudFN0YWNrLFxuICAgICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICAgIHN0YWNrTmFtZTogYXNzZXROb2RlLnBhcmVudFN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgZm9yY2VQdWJsaXNoOiBvcHRpb25zLmZvcmNlQXNzZXRQdWJsaXNoaW5nLFxuICAgICAgfSk7XG4gICAgICBhd2FpdCBwdWJsaXNoQXNzZXRTcGFuLmVuZCgpO1xuICAgIH07XG5cbiAgICBjb25zdCBkZXBsb3lTdGFjayA9IGFzeW5jIChzdGFja05vZGU6IFN0YWNrTm9kZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhY2sgPSBzdGFja05vZGUuc3RhY2s7XG4gICAgICBpZiAoc3RhY2tDb2xsZWN0aW9uLnN0YWNrQ291bnQgIT09IDEpIHtcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhY2suZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICBgU3RhY2sgJHtzdGFjay5kaXNwbGF5TmFtZX0gZG9lcyBub3QgZGVmaW5lIGFuIGVudmlyb25tZW50LCBhbmQgQVdTIGNyZWRlbnRpYWxzIGNvdWxkIG5vdCBiZSBvYnRhaW5lZCBmcm9tIHN0YW5kYXJkIGxvY2F0aW9ucyBvciBubyByZWdpb24gd2FzIGNvbmZpZ3VyZWQuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGdlbmVyYXRlZCBzdGFjayBoYXMgbm8gcmVzb3VyY2VzXG4gICAgICBpZiAoT2JqZWN0LmtleXMoc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzIHx8IHt9KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gc3RhY2sgaXMgZW1wdHkgYW5kIGRvZXNuJ3QgZXhpc3QgPT4gZG8gbm90aGluZ1xuICAgICAgICBjb25zdCBzdGFja0V4aXN0cyA9IGF3YWl0IGRlcGxveW1lbnRzLnN0YWNrRXhpc3RzKHsgc3RhY2sgfSk7XG4gICAgICAgIGlmICghc3RhY2tFeGlzdHMpIHtcbiAgICAgICAgICByZXR1cm4gaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX1c1MDIxLm1zZyhgJHtjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKX06IHN0YWNrIGhhcyBubyByZXNvdXJjZXMsIHNraXBwaW5nIGRlcGxveW1lbnQuYCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RhY2sgaXMgZW1wdHksIGJ1dCBleGlzdHMgPT4gZGVsZXRlXG4gICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9XNTAyMi5tc2coYCR7Y2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSl9OiBzdGFjayBoYXMgbm8gcmVzb3VyY2VzLCBkZWxldGluZyBleGlzdGluZyBzdGFjay5gKSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2Rlc3Ryb3koYXNzZW1ibHksICdkZXBsb3knLCB7XG4gICAgICAgICAgc3RhY2tzOiB7IHBhdHRlcm5zOiBbc3RhY2suaGllcmFyY2hpY2FsSWRdLCBzdHJhdGVneTogU3RhY2tTZWxlY3Rpb25TdHJhdGVneS5QQVRURVJOX01VU1RfTUFUQ0hfU0lOR0xFIH0sXG4gICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IGRlcGxveW1lbnRzLnJlYWRDdXJyZW50VGVtcGxhdGUoc3RhY2spO1xuXG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgRGlmZkZvcm1hdHRlcih7XG4gICAgICAgIHRlbXBsYXRlSW5mbzoge1xuICAgICAgICAgIG9sZFRlbXBsYXRlOiBjdXJyZW50VGVtcGxhdGUsXG4gICAgICAgICAgbmV3VGVtcGxhdGU6IHN0YWNrLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNlY3VyaXR5RGlmZiA9IGZvcm1hdHRlci5mb3JtYXRTZWN1cml0eURpZmYoKTtcblxuICAgICAgLy8gU2VuZCBhIHJlcXVlc3QgcmVzcG9uc2Ugd2l0aCB0aGUgZm9ybWF0dGVkIHNlY3VyaXR5IGRpZmYgYXMgcGFydCBvZiB0aGUgbWVzc2FnZSxcbiAgICAgIC8vIGFuZCB0aGUgdGVtcGxhdGUgZGlmZiBhcyBkYXRhXG4gICAgICAvLyAoSW9Ib3N0IGRlY2lkZXMgd2hldGhlciB0byBwcmludCBkZXBlbmRpbmcgb24gcGVybWlzc2lvbkNoYW5nZVR5cGUpXG4gICAgICBjb25zdCBkZXBsb3lNb3RpdmF0aW9uID0gJ1wiLS1yZXF1aXJlLWFwcHJvdmFsXCIgaXMgZW5hYmxlZCBhbmQgc3RhY2sgaW5jbHVkZXMgc2VjdXJpdHktc2Vuc2l0aXZlIHVwZGF0ZXMuJztcbiAgICAgIGNvbnN0IGRlcGxveVF1ZXN0aW9uID0gYCR7c2VjdXJpdHlEaWZmLmZvcm1hdHRlZERpZmZ9XFxuXFxuJHtkZXBsb3lNb3RpdmF0aW9ufVxcbkRvIHlvdSB3aXNoIHRvIGRlcGxveSB0aGVzZSBjaGFuZ2VzYDtcbiAgICAgIGNvbnN0IGRlcGxveUNvbmZpcm1lZCA9IGF3YWl0IGlvSGVscGVyLnJlcXVlc3RSZXNwb25zZShJTy5DREtfVE9PTEtJVF9JNTA2MC5yZXEoZGVwbG95UXVlc3Rpb24sIHtcbiAgICAgICAgbW90aXZhdGlvbjogZGVwbG95TW90aXZhdGlvbixcbiAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgIHBlcm1pc3Npb25DaGFuZ2VUeXBlOiBzZWN1cml0eURpZmYucGVybWlzc2lvbkNoYW5nZVR5cGUsXG4gICAgICAgIHRlbXBsYXRlRGlmZnM6IGZvcm1hdHRlci5kaWZmcyxcbiAgICAgIH0pKTtcbiAgICAgIGlmICghZGVwbG95Q29uZmlybWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0Fib3J0ZWQgYnkgdXNlcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBGb2xsb3dpbmcgYXJlIHRoZSBzYW1lIHNlbWFudGljcyB3ZSBhcHBseSB3aXRoIHJlc3BlY3QgdG8gTm90aWZpY2F0aW9uIEFSTnMgKGRpY3RhdGVkIGJ5IHRoZSBTREspXG4gICAgICAvL1xuICAgICAgLy8gIC0gdW5kZWZpbmVkICA9PiAgY2RrIGlnbm9yZXMgaXQsIGFzIGlmIGl0IHdhc24ndCBzdXBwb3J0ZWQgKGFsbG93cyBleHRlcm5hbCBtYW5hZ2VtZW50KS5cbiAgICAgIC8vICAtIFtdOiAgICAgICAgPT4gIGNkayBtYW5hZ2VzIGl0LCBhbmQgdGhlIHVzZXIgd2FudHMgdG8gd2lwZSBpdCBvdXQuXG4gICAgICAvLyAgLSBbJ2Fybi0xJ10gID0+ICBjZGsgbWFuYWdlcyBpdCwgYW5kIHRoZSB1c2VyIHdhbnRzIHRvIHNldCBpdCB0byBbJ2Fybi0xJ10uXG4gICAgICBjb25zdCBub3RpZmljYXRpb25Bcm5zID0gKCEhb3B0aW9ucy5ub3RpZmljYXRpb25Bcm5zIHx8ICEhc3RhY2subm90aWZpY2F0aW9uQXJucylcbiAgICAgICAgPyAob3B0aW9ucy5ub3RpZmljYXRpb25Bcm5zID8/IFtdKS5jb25jYXQoc3RhY2subm90aWZpY2F0aW9uQXJucyA/PyBbXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAoY29uc3Qgbm90aWZpY2F0aW9uQXJuIG9mIG5vdGlmaWNhdGlvbkFybnMgPz8gW10pIHtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZVNuc1RvcGljQXJuKG5vdGlmaWNhdGlvbkFybikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBOb3RpZmljYXRpb24gYXJuICR7bm90aWZpY2F0aW9uQXJufSBpcyBub3QgYSB2YWxpZCBhcm4gZm9yIGFuIFNOUyB0b3BpY2ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YWNrSW5kZXggPSBzdGFja3MuaW5kZXhPZihzdGFjaykgKyAxO1xuICAgICAgY29uc3QgZGVwbG95U3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5ERVBMT1lfU1RBQ0spXG4gICAgICAgIC5iZWdpbihgJHtjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKX06IGRlcGxveWluZy4uLiBbJHtzdGFja0luZGV4fS8ke3N0YWNrQ29sbGVjdGlvbi5zdGFja0NvdW50fV1gLCB7XG4gICAgICAgICAgdG90YWw6IHN0YWNrQ29sbGVjdGlvbi5zdGFja0NvdW50LFxuICAgICAgICAgIGN1cnJlbnQ6IHN0YWNrSW5kZXgsXG4gICAgICAgICAgc3RhY2ssXG4gICAgICAgIH0pO1xuXG4gICAgICBsZXQgdGFncyA9IG9wdGlvbnMudGFncztcbiAgICAgIGlmICghdGFncyB8fCB0YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0YWdzID0gdGFnc0ZvclN0YWNrKHN0YWNrKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGRlcGxveUR1cmF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGRlcGxveVJlc3VsdDogU3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0IHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIGxldCByb2xsYmFjayA9IG9wdGlvbnMucm9sbGJhY2s7XG4gICAgICAgIGxldCBpdGVyYXRpb24gPSAwO1xuICAgICAgICB3aGlsZSAoIWRlcGxveVJlc3VsdCkge1xuICAgICAgICAgIGlmICgrK2l0ZXJhdGlvbiA+IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ1RoaXMgbG9vcCBzaG91bGQgaGF2ZSBzdGFiaWxpemVkIGluIDIgaXRlcmF0aW9ucywgYnV0IGRpZG5cXCd0LiBJZiB5b3UgYXJlIHNlZWluZyB0aGlzIGVycm9yLCBwbGVhc2UgcmVwb3J0IGl0IGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvbmV3L2Nob29zZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBkZXBsb3ltZW50cy5kZXBsb3lTdGFjayh7XG4gICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgIGRlcGxveU5hbWU6IHN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICAgIHJvbGVBcm46IG9wdGlvbnMucm9sZUFybixcbiAgICAgICAgICAgIHRvb2xraXRTdGFja05hbWU6IHRoaXMudG9vbGtpdFN0YWNrTmFtZSxcbiAgICAgICAgICAgIHJldXNlQXNzZXRzOiBvcHRpb25zLnJldXNlQXNzZXRzLFxuICAgICAgICAgICAgbm90aWZpY2F0aW9uQXJucyxcbiAgICAgICAgICAgIHRhZ3MsXG4gICAgICAgICAgICBkZXBsb3ltZW50TWV0aG9kOiBvcHRpb25zLmRlcGxveW1lbnRNZXRob2QsXG4gICAgICAgICAgICBmb3JjZURlcGxveW1lbnQ6IG9wdGlvbnMuZm9yY2VEZXBsb3ltZW50LFxuICAgICAgICAgICAgcGFyYW1ldGVyczogT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1ldGVyTWFwWycqJ10sIHBhcmFtZXRlck1hcFtzdGFjay5zdGFja05hbWVdKSxcbiAgICAgICAgICAgIHVzZVByZXZpb3VzUGFyYW1ldGVyczogb3B0aW9ucy5wYXJhbWV0ZXJzPy5rZWVwRXhpc3RpbmdQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcm9sbGJhY2ssXG4gICAgICAgICAgICBleHRyYVVzZXJBZ2VudDogb3B0aW9ucy5leHRyYVVzZXJBZ2VudCxcbiAgICAgICAgICAgIGFzc2V0UGFyYWxsZWxpc206IG9wdGlvbnMuYXNzZXRQYXJhbGxlbGlzbSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHN3aXRjaCAoci50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkaWQtZGVwbG95LXN0YWNrJzpcbiAgICAgICAgICAgICAgZGVwbG95UmVzdWx0ID0gcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxwYXVzZWQtbmVlZC1yb2xsYmFjay1maXJzdCc6IHtcbiAgICAgICAgICAgICAgY29uc3QgbW90aXZhdGlvbiA9IHIucmVhc29uID09PSAncmVwbGFjZW1lbnQnXG4gICAgICAgICAgICAgICAgPyBgU3RhY2sgaXMgaW4gYSBwYXVzZWQgZmFpbCBzdGF0ZSAoJHtyLnN0YXR1c30pIGFuZCBjaGFuZ2UgaW5jbHVkZXMgYSByZXBsYWNlbWVudCB3aGljaCBjYW5ub3QgYmUgZGVwbG95ZWQgd2l0aCBcIi0tbm8tcm9sbGJhY2tcImBcbiAgICAgICAgICAgICAgICA6IGBTdGFjayBpcyBpbiBhIHBhdXNlZCBmYWlsIHN0YXRlICgke3Iuc3RhdHVzfSkgYW5kIGNvbW1hbmQgbGluZSBhcmd1bWVudHMgZG8gbm90IGluY2x1ZGUgXCItLW5vLXJvbGxiYWNrXCJgO1xuICAgICAgICAgICAgICBjb25zdCBxdWVzdGlvbiA9IGAke21vdGl2YXRpb259LiBQZXJmb3JtIGEgcmVndWxhciBkZXBsb3ltZW50YDtcblxuICAgICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBpb0hlbHBlci5yZXF1ZXN0UmVzcG9uc2UoSU8uQ0RLX1RPT0xLSVRfSTUwNTAucmVxKHF1ZXN0aW9uLCB7XG4gICAgICAgICAgICAgICAgbW90aXZhdGlvbixcbiAgICAgICAgICAgICAgICBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0Fib3J0ZWQgYnkgdXNlcicpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gUGVyZm9ybSBhIHJvbGxiYWNrXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JvbGxiYWNrKGFzc2VtYmx5LCBhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICBzdGFja3M6IHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm5zOiBbc3RhY2suaGllcmFyY2hpY2FsSWRdLFxuICAgICAgICAgICAgICAgICAgc3RyYXRlZ3k6IFN0YWNrU2VsZWN0aW9uU3RyYXRlZ3kuUEFUVEVSTl9NVVNUX01BVENIX1NJTkdMRSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9ycGhhbkZhaWxlZFJlc291cmNlczogb3B0aW9ucy5vcnBoYW5GYWlsZWRSZXNvdXJjZXNEdXJpbmdSb2xsYmFjayxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gR28gYXJvdW5kIHRocm91Z2ggdGhlICd3aGlsZScgbG9vcCBhZ2FpbiBidXQgc3dpdGNoIHJvbGxiYWNrIHRvIHRydWUuXG4gICAgICAgICAgICAgIHJvbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2VtZW50LXJlcXVpcmVzLXJvbGxiYWNrJzoge1xuICAgICAgICAgICAgICBjb25zdCBtb3RpdmF0aW9uID0gJ0NoYW5nZSBpbmNsdWRlcyBhIHJlcGxhY2VtZW50IHdoaWNoIGNhbm5vdCBiZSBkZXBsb3llZCB3aXRoIFwiLS1uby1yb2xsYmFja1wiJztcbiAgICAgICAgICAgICAgY29uc3QgcXVlc3Rpb24gPSBgJHttb3RpdmF0aW9ufS4gUGVyZm9ybSBhIHJlZ3VsYXIgZGVwbG95bWVudGA7XG5cbiAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkID0gYXdhaXQgaW9IZWxwZXIucmVxdWVzdFJlc3BvbnNlKElPLkNES19UT09MS0lUX0k1MDUwLnJlcShxdWVzdGlvbiwge1xuICAgICAgICAgICAgICAgIG1vdGl2YXRpb24sXG4gICAgICAgICAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdBYm9ydGVkIGJ5IHVzZXInKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEdvIGFyb3VuZCB0aHJvdWdoIHRoZSAnd2hpbGUnIGxvb3AgYWdhaW4gYnV0IHN3aXRjaCByb2xsYmFjayB0byB0cnVlLlxuICAgICAgICAgICAgICByb2xsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBVbmV4cGVjdGVkIHJlc3VsdCB0eXBlIGZyb20gZGVwbG95U3RhY2s6ICR7SlNPTi5zdHJpbmdpZnkocil9LiBJZiB5b3UgYXJlIHNlZWluZyB0aGlzIGVycm9yLCBwbGVhc2UgcmVwb3J0IGl0IGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvbmV3L2Nob29zZWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXBsb3lSZXN1bHQubm9PcFxuICAgICAgICAgID8gYCDinIUgICR7c3RhY2suZGlzcGxheU5hbWV9IChubyBjaGFuZ2VzKWBcbiAgICAgICAgICA6IGAg4pyFICAke3N0YWNrLmRpc3BsYXlOYW1lfWA7XG5cbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1OTAwLm1zZyhjaGFsay5ncmVlbignXFxuJyArIG1lc3NhZ2UpLCBkZXBsb3lSZXN1bHQpKTtcbiAgICAgICAgZGVwbG95RHVyYXRpb24gPSBhd2FpdCBkZXBsb3lTcGFuLnRpbWluZyhJTy5DREtfVE9PTEtJVF9JNTAwMCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlcGxveVJlc3VsdC5vdXRwdXRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgYnVmZmVyID0gWydPdXRwdXRzOiddO1xuICAgICAgICAgIHN0YWNrT3V0cHV0c1tzdGFjay5zdGFja05hbWVdID0gZGVwbG95UmVzdWx0Lm91dHB1dHM7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZGVwbG95UmVzdWx0Lm91dHB1dHMpLnNvcnQoKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkZXBsb3lSZXN1bHQub3V0cHV0c1tuYW1lXTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGAke2NoYWxrLmN5YW4oc3RhY2suaWQpfS4ke2NoYWxrLmN5YW4obmFtZSl9ID0gJHtjaGFsay51bmRlcmxpbmUoY2hhbGsuY3lhbih2YWx1ZSkpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTU5MDEubXNnKGJ1ZmZlci5qb2luKCdcXG4nKSkpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTkwMS5tc2coYFN0YWNrIEFSTjpcXG4ke2RlcGxveVJlc3VsdC5zdGFja0Fybn1gKSk7XG5cbiAgICAgICAgcmV0LnN0YWNrcy5wdXNoKHtcbiAgICAgICAgICBzdGFja05hbWU6IHN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICAgICAgYWNjb3VudDogc3RhY2suZW52aXJvbm1lbnQuYWNjb3VudCxcbiAgICAgICAgICAgIHJlZ2lvbjogc3RhY2suZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhY2tBcm46IGRlcGxveVJlc3VsdC5zdGFja0FybixcbiAgICAgICAgICBvdXRwdXRzOiBkZXBsb3lSZXN1bHQub3V0cHV0cyxcbiAgICAgICAgICBoaWVyYXJjaGljYWxJZDogc3RhY2suaGllcmFyY2hpY2FsSWQsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIC8vIEl0IGhhcyB0byBiZSBleGFjdGx5IHRoaXMgc3RyaW5nIGJlY2F1c2UgYW4gaW50ZWdyYXRpb24gdGVzdCB0ZXN0cyBmb3JcbiAgICAgICAgLy8gXCJib2xkKHN0YWNrbmFtZSkgZmFpbGVkOiBSZXNvdXJjZU5vdFJlYWR5OiA8ZXJyb3I+XCJcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICBbYOKdjCAgJHtjaGFsay5ib2xkKHN0YWNrLnN0YWNrTmFtZSl9IGZhaWxlZDpgLCAuLi4oZS5uYW1lID8gW2Ake2UubmFtZX06YF0gOiBbXSksIGUubWVzc2FnZV0uam9pbignICcpLFxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJhY2VMb2dzKSB7XG4gICAgICAgICAgLy8gZGVwbG95IGNhbGxzIHRoYXQgb3JpZ2luYXRlIGZyb20gd2F0Y2ggd2lsbCBjb21lIHdpdGggdGhlaXIgb3duIGNsb3VkV2F0Y2hMb2dNb25pdG9yXG4gICAgICAgICAgY29uc3QgY2xvdWRXYXRjaExvZ01vbml0b3IgPSBvcHRpb25zLmNsb3VkV2F0Y2hMb2dNb25pdG9yID8/IG5ldyBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yKHsgaW9IZWxwZXIgfSk7XG4gICAgICAgICAgY29uc3QgZm91bmRMb2dHcm91cHNSZXN1bHQgPSBhd2FpdCBmaW5kQ2xvdWRXYXRjaExvZ0dyb3Vwcyhhd2FpdCB0aGlzLnNka1Byb3ZpZGVyKCdkZXBsb3knKSwgaW9IZWxwZXIsIHN0YWNrKTtcbiAgICAgICAgICBjbG91ZFdhdGNoTG9nTW9uaXRvci5hZGRMb2dHcm91cHMoXG4gICAgICAgICAgICBmb3VuZExvZ0dyb3Vwc1Jlc3VsdC5lbnYsXG4gICAgICAgICAgICBmb3VuZExvZ0dyb3Vwc1Jlc3VsdC5zZGssXG4gICAgICAgICAgICBmb3VuZExvZ0dyb3Vwc1Jlc3VsdC5sb2dHcm91cE5hbWVzLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MDMxLm1zZyhgVGhlIGZvbGxvd2luZyBsb2cgZ3JvdXBzIGFyZSBhZGRlZDogJHtmb3VuZExvZ0dyb3Vwc1Jlc3VsdC5sb2dHcm91cE5hbWVzfWApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGFuIG91dHB1dHMgZmlsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIGNyZWF0ZSB0aGUgZmlsZSBwYXRoIGFuZCB3cml0ZSBzdGFjayBvdXRwdXRzIHRvIGl0IG9uY2UuXG4gICAgICAgIC8vIE91dHB1dHMgYXJlIHdyaXR0ZW4gYWZ0ZXIgYWxsIHN0YWNrcyBoYXZlIGJlZW4gZGVwbG95ZWQuIElmIGEgc3RhY2sgZGVwbG95bWVudCBmYWlscyxcbiAgICAgICAgLy8gYWxsIG9mIHRoZSBvdXRwdXRzIGZyb20gc3VjY2Vzc2Z1bGx5IGRlcGxveWVkIHN0YWNrcyBiZWZvcmUgdGhlIGZhaWx1cmUgd2lsbCBzdGlsbCBiZSB3cml0dGVuLlxuICAgICAgICBpZiAob3V0cHV0c0ZpbGUpIHtcbiAgICAgICAgICBmcy5lbnN1cmVGaWxlU3luYyhvdXRwdXRzRmlsZSk7XG4gICAgICAgICAgYXdhaXQgZnMud3JpdGVKc29uKG91dHB1dHNGaWxlLCBzdGFja091dHB1dHMsIHtcbiAgICAgICAgICAgIHNwYWNlczogMixcbiAgICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gc3ludGhEdXJhdGlvbi5hc01zICsgKGRlcGxveUR1cmF0aW9uPy5hc01zID8/IDApO1xuICAgICAgYXdhaXQgZGVwbG95U3Bhbi5lbmQoYFxcbuKcqCAgVG90YWwgdGltZTogJHtmb3JtYXRUaW1lKGR1cmF0aW9uKX1zXFxuYCwgeyBkdXJhdGlvbiB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXNzZXRCdWlsZFRpbWUgPSBvcHRpb25zLmFzc2V0QnVpbGRUaW1lID8/IEFzc2V0QnVpbGRUaW1lLkFMTF9CRUZPUkVfREVQTE9ZO1xuICAgIGNvbnN0IHByZWJ1aWxkQXNzZXRzID0gYXNzZXRCdWlsZFRpbWUgPT09IEFzc2V0QnVpbGRUaW1lLkFMTF9CRUZPUkVfREVQTE9ZO1xuICAgIGNvbnN0IGNvbmN1cnJlbmN5ID0gb3B0aW9ucy5jb25jdXJyZW5jeSB8fCAxO1xuXG4gICAgY29uc3Qgc3RhY2tzQW5kVGhlaXJBc3NldE1hbmlmZXN0cyA9IHN0YWNrcy5mbGF0TWFwKChzdGFjaykgPT4gW1xuICAgICAgc3RhY2ssXG4gICAgICAuLi5zdGFjay5kZXBlbmRlbmNpZXMuZmlsdGVyKHggPT4gY3hhcGkuQXNzZXRNYW5pZmVzdEFydGlmYWN0LmlzQXNzZXRNYW5pZmVzdEFydGlmYWN0KHgpKSxcbiAgICBdKTtcbiAgICBjb25zdCB3b3JrR3JhcGggPSBuZXcgV29ya0dyYXBoQnVpbGRlcihpb0hlbHBlciwgcHJlYnVpbGRBc3NldHMpLmJ1aWxkKHN0YWNrc0FuZFRoZWlyQXNzZXRNYW5pZmVzdHMpO1xuXG4gICAgLy8gVW5sZXNzIHdlIGFyZSBydW5uaW5nIHdpdGggJy0tZm9yY2UnLCBza2lwIGFscmVhZHkgcHVibGlzaGVkIGFzc2V0c1xuICAgIGlmICghb3B0aW9ucy5mb3JjZUFzc2V0UHVibGlzaGluZykge1xuICAgICAgYXdhaXQgcmVtb3ZlUHVibGlzaGVkQXNzZXRzRnJvbVdvcmtHcmFwaCh3b3JrR3JhcGgsIGRlcGxveW1lbnRzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBncmFwaENvbmN1cnJlbmN5OiBDb25jdXJyZW5jeSA9IHtcbiAgICAgICdzdGFjayc6IGNvbmN1cnJlbmN5LFxuICAgICAgJ2Fzc2V0LWJ1aWxkJzogMSwgLy8gVGhpcyB3aWxsIGJlIENQVS1ib3VuZC9tZW1vcnkgYm91bmQsIG1vc3RseSBtYXR0ZXJzIGZvciBEb2NrZXIgYnVpbGRzXG4gICAgICAnYXNzZXQtcHVibGlzaCc6IChvcHRpb25zLmFzc2V0UGFyYWxsZWxpc20gPz8gdHJ1ZSkgPyA4IDogMSwgLy8gVGhpcyB3aWxsIGJlIEkvTy1ib3VuZCwgOCBpbiBwYXJhbGxlbCBzZWVtcyByZWFzb25hYmxlXG4gICAgfTtcblxuICAgIGF3YWl0IHdvcmtHcmFwaC5kb1BhcmFsbGVsKGdyYXBoQ29uY3VycmVuY3ksIHtcbiAgICAgIGRlcGxveVN0YWNrLFxuICAgICAgYnVpbGRBc3NldCxcbiAgICAgIHB1Ymxpc2hBc3NldCxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogV2F0Y2ggQWN0aW9uXG4gICAqXG4gICAqIENvbnRpbnVvdXNseSBvYnNlcnZlIHByb2plY3QgZmlsZXMgYW5kIGRlcGxveSB0aGUgc2VsZWN0ZWQgc3RhY2tzXG4gICAqIGF1dG9tYXRpY2FsbHkgd2hlbiBjaGFuZ2VzIGFyZSBkZXRlY3RlZC4gRGVmYXVsdHMgdG8gaG90c3dhcCBkZXBsb3ltZW50cy5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGltbWVkaWF0ZWx5LCBzdGFydGluZyBhIHdhdGNoZXIgaW4gdGhlIGJhY2tncm91bmQuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgd2F0Y2goY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBXYXRjaE9wdGlvbnMgPSB7fSk6IFByb21pc2U8SVdhdGNoZXI+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICd3YXRjaCcpO1xuICAgIGF3YWl0IHVzaW5nIGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKGlvSGVscGVyLCBjeCwgZmFsc2UpO1xuICAgIGNvbnN0IHJvb3REaXIgPSBvcHRpb25zLndhdGNoRGlyID8/IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBGb3IgdGhlIFwiaW5jbHVkZVwiIHNldHRpbmcsIHRoZSBiZWhhdmlvciBpczpcbiAgICAvLyAxLiBcIndhdGNoXCIgc2V0dGluZyB3aXRob3V0IGFuIFwiaW5jbHVkZVwiIGtleT8gV2UgZGVmYXVsdCB0byBvYnNlcnZpbmcgXCIqKlwiLlxuICAgIC8vIDIuIFwid2F0Y2hcIiBzZXR0aW5nIHdpdGggYW4gZW1wdHkgXCJpbmNsdWRlXCIga2V5PyBXZSBkZWZhdWx0IHRvIG9ic2VydmluZyBcIioqXCIuXG4gICAgLy8gMy4gTm9uLWVtcHR5IFwiaW5jbHVkZVwiIGtleT8gSnVzdCB1c2UgdGhlIFwiaW5jbHVkZVwiIGtleS5cbiAgICBjb25zdCB3YXRjaEluY2x1ZGVzID0gb3B0aW9ucy5pbmNsdWRlID8/IFtdO1xuICAgIGlmICh3YXRjaEluY2x1ZGVzLmxlbmd0aCA8PSAwKSB7XG4gICAgICB3YXRjaEluY2x1ZGVzLnB1c2goJyoqJyk7XG4gICAgfVxuXG4gICAgLy8gRm9yIHRoZSBcImV4Y2x1ZGVcIiBzZXR0aW5nLCB0aGUgYmVoYXZpb3IgaXMgdG8gYWRkIHNvbWUgZGVmYXVsdCBleGNsdWRlcyBpbiBhZGRpdGlvbiB0b1xuICAgIC8vIHBhdHRlcm5zIHNwZWNpZmllZCBieSB0aGUgdXNlciBzZW5zaWJsZSBkZWZhdWx0IHBhdHRlcm5zOlxuICAgIGNvbnN0IHdhdGNoRXhjbHVkZXMgPSBvcHRpb25zLmV4Y2x1ZGUgPz8gWy4uLldBVENIX0VYQ0xVREVfREVGQVVMVFNdO1xuICAgIC8vIDEuIFRoZSBDREsgb3V0cHV0IGRpcmVjdG9yeSwgaWYgaXQgaXMgdW5kZXIgdGhlIHJvb3REaXJcbiAgICBjb25zdCByZWxhdGl2ZU91dERpciA9IHBhdGgucmVsYXRpdmUocm9vdERpciwgYXNzZW1ibHkuZGlyZWN0b3J5KTtcbiAgICBpZiAoQm9vbGVhbihyZWxhdGl2ZU91dERpciAmJiAhcmVsYXRpdmVPdXREaXIuc3RhcnRzV2l0aCgnLi4nICsgcGF0aC5zZXApICYmICFwYXRoLmlzQWJzb2x1dGUocmVsYXRpdmVPdXREaXIpKSkge1xuICAgICAgd2F0Y2hFeGNsdWRlcy5wdXNoKGAke3JlbGF0aXZlT3V0RGlyfS8qKmApO1xuICAgIH1cbiAgICAvLyAyLiBBbnkgZmlsZSB3aG9zZSBuYW1lIHN0YXJ0cyB3aXRoIGEgZG90LlxuICAgIHdhdGNoRXhjbHVkZXMucHVzaCgnLionLCAnKiovLionKTtcbiAgICAvLyAzLiBBbnkgZGlyZWN0b3J5J3MgY29udGVudCB3aG9zZSBuYW1lIHN0YXJ0cyB3aXRoIGEgZG90LlxuICAgIHdhdGNoRXhjbHVkZXMucHVzaCgnKiovLiovKionKTtcbiAgICAvLyA0LiBBbnkgbm9kZV9tb2R1bGVzIGFuZCBpdHMgY29udGVudCAoZXZlbiBpZiBpdCdzIG5vdCBhIEpTL1RTIHByb2plY3QsIHlvdSBtaWdodCBiZSB1c2luZyBhIGxvY2FsIGF3cy1jbGkgcGFja2FnZSlcbiAgICB3YXRjaEV4Y2x1ZGVzLnB1c2goJyoqL25vZGVfbW9kdWxlcy8qKicpO1xuXG4gICAgLy8gUHJpbnQgc29tZSBkZWJ1ZyBpbmZvcm1hdGlvbiBvbiBjb21wdXRlZCBzZXR0aW5nc1xuICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTMxMC5tc2coW1xuICAgICAgYHJvb3QgZGlyZWN0b3J5IHVzZWQgZm9yICd3YXRjaCcgaXM6ICR7cm9vdERpcn1gLFxuICAgICAgYCdpbmNsdWRlJyBwYXR0ZXJucyBmb3IgJ3dhdGNoJzogJHtKU09OLnN0cmluZ2lmeSh3YXRjaEluY2x1ZGVzKX1gLFxuICAgICAgYCdleGNsdWRlJyBwYXR0ZXJucyBmb3IgJ3dhdGNoJzogJHtKU09OLnN0cmluZ2lmeSh3YXRjaEV4Y2x1ZGVzKX1gLFxuICAgIF0uam9pbignXFxuJyksIHtcbiAgICAgIHdhdGNoRGlyOiByb290RGlyLFxuICAgICAgaW5jbHVkZXM6IHdhdGNoSW5jbHVkZXMsXG4gICAgICBleGNsdWRlczogd2F0Y2hFeGNsdWRlcyxcbiAgICB9KSk7XG5cbiAgICAvLyBTaW5jZSAnY2RrIGRlcGxveScgaXMgYSByZWxhdGl2ZWx5IHNsb3cgb3BlcmF0aW9uIGZvciBhICd3YXRjaCcgcHJvY2VzcyxcbiAgICAvLyBpbnRyb2R1Y2UgYSBjb25jdXJyZW5jeSBsYXRjaCB0aGF0IHRyYWNrcyB0aGUgc3RhdGUuXG4gICAgLy8gVGhpcyB3YXksIGlmIGZpbGUgY2hhbmdlIGV2ZW50cyBhcnJpdmUgd2hlbiBhICdjZGsgZGVwbG95JyBpcyBzdGlsbCBleGVjdXRpbmcsXG4gICAgLy8gd2Ugd2lsbCBiYXRjaCB0aGVtLCBhbmQgdHJpZ2dlciBhbm90aGVyICdjZGsgZGVwbG95JyBhZnRlciB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsXG4gICAgLy8gbWFraW5nIHN1cmUgJ2NkayBkZXBsb3kncyAgYWx3YXlzIGV4ZWN1dGUgb25lIGF0IGEgdGltZS5cbiAgICAvLyBIZXJlJ3MgYSBkaWFncmFtIHNob3dpbmcgdGhlIHN0YXRlIHRyYW5zaXRpb25zOlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tICAgICAgICAgICAgICAgIC0tLS0tLS0tICAgIGZpbGUgY2hhbmdlZCAgICAgLS0tLS0tLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgZmlsZSBjaGFuZ2VkXG4gICAgLy8gfCAgICAgICAgICAgIHwgIHJlYWR5IGV2ZW50ICAgfCAgICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tPiB8ICAgICAgICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgcHJlLXJlYWR5ICB8IC0tLS0tLS0tLS0tLS0+IHwgb3BlbiB8ICAgICAgICAgICAgICAgICAgICAgfCBkZXBsb3lpbmcgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgcXVldWVkICAgfCAgICAgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICAgICAgfCA8LS0tLS0tLS0tLS0tLS0tLS0tIHwgICAgICAgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS18XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0gICAgICAgICAgICAgICAgLS0tLS0tLS0gICdjZGsgZGVwbG95JyBkb25lICAtLS0tLS0tLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tXG4gICAgdHlwZSBMYXRjaFN0YXRlID0gJ3ByZS1yZWFkeScgfCAnb3BlbicgfCAnZGVwbG95aW5nJyB8ICdxdWV1ZWQnO1xuICAgIGxldCBsYXRjaDogTGF0Y2hTdGF0ZSA9ICdwcmUtcmVhZHknO1xuXG4gICAgY29uc3QgY2xvdWRXYXRjaExvZ01vbml0b3IgPSBvcHRpb25zLnRyYWNlTG9ncyA/IG5ldyBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yKHsgaW9IZWxwZXIgfSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZGVwbG95QW5kV2F0Y2ggPSBhc3luYyAoKSA9PiB7XG4gICAgICBsYXRjaCA9ICdkZXBsb3lpbmcnIGFzIExhdGNoU3RhdGU7XG4gICAgICBhd2FpdCBjbG91ZFdhdGNoTG9nTW9uaXRvcj8uZGVhY3RpdmF0ZSgpO1xuXG4gICAgICBhd2FpdCB0aGlzLmludm9rZURlcGxveUZyb21XYXRjaChhc3NlbWJseSwgb3B0aW9ucywgY2xvdWRXYXRjaExvZ01vbml0b3IpO1xuXG4gICAgICAvLyBJZiBsYXRjaCBpcyBzdGlsbCAnZGVwbG95aW5nJyBhZnRlciB0aGUgJ2F3YWl0JywgdGhhdCdzIGZpbmUsXG4gICAgICAvLyBidXQgaWYgaXQncyAncXVldWVkJywgdGhhdCBtZWFucyB3ZSBuZWVkIHRvIGRlcGxveSBhZ2FpblxuICAgICAgd2hpbGUgKGxhdGNoID09PSAncXVldWVkJykge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3QgcmVhbGl6ZSBsYXRjaCBjYW4gY2hhbmdlIGJldHdlZW4gJ2F3YWl0cycsXG4gICAgICAgIC8vIGFuZCB0aGlua3MgdGhlIGFib3ZlICd3aGlsZScgY29uZGl0aW9uIGlzIGFsd2F5cyAnZmFsc2UnIHdpdGhvdXQgdGhlIGNhc3RcbiAgICAgICAgbGF0Y2ggPSAnZGVwbG95aW5nJztcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MzE1Lm1zZyhcIkRldGVjdGVkIGZpbGUgY2hhbmdlcyBkdXJpbmcgZGVwbG95bWVudC4gSW52b2tpbmcgJ2NkayBkZXBsb3knIGFnYWluXCIpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnZva2VEZXBsb3lGcm9tV2F0Y2goYXNzZW1ibHksIG9wdGlvbnMsIGNsb3VkV2F0Y2hMb2dNb25pdG9yKTtcbiAgICAgIH1cbiAgICAgIGxhdGNoID0gJ29wZW4nO1xuICAgICAgYXdhaXQgY2xvdWRXYXRjaExvZ01vbml0b3I/LmFjdGl2YXRlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHdhdGNoZXIgPSBjaG9raWRhclxuICAgICAgLndhdGNoKHdhdGNoSW5jbHVkZXMsIHtcbiAgICAgICAgaWdub3JlZDogd2F0Y2hFeGNsdWRlcyxcbiAgICAgICAgY3dkOiByb290RGlyLFxuICAgICAgfSlcbiAgICAgIC5vbigncmVhZHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxhdGNoID0gJ29wZW4nO1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5kZWJ1ZyhcIid3YXRjaCcgcmVjZWl2ZWQgdGhlICdyZWFkeScgZXZlbnQuIEZyb20gbm93IG9uLCBhbGwgZmlsZSBjaGFuZ2VzIHdpbGwgdHJpZ2dlciBhIGRlcGxveW1lbnRcIik7XG4gICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTMxNC5tc2coXCJUcmlnZ2VyaW5nIGluaXRpYWwgJ2NkayBkZXBsb3knXCIpKTtcbiAgICAgICAgYXdhaXQgZGVwbG95QW5kV2F0Y2goKTtcbiAgICAgIH0pXG4gICAgICAub24oJ2FsbCcsIGFzeW5jIChldmVudDogJ2FkZCcgfCAnYWRkRGlyJyB8ICdjaGFuZ2UnIHwgJ3VubGluaycgfCAndW5saW5rRGlyJywgZmlsZVBhdGg6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCB3YXRjaEV2ZW50ID0ge1xuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIHBhdGg6IGZpbGVQYXRoLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobGF0Y2ggPT09ICdwcmUtcmVhZHknKSB7XG4gICAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MzExLm1zZyhgJ3dhdGNoJyBpcyBvYnNlcnZpbmcgJHtldmVudCA9PT0gJ2FkZERpcicgPyAnZGlyZWN0b3J5JyA6ICd0aGUgZmlsZSd9ICcke2ZpbGVQYXRofScgZm9yIGNoYW5nZXNgLCB3YXRjaEV2ZW50KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF0Y2ggPT09ICdvcGVuJykge1xuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTMxMi5tc2coYERldGVjdGVkIGNoYW5nZSB0byAnJHtmaWxlUGF0aH0nICh0eXBlOiAke2V2ZW50fSkuIFRyaWdnZXJpbmcgJ2NkayBkZXBsb3knYCwgd2F0Y2hFdmVudCkpO1xuICAgICAgICAgIGF3YWl0IGRlcGxveUFuZFdhdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcyBtZWFucyBsYXRjaCBpcyBlaXRoZXIgJ2RlcGxveWluZycgb3IgJ3F1ZXVlZCdcbiAgICAgICAgICBsYXRjaCA9ICdxdWV1ZWQnO1xuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTMxMy5tc2coXG4gICAgICAgICAgICBgRGV0ZWN0ZWQgY2hhbmdlIHRvICcke2ZpbGVQYXRofScgKHR5cGU6ICR7ZXZlbnR9KSB3aGlsZSAnY2RrIGRlcGxveScgaXMgc3RpbGwgcnVubmluZy4gV2lsbCBxdWV1ZSBmb3IgYW5vdGhlciBkZXBsb3ltZW50IGFmdGVyIHRoaXMgb25lIGZpbmlzaGVzJ2AsXG4gICAgICAgICAgICB3YXRjaEV2ZW50LFxuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIGNvbnN0IHN0b3BwZWRQcm9taXNlID0gcHJvbWlzZVdpdGhSZXNvbHZlcnM8dm9pZD4oKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhc3luYyBkaXNwb3NlKCkge1xuICAgICAgICAvLyBzdG9wIHRoZSBsb2dzIG1vbml0b3IsIGlmIGl0IGV4aXN0c1xuICAgICAgICBhd2FpdCBjbG91ZFdhdGNoTG9nTW9uaXRvcj8uZGVhY3RpdmF0ZSgpO1xuICAgICAgICAvLyBjbG9zZSB0aGUgd2F0Y2hlciBpdHNlbGZcbiAgICAgICAgYXdhaXQgd2F0Y2hlci5jbG9zZSgpO1xuICAgICAgICAvLyBQcmV2ZW50cyBOb2RlIGZyb20gc3RheWluZyBhbGl2ZS4gVGhlcmUgaXMgbm8gJ2VuZCcgZXZlbnQgdGhhdCB0aGUgd2F0Y2hlciBlbWl0c1xuICAgICAgICAvLyB0aGF0IHdlIGNhbiBrbm93IGl0J3MgZGVmaW5pdGVseSBkb25lLCBzbyBiZXN0IHdlIGNhbiBkbyBpcyB0ZWxsIGl0IHRvIHN0b3Agd2F0Y2hpbmcsXG4gICAgICAgIC8vIHN0b3Aga2VlcGluZyBOb2RlIGFsaXZlLCBhbmQgdGhlbiBwcmV0ZW5kIHRoYXQncyBldmVyeXRoaW5nIHdlIG5lZWRlZCB0byBkby5cbiAgICAgICAgd2F0Y2hlci51bnJlZigpO1xuICAgICAgICBzdG9wcGVkUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiBzdG9wcGVkUHJvbWlzZS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHdhaXRGb3JFbmQoKSB7XG4gICAgICAgIHJldHVybiBzdG9wcGVkUHJvbWlzZS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIFtTeW1ib2wuYXN5bmNEaXNwb3NlXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgfSxcbiAgICB9IHNhdGlzZmllcyBJV2F0Y2hlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xsYmFjayBBY3Rpb25cbiAgICpcbiAgICogUm9sbHMgYmFjayB0aGUgc2VsZWN0ZWQgc3RhY2tzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJvbGxiYWNrKGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgb3B0aW9uczogUm9sbGJhY2tPcHRpb25zID0ge30pOiBQcm9taXNlPFJvbGxiYWNrUmVzdWx0PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAncm9sbGJhY2snKTtcbiAgICBhd2FpdCB1c2luZyBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9yb2xsYmFjayhhc3NlbWJseSwgJ3JvbGxiYWNrJywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGFsbG93IHJvbGxiYWNrIGJlaW5nIGNhbGxlZCBhcyBwYXJ0IG9mIHRoZSBkZXBsb3kgb3Igd2F0Y2ggYWN0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfcm9sbGJhY2soYXNzZW1ibHk6IFN0YWNrQXNzZW1ibHksIGFjdGlvbjogJ3JvbGxiYWNrJyB8ICdkZXBsb3knIHwgJ3dhdGNoJywgb3B0aW9uczogUm9sbGJhY2tPcHRpb25zKTogUHJvbWlzZTxSb2xsYmFja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHNlbGVjdFN0YWNrcyA9IG9wdGlvbnMuc3RhY2tzID8/IEFMTF9TVEFDS1M7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCBhY3Rpb24pO1xuICAgIGNvbnN0IHN5bnRoU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5TWU5USF9BU1NFTUJMWSkuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3NWMihzZWxlY3RTdGFja3MpO1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGVTdGFja3NNZXRhZGF0YShzdGFja3MsIGlvSGVscGVyKTtcbiAgICBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICBjb25zdCByZXQ6IFJvbGxiYWNrUmVzdWx0ID0ge1xuICAgICAgc3RhY2tzOiBbXSxcbiAgICB9O1xuXG4gICAgaWYgKHN0YWNrcy5zdGFja0NvdW50ID09PSAwKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTYwMDEubXNnKCdObyBzdGFja3Mgc2VsZWN0ZWQnKSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGxldCBhbnlSb2xsYmFja2FibGUgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgW2luZGV4LCBzdGFja10gb2Ygc3RhY2tzLnN0YWNrQXJ0aWZhY3RzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgcm9sbGJhY2tTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlJPTExCQUNLX1NUQUNLKS5iZWdpbihgUm9sbGluZyBiYWNrICR7Y2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSl9YCwge1xuICAgICAgICB0b3RhbDogc3RhY2tzLnN0YWNrQ291bnQsXG4gICAgICAgIGN1cnJlbnQ6IGluZGV4ICsgMSxcbiAgICAgICAgc3RhY2ssXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlcGxveW1lbnRzID0gYXdhaXQgdGhpcy5kZXBsb3ltZW50c0ZvckFjdGlvbigncm9sbGJhY2snKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0YWNrUmVzdWx0ID0gYXdhaXQgZGVwbG95bWVudHMucm9sbGJhY2tTdGFjayh7XG4gICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgIHRvb2xraXRTdGFja05hbWU6IHRoaXMudG9vbGtpdFN0YWNrTmFtZSxcbiAgICAgICAgICBvcnBoYW5GYWlsZWRSZXNvdXJjZXM6IG9wdGlvbnMub3JwaGFuRmFpbGVkUmVzb3VyY2VzLFxuICAgICAgICAgIHZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uOiBvcHRpb25zLnZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uLFxuICAgICAgICAgIG9ycGhhbkxvZ2ljYWxJZHM6IG9wdGlvbnMub3JwaGFuTG9naWNhbElkcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc3RhY2tSZXN1bHQubm90SW5Sb2xsYmFja2FibGVTdGF0ZSkge1xuICAgICAgICAgIGFueVJvbGxiYWNrYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcm9sbGJhY2tTcGFuLmVuZCgpO1xuXG4gICAgICAgIHJldC5zdGFja3MucHVzaCh7XG4gICAgICAgICAgZW52aXJvbm1lbnQ6IHtcbiAgICAgICAgICAgIGFjY291bnQ6IHN0YWNrLmVudmlyb25tZW50LmFjY291bnQsXG4gICAgICAgICAgICByZWdpb246IHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YWNrTmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgIHN0YWNrQXJuOiBzdGFja1Jlc3VsdC5zdGFja0FybixcbiAgICAgICAgICByZXN1bHQ6IHN0YWNrUmVzdWx0Lm5vdEluUm9sbGJhY2thYmxlU3RhdGUgPyAnYWxyZWFkeS1zdGFibGUnIDogJ3JvbGxlZC1iYWNrJyxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0U2OTAwLm1zZyhgXFxuIOKdjCAgJHtjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKX0gZmFpbGVkOiAke2Zvcm1hdEVycm9yTWVzc2FnZShlKX1gLCB7IGVycm9yOiBlIH0pKTtcbiAgICAgICAgdGhyb3cgVG9vbGtpdEVycm9yLndpdGhDYXVzZSgnUm9sbGJhY2sgZmFpbGVkICh1c2UgLS1mb3JjZSB0byBvcnBoYW4gZmFpbGluZyByZXNvdXJjZXMpJywgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYW55Um9sbGJhY2thYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdObyBzdGFja3Mgd2VyZSBpbiBhIHN0YXRlIHRoYXQgY291bGQgYmUgcm9sbGVkIGJhY2snKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZmFjdG9yIEFjdGlvbi4gTW92ZXMgcmVzb3VyY2VzIGZyb20gb25lIGxvY2F0aW9uIChzdGFjayArIGxvZ2ljYWwgSUQpIHRvIGFub3RoZXIuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVmYWN0b3IoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBSZWZhY3Rvck9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMucmVxdWlyZVVuc3RhYmxlRmVhdHVyZSgncmVmYWN0b3InKTtcblxuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ3JlZmFjdG9yJyk7XG4gICAgYXdhaXQgdXNpbmcgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2UoaW9IZWxwZXIsIGN4KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVmYWN0b3IoYXNzZW1ibHksIGlvSGVscGVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3JlZmFjdG9yKGFzc2VtYmx5OiBTdGFja0Fzc2VtYmx5LCBpb0hlbHBlcjogSW9IZWxwZXIsIG9wdGlvbnM6IFJlZmFjdG9yT3B0aW9ucyA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFvcHRpb25zLmRyeVJ1bikge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignUmVmYWN0b3IgaXMgbm90IGF2YWlsYWJsZSB5ZXQuIFRvbyBzZWUgdGhlIHByb3Bvc2VkIGNoYW5nZXMsIHVzZSB0aGUgLS1kcnktcnVuIGZsYWcuJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2RrUHJvdmlkZXIgPSBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyKCdyZWZhY3RvcicpO1xuICAgIGNvbnN0IHNlbGVjdGVkU3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIob3B0aW9ucy5zdGFja3MgPz8gQUxMX1NUQUNLUyk7XG4gICAgY29uc3QgZ3JvdXBzID0gYXdhaXQgZ3JvdXBTdGFja3Moc2RrUHJvdmlkZXIsIHNlbGVjdGVkU3RhY2tzLnN0YWNrQXJ0aWZhY3RzLCBvcHRpb25zLmFkZGl0aW9uYWxTdGFja05hbWVzID8/IFtdKTtcblxuICAgIGZvciAobGV0IHsgZW52aXJvbm1lbnQsIGxvY2FsU3RhY2tzLCBkZXBsb3llZFN0YWNrcyB9IG9mIGdyb3Vwcykge1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhmb3JtYXRFbnZpcm9ubWVudFNlY3Rpb25IZWFkZXIoZW52aXJvbm1lbnQpKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IG5ldyBSZWZhY3RvcmluZ0NvbnRleHQoe1xuICAgICAgICAgIGVudmlyb25tZW50LFxuICAgICAgICAgIGRlcGxveWVkU3RhY2tzLFxuICAgICAgICAgIGxvY2FsU3RhY2tzLFxuICAgICAgICAgIG92ZXJyaWRlczogZ2V0T3ZlcnJpZGVzKGVudmlyb25tZW50LCBkZXBsb3llZFN0YWNrcywgbG9jYWxTdGFja3MpLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtYXBwaW5ncyA9IGNvbnRleHQubWFwcGluZ3M7XG5cbiAgICAgICAgaWYgKG1hcHBpbmdzLmxlbmd0aCA9PT0gMCAmJiBjb250ZXh0LmFtYmlndW91c1BhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oJ05vdGhpbmcgdG8gcmVmYWN0b3IuJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0eXBlZE1hcHBpbmdzID0gbWFwcGluZ3NcbiAgICAgICAgICAubWFwKG0gPT4gbS50b1R5cGVkTWFwcGluZygpKVxuICAgICAgICAgIC5maWx0ZXIobSA9PiBtLnR5cGUgIT09ICdBV1M6OkNESzo6TWV0YWRhdGEnKTtcblxuICAgICAgICBsZXQgcmVmYWN0b3JNZXNzYWdlID0gZm9ybWF0VHlwZWRNYXBwaW5ncyh0eXBlZE1hcHBpbmdzKTtcbiAgICAgICAgY29uc3QgcmVmYWN0b3JSZXN1bHQ6IFJlZmFjdG9yUmVzdWx0ID0geyB0eXBlZE1hcHBpbmdzIH07XG5cbiAgICAgICAgaWYgKGNvbnRleHQuYW1iaWd1b3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHBhdGhzID0gY29udGV4dC5hbWJpZ3VvdXNQYXRocztcbiAgICAgICAgICByZWZhY3Rvck1lc3NhZ2UgKz0gJ1xcbicgKyBmb3JtYXRBbWJpZ3VvdXNNYXBwaW5ncyhwYXRocyk7XG4gICAgICAgICAgcmVmYWN0b3JSZXN1bHQuYW1iaWd1b3VzUGF0aHMgPSBwYXRocztcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JODkwMC5tc2cocmVmYWN0b3JNZXNzYWdlLCByZWZhY3RvclJlc3VsdCkpO1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9FODkwMC5tc2coZS5tZXNzYWdlLCB7IGVycm9yOiBlIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRPdmVycmlkZXMoZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBkZXBsb3llZFN0YWNrczogQ2xvdWRGb3JtYXRpb25TdGFja1tdLCBsb2NhbFN0YWNrczogQ2xvdWRGb3JtYXRpb25TdGFja1tdKSB7XG4gICAgICBjb25zdCBtYXBwaW5nR3JvdXAgPSBvcHRpb25zLm92ZXJyaWRlc1xuICAgICAgICA/LmZpbmQoZyA9PiBnLnJlZ2lvbiA9PT0gZW52aXJvbm1lbnQucmVnaW9uICYmIGcuYWNjb3VudCA9PT0gZW52aXJvbm1lbnQuYWNjb3VudCk7XG5cbiAgICAgIGxldCBvdmVycmlkZXM6IFJlc291cmNlTWFwcGluZ1tdID0gW107XG4gICAgICBpZiAobWFwcGluZ0dyb3VwICE9IG51bGwpIHtcbiAgICAgICAgb3ZlcnJpZGVzID0gT2JqZWN0LmVudHJpZXMobWFwcGluZ0dyb3VwLnJlc291cmNlcyA/PyB7fSkubWFwKChbc291cmNlLCBkZXN0aW5hdGlvbl0pID0+IHtcbiAgICAgICAgICBjb25zdCBzb3VyY2VTdGFjayA9IGZpbmRTdGFjayhzb3VyY2UsIGRlcGxveWVkU3RhY2tzKTtcbiAgICAgICAgICBjb25zdCBzb3VyY2VMb2dpY2FsSWQgPSBzb3VyY2Uuc3BsaXQoJy4nKVsxXTtcblxuICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uU3RhY2sgPSBmaW5kU3RhY2soZGVzdGluYXRpb24sIGxvY2FsU3RhY2tzKTtcbiAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkxvZ2ljYWxJZCA9IGRlc3RpbmF0aW9uLnNwbGl0KCcuJylbMV07XG5cbiAgICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlTWFwcGluZyhcbiAgICAgICAgICAgIG5ldyBSZXNvdXJjZUxvY2F0aW9uKHNvdXJjZVN0YWNrLCBzb3VyY2VMb2dpY2FsSWQpLFxuICAgICAgICAgICAgbmV3IFJlc291cmNlTG9jYXRpb24oZGVzdGluYXRpb25TdGFjaywgZGVzdGluYXRpb25Mb2dpY2FsSWQpLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3ZlcnJpZGVzO1xuXG4gICAgICBmdW5jdGlvbiBmaW5kU3RhY2sobG9jYXRpb246IHN0cmluZywgc3RhY2tzOiBDbG91ZEZvcm1hdGlvblN0YWNrW10pOiBDbG91ZEZvcm1hdGlvblN0YWNrIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RhY2tzLmZpbmQoc3RhY2sgPT4ge1xuICAgICAgICAgIGNvbnN0IFtzdGFja05hbWUsIGxvZ2ljYWxJZF0gPSBsb2NhdGlvbi5zcGxpdCgnLicpO1xuICAgICAgICAgIGlmIChzdGFja05hbWUgPT0gbnVsbCB8fCBsb2dpY2FsSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgSW52YWxpZCBsb2NhdGlvbiAnJHtsb2NhdGlvbn0nYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdGFjay5zdGFja05hbWUgPT09IHN0YWNrTmFtZSAmJiBzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXM/Lltsb2dpY2FsSWRdICE9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYENhbm5vdCBmaW5kIHJlc291cmNlIGluIGxvY2F0aW9uICR7bG9jYXRpb259YCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IEFjdGlvblxuICAgKlxuICAgKiBEZXN0cm95cyB0aGUgc2VsZWN0ZWQgU3RhY2tzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRlc3Ryb3koY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBEZXN0cm95T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXN0cm95UmVzdWx0PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnZGVzdHJveScpO1xuICAgIGF3YWl0IHVzaW5nIGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKGlvSGVscGVyLCBjeCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2Rlc3Ryb3koYXNzZW1ibHksICdkZXN0cm95Jywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGFsbG93IGRlc3Ryb3kgYmVpbmcgY2FsbGVkIGFzIHBhcnQgb2YgdGhlIGRlcGxveSBhY3Rpb24uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9kZXN0cm95KGFzc2VtYmx5OiBTdGFja0Fzc2VtYmx5LCBhY3Rpb246ICdkZXBsb3knIHwgJ2Rlc3Ryb3knLCBvcHRpb25zOiBEZXN0cm95T3B0aW9ucyk6IFByb21pc2U8RGVzdHJveVJlc3VsdD4ge1xuICAgIGNvbnN0IHNlbGVjdFN0YWNrcyA9IG9wdGlvbnMuc3RhY2tzID8/IEFMTF9TVEFDS1M7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCBhY3Rpb24pO1xuICAgIGNvbnN0IHN5bnRoU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5TWU5USF9BU1NFTUJMWSkuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICAvLyBUaGUgc3RhY2tzIHdpbGwgaGF2ZSBiZWVuIG9yZGVyZWQgZm9yIGRlcGxveW1lbnQsIHNvIHJldmVyc2UgdGhlbSBmb3IgZGVsZXRpb24uXG4gICAgY29uc3Qgc3RhY2tzID0gKGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcykpLnJldmVyc2VkKCk7XG4gICAgYXdhaXQgc3ludGhTcGFuLmVuZCgpO1xuXG4gICAgY29uc3QgcmV0OiBEZXN0cm95UmVzdWx0ID0ge1xuICAgICAgc3RhY2tzOiBbXSxcbiAgICB9O1xuXG4gICAgY29uc3QgbW90aXZhdGlvbiA9ICdEZXN0cm95aW5nIHN0YWNrcyBpcyBhbiBpcnJldmVyc2libGUgYWN0aW9uJztcbiAgICBjb25zdCBxdWVzdGlvbiA9IGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlOiAke2NoYWxrLnJlZChzdGFja3MuaGllcmFyY2hpY2FsSWRzLmpvaW4oJywgJykpfWA7XG4gICAgY29uc3QgY29uZmlybWVkID0gYXdhaXQgaW9IZWxwZXIucmVxdWVzdFJlc3BvbnNlKElPLkNES19UT09MS0lUX0k3MDEwLnJlcShxdWVzdGlvbiwgeyBtb3RpdmF0aW9uIH0pKTtcbiAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0U3MDEwLm1zZygnQWJvcnRlZCBieSB1c2VyJykpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjb25zdCBkZXN0cm95U3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5ERVNUUk9ZX0FDVElPTikuYmVnaW4oe1xuICAgICAgc3RhY2tzOiBzdGFja3Muc3RhY2tBcnRpZmFjdHMsXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoY29uc3QgW2luZGV4LCBzdGFja10gb2Ygc3RhY2tzLnN0YWNrQXJ0aWZhY3RzLmVudHJpZXMoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNpbmdsZURlc3Ryb3lTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLkRFU1RST1lfU1RBQ0spXG4gICAgICAgICAgICAuYmVnaW4oY2hhbGsuZ3JlZW4oYCR7Y2hhbGsuYmx1ZShzdGFjay5kaXNwbGF5TmFtZSl9OiBkZXN0cm95aW5nLi4uIFske2luZGV4ICsgMX0vJHtzdGFja3Muc3RhY2tDb3VudH1dYCksIHtcbiAgICAgICAgICAgICAgdG90YWw6IHN0YWNrcy5zdGFja0NvdW50LFxuICAgICAgICAgICAgICBjdXJyZW50OiBpbmRleCArIDEsXG4gICAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgZGVwbG95bWVudHMgPSBhd2FpdCB0aGlzLmRlcGxveW1lbnRzRm9yQWN0aW9uKGFjdGlvbik7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVwbG95bWVudHMuZGVzdHJveVN0YWNrKHtcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgZGVwbG95TmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0LnN0YWNrcy5wdXNoKHtcbiAgICAgICAgICAgIGVudmlyb25tZW50OiB7XG4gICAgICAgICAgICAgIGFjY291bnQ6IHN0YWNrLmVudmlyb25tZW50LmFjY291bnQsXG4gICAgICAgICAgICAgIHJlZ2lvbjogc3RhY2suZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YWNrTmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgICAgc3RhY2tBcm46IHJlc3VsdC5zdGFja0FybixcbiAgICAgICAgICAgIHN0YWNrRXhpc3RlZDogcmVzdWx0LnN0YWNrQXJuICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTc5MDAubXNnKGNoYWxrLmdyZWVuKGBcXG4g4pyFICAke2NoYWxrLmJsdWUoc3RhY2suZGlzcGxheU5hbWUpfTogJHthY3Rpb259ZWRgKSwgc3RhY2spKTtcbiAgICAgICAgICBhd2FpdCBzaW5nbGVEZXN0cm95U3Bhbi5lbmQoKTtcbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0U3OTAwLm1zZyhgXFxuIOKdjCAgJHtjaGFsay5ibHVlKHN0YWNrLmRpc3BsYXlOYW1lKX06ICR7YWN0aW9ufSBmYWlsZWQgJHtlfWAsIHsgZXJyb3I6IGUgfSkpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgZGVzdHJveVNwYW4uZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBzdGFja3MgZm9yIGVycm9ycyBhbmQgd2FybmluZ3MgYWNjb3JkaW5nIHRvIHRoZSBDTEkncyBjdXJyZW50IHNldHRpbmdzXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHZhbGlkYXRlU3RhY2tzTWV0YWRhdGEoc3RhY2tzOiBTdGFja0NvbGxlY3Rpb24sIGlvSG9zdDogSW9IZWxwZXIpIHtcbiAgICBjb25zdCBidWlsZGVyID0gKGxldmVsOiBJb01lc3NhZ2VMZXZlbCkgPT4ge1xuICAgICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgcmV0dXJuIElPLkNES19BU1NFTUJMWV9FOTk5OTtcbiAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgcmV0dXJuIElPLkNES19BU1NFTUJMWV9XOTk5OTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gSU8uQ0RLX0FTU0VNQkxZX0k5OTk5O1xuICAgICAgfVxuICAgIH07XG4gICAgYXdhaXQgc3RhY2tzLnZhbGlkYXRlTWV0YWRhdGEoXG4gICAgICB0aGlzLnByb3BzLmFzc2VtYmx5RmFpbHVyZUF0LFxuICAgICAgYXN5bmMgKGxldmVsLCBtc2cpID0+IGlvSG9zdC5ub3RpZnkoYnVpbGRlcihsZXZlbCkubXNnKGBbJHtsZXZlbH0gYXQgJHttc2cuaWR9XSAke21zZy5lbnRyeS5kYXRhfWAsIG1zZykpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZGVwbG95bWVudHMgY2xhc3NcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZGVwbG95bWVudHNGb3JBY3Rpb24oYWN0aW9uOiBUb29sa2l0QWN0aW9uKTogUHJvbWlzZTxEZXBsb3ltZW50cz4ge1xuICAgIHJldHVybiBuZXcgRGVwbG95bWVudHMoe1xuICAgICAgc2RrUHJvdmlkZXI6IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoYWN0aW9uKSxcbiAgICAgIHRvb2xraXRTdGFja05hbWU6IHRoaXMudG9vbGtpdFN0YWNrTmFtZSxcbiAgICAgIGlvSGVscGVyOiBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCBhY3Rpb24pLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbnZva2VEZXBsb3lGcm9tV2F0Y2goXG4gICAgYXNzZW1ibHk6IFN0YWNrQXNzZW1ibHksXG4gICAgb3B0aW9uczogV2F0Y2hPcHRpb25zLFxuICAgIGNsb3VkV2F0Y2hMb2dNb25pdG9yPzogQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvcixcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gd2F0Y2ggZGVmYXVsdHMgdG8gaG90c3dhcCBkZXBsb3ltZW50XG4gICAgY29uc3QgZGVwbG95bWVudE1ldGhvZCA9IG9wdGlvbnMuZGVwbG95bWVudE1ldGhvZCA/PyB7IG1ldGhvZDogJ2hvdHN3YXAnIH07XG4gICAgY29uc3QgZGVwbG95T3B0aW9uczogUHJpdmF0ZURlcGxveU9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgY2xvdWRXYXRjaExvZ01vbml0b3IsXG4gICAgICBkZXBsb3ltZW50TWV0aG9kLFxuICAgICAgZXh0cmFVc2VyQWdlbnQ6IGBjZGstd2F0Y2gvaG90c3dhcC0ke2RlcGxveW1lbnRNZXRob2QubWV0aG9kID09PSAnaG90c3dhcCcgPyAnb24nIDogJ29mZid9YCxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2RlcGxveShhc3NlbWJseSwgJ3dhdGNoJywgZGVwbG95T3B0aW9ucyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBqdXN0IGNvbnRpbnVlIC0gZGVwbG95IHdpbGwgc2hvdyB0aGUgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgZmVhdHVyZSBmbGFnIGluZm9ybWF0aW9uIGZyb20gdGhlIGNsb3VkIGFzc2VtYmx5XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZmxhZ3MoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlKTogUHJvbWlzZTxGZWF0dXJlRmxhZ1tdPiB7XG4gICAgdGhpcy5yZXF1aXJlVW5zdGFibGVGZWF0dXJlKCdmbGFncycpO1xuXG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnZmxhZ3MnKTtcbiAgICBhd2FpdCB1c2luZyBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgIGNvbnN0IGFydGlmYWN0cyA9IE9iamVjdC52YWx1ZXMoYXNzZW1ibHkuY2xvdWRBc3NlbWJseS5tYW5pZmVzdC5hcnRpZmFjdHMgPz8ge30pO1xuICAgIGNvbnN0IGZlYXR1cmVGbGFnUmVwb3J0cyA9IGFydGlmYWN0cy5maWx0ZXIoYSA9PiBhLnR5cGUgPT09IEFydGlmYWN0VHlwZS5GRUFUVVJFX0ZMQUdfUkVQT1JUKTtcblxuICAgIGNvbnN0IGZsYWdzID0gZmVhdHVyZUZsYWdSZXBvcnRzLmZsYXRNYXAocmVwb3J0ID0+IHtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSByZXBvcnQucHJvcGVydGllcyBhcyBGZWF0dXJlRmxhZ1JlcG9ydFByb3BlcnRpZXM7XG4gICAgICBjb25zdCBtb2R1bGVOYW1lID0gcHJvcGVydGllcy5tb2R1bGU7XG5cbiAgICAgIGNvbnN0IGZsYWdzV2l0aFVuY29uZmlndXJlZEJlaGF2ZXNMaWtlID0gT2JqZWN0LmVudHJpZXMocHJvcGVydGllcy5mbGFncylcbiAgICAgICAgLmZpbHRlcigoW18sIGZsYWdJbmZvXSkgPT4gZmxhZ0luZm8udW5jb25maWd1cmVkQmVoYXZlc0xpa2UgIT0gdW5kZWZpbmVkKTtcblxuICAgICAgY29uc3Qgc2hvdWxkSW5jbHVkZVVuY29uZmlndXJlZEJlaGF2ZXNMaWtlID0gZmxhZ3NXaXRoVW5jb25maWd1cmVkQmVoYXZlc0xpa2UubGVuZ3RoID4gMDtcblxuICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMuZmxhZ3MpLm1hcCgoW2ZsYWdOYW1lLCBmbGFnSW5mb10pID0+IHtcbiAgICAgICAgY29uc3QgYmFzZUZsYWcgPSB7XG4gICAgICAgICAgbW9kdWxlOiBtb2R1bGVOYW1lLFxuICAgICAgICAgIG5hbWU6IGZsYWdOYW1lLFxuICAgICAgICAgIHJlY29tbWVuZGVkVmFsdWU6IGZsYWdJbmZvLnJlY29tbWVuZGVkVmFsdWUsXG4gICAgICAgICAgdXNlclZhbHVlOiBmbGFnSW5mby51c2VyVmFsdWUgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBmbGFnSW5mby5leHBsYW5hdGlvbiA/PyAnJyxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc2hvdWxkSW5jbHVkZVVuY29uZmlndXJlZEJlaGF2ZXNMaWtlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmJhc2VGbGFnLFxuICAgICAgICAgICAgdW5jb25maWd1cmVkQmVoYXZlc0xpa2U6IHtcbiAgICAgICAgICAgICAgdjI6IGZsYWdJbmZvLnVuY29uZmlndXJlZEJlaGF2ZXNMaWtlPy52MiA/PyBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlRmxhZztcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZsYWdzO1xuICB9XG5cbiAgcHJpdmF0ZSByZXF1aXJlVW5zdGFibGVGZWF0dXJlKHJlcXVlc3RlZEZlYXR1cmU6IFVuc3RhYmxlRmVhdHVyZSkge1xuICAgIGlmICghdGhpcy51bnN0YWJsZUZlYXR1cmVzLmluY2x1ZGVzKHJlcXVlc3RlZEZlYXR1cmUpKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBVbnN0YWJsZSBmZWF0dXJlICcke3JlcXVlc3RlZEZlYXR1cmV9JyBpcyBub3QgZW5hYmxlZC4gUGxlYXNlIGVuYWJsZSBpdCB1bmRlciAndW5zdGFibGVGZWF0dXJlcydgKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==